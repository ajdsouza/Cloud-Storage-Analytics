Current implementation at GIT

The GIT Implementation loads the raw metrics for each of the storage layers to the EM repository. A PL/SQL package analyzes the loaded metrics.Storage reports are created by the
analysis.

Drawbacks of GIT implementation
	  -  Analysis of the metrics is done much better with  native knowledge of the Operating system in many cases . E.g. On Linux the inode uniquely identifies any file, On Solaris raw and block devices are automatically created for a disk device,while on linux the raw device may be be explicity created.
	 -   Analysis job adds to the load on the repository.
	 -   There is a lag between the time the data was loaded for a host and the time it was analyzed
	 -   The size of raw metrics is much larger than the size of the reporting data generated by analysis.  
	 -   The raw metrics are hardly used directly for any reports.

Proposed implementation.
	 Complete the analysis of the raw metrics on the host . Structure and load the analyzed data to the EM repository.
	 The analysis will be implemented in a perl module. The Storage Analysis perl module will take the raw metrics for each storage layer on the host as input. It will analyze the raw data
	 and instrument the pre-cooked analyzed data as storage data and storage keys metrics. The metrics will be provided to the framework ready to be loaded to the em repository.

	     
	     Schematic 

	     Analyzed Data

	     Storage Analysis Perl Module
		  - OS Native knowledge		  
	     
	     Disk Metrics
	     Software Raid Metrics
	     Volume Manager Metrics
	     Filesystem Metrics
	     NFS metrics
	     Oracle Database Metrics


	     Basic Requirements from raw metrics

	     In addition to the other storage later and entity type specific data the raw metrics for any storage layer will have to provide the storage analysis perl modules with the following information

	     -	  An persistant identifier for an entity on the host.
    	     The operating system will provide a identification for entities which are on the operating system, such an identifier should remain consistent for the same entity across storage layers eg. On any flavor of UNIX the inode will identify any file on the operating system.

	     -	 For entities which are internal to a storage layer, the relation ship between the entities should be obtained from the the interfaces of that storage layer.
	
	     -	 A global unique identifier which will uniquely identify a disk being shared. 

	     -	 Type and Size of the entity being instrumented
 	     

	     Note : A detailed document on metrics for each storage layer will be published as part of the porting notes.


	     What will the Storage Analysis perl module do ?
	     It will invoke the OS specific interfaces to instrument the raw metrics for each storage layer on the Host. It will try to construct the storage layout tree for the host from the distinct set of raw metrics it collects for each storage layer. The entities from a storage layer will be related to the entities in another storage layer using the Operating system specific persistant identifier of the entity. For entities which are internal to a storage layer, the relationship will have already been provided in the raw metrics. The constructed storage layout will enable easy flagging of the used and free devices in the storage layout. It will also enable computing the used and free storage at each entity in the tree. The perlmodule will further analyze the tree to generate the required query flags. Any inconsistencies encountered while performing the analysis will be instrumented in storage issues metric. On completion of the analysis the storage layout will be decomposed into the storage data and storage keys metrics and provided to the em framework for loading to the repository.
