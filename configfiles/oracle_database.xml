<!-- edited with XMLSPY v5 rel. 4 U (http://www.xmlspy.com) by LUCY EPPOLITO (ORACLE CORPORATION) -->
<!-- $Header: oracle_database.xml 22-jul-2004.14:47:48 ajdsouza Exp $
   MODIFIED    (MM/DD/YY)
      ajdsouza  07/22/04 - Changed the db_datafiles, db_redologs, db_controlfiles to oslinetoken executions
      rreilly   07/14/04 - bug 3548431 db_recSegmentSettings_sysseg perf fix 
      ychan     07/13/04 - Fix bug 3738242 
      ychan     07/09/04 - Remove 10gBeta 
      rasundar  07/01/04 - Capitalize s in Number of spilled Messages 
      xuliu     07/01/04 - rac interconnect 
      ychan     06/30/04 - Fix bug 3467825 
      kranjan   06/28/04 - fix for bug 3576903
      mnihalan  06/24/04 - Add metric for Segment Advisor Recommendations 
      jgwang    06/22/04 - 
      jochen    06/21/04 - Add media failure category to alert log 
      jgwang    06/21/04 - add NLS labels for UDMs 
      jstone    06/11/04 - composite key for db_FeatureUsage (3669601) 
      lhan      06/10/04 - UDM change
      jsoule    06/03/04 - relocate oracle_database resources 
      sresrini  05/10/04 - add streams metrics
      sbadrina  05/05/04 - add used size to db_tablespaces 
      ysun      05/04/04 - sync with mainsa
      jochen    04/27/04 - Add minSegSize to wastedSpace 
      jgwang    04/23/04 - sqludm enhancement
      yfeng     04/16/04 - Fix bug 3263351- dummy row with null timestamp
      jsoule    04/14/04 - invert recovery area metric computation 
      ysun      04/08/04 - update global_cache_gets for 9.x
      pbantis   04/05/04 - Update ha_init_params metric 
      rreilly   03/15/04 - add storage policies 
      jsoule    03/09/04 - define column mapping for alertLog 
      ychan     02/18/04 - Fix bug 3450634 
      xshen     02/18/04 - fix bug 3451403 
      jsoule    01/19/04 - fix blocked session count key values 
      hmulling  01/07/04 - do not report default pwd of expired accounts 
      abodge    12/29/03 - Fix JAVASNM ref in invalid objects query 
      yfeng     12/12/03 - Use union all for mgmt_sql_summary 
      yfeng     12/11/03 - Add ValidIf for memt_sql_metric_helper 
      yfeng     12/07/03 - Use the original NLS string for 
      yfeng     12/06/03 - return snap_time for mgmt_sql_metric_helper 
      yfeng     12/05/03 - Modify mgmt_sql_metric_helper 
      nachen    12/05/03 - fix sql for addm findings 
      jsoule    12/04/03 - upload less sys/file metric data 
      nachen    11/25/03 - improve addm performance 
      hmulling  11/24/03 - disable rac use of remote login esm metric 
      jsoule    11/21/03 - add CpuTimingEnabled dynamic property 
      lhan      11/12/03 - Change osm to asm 
      jsoule    11/16/03 - remove line break from nlsid for system_response_time_per_call
      lhan      11/05/03 - add SQL UDM
      abodge    11/06/03 - More recseg perf work 
      jsoule    11/06/03 - add TimeFormat property 
      xshen     11/04/03 - split db_datafiles query to hidden metrics 
      ysun      11/03/03 - update statisics_level
      hmulling  11/03/03 - add help=no_help attribute to esm metrics 
      jsoule    10/30/03 - revert Recovery_Area.Free_Space one last time 
      abodge    10/30/03 - Fix bug 3210014 
      vchao     10/29/03 - Added StatisticsLevel dynamic property
      jsoule    10/28/03 - fix GetArchiveDestination
      jsoule    10/28/03 - use open mode to prevent SQL Response metric
      jsoule    10/27/03 - add open mode dynamic property
      pbantis   10/24/03 - Add log_mode column to ha_info
      abodge    10/23/03 - Restrict segments queries
      vchao     10/24/03 - Bug 3090611. Specify dynamic preoperty of dump_dest
                           in term of ORACLE_SID
      jsoule    10/20/03 - hint bad queries
      gallison  10/19/03 - Add DataGuardStatus to metadata (3202444)
      jaysmith  10/16/03 - add Role property to PushDescriptors
      yfeng     10/16/03 - Fix mgmt_sql_plan metric
      vchao     10/15/03 - Bug 3156858. Provide more/all metrics as column
                           choices forDB target roll table
      jochen    10/08/03 - Enable seg_find/grant_privs
      jsoule    10/15/03 - reintroduce Sessions: Other
      jsoule    10/14/03 - remove key attribute from recovery area
      kmckeen   10/14/03 - Bug 3191581 - update problemTbsp 10i SQL query to
                           use new view
      hmulling  10/10/03 - undo removal of validif because of oci bug
      jsoule    10/07/03 - restore keys to UserBlock alert
      jochen    10/07/03 - Disable seg_find/grant_privs
      jsoule    10/07/03 - restore keys to UserBlock alert
      jsoule    10/06/03 - fix credential info corruption
      ysun      10/06/03 - remove UserBlock for RAC instances
      hmulling2 10/03/03 - remove ValidIf tag for testPrivileges
      jsoule    10/02/03 - fix internal names for wait_sess_cls
      jochen    10/01/03 - Add seg_find/grant_privs
      gallison  10/02/03 - Add dataguard status dynprop
      anajmi    09/30/03 - Allowed 8iR2 ESM metrics where valid
      jsoule    09/30/03 - fix GetOSMInstance dynamic property
      jsoule    09/30/03 - react to v$view definition changes
      abodge    09/30/03 - Enhance mixed-segment-types check
      abodge    09/25/03 - Rework storage policy rule
      eujang    09/27/03 - Changed dbsmp privilege test error message
      jabramso  09/25/03 - ilint (tvmai26) diff
      jsoule    09/23/03 - fix ilint complaint
      eujang    09/22/03 - ESM integration
      abodge    09/19/03 - Add sys users to storage policy metrics
      vchao     09/19/03 - Remove redundant columns from wati_bottlenecks
      kmckeen   09/17/03 - Bug 3115742 - fix performance of 10i problemTbsp query
      abodge    09/17/03 - Improve segment query performance
      kdas      09/16/03 - fix for 3115863
      yfeng     09/11/03 - Add dummy for sql metric for deleting old data
      abodge    09/12/03 - Dont get invalid Java classes
      vchao     09/11/03 - transient time column in time-series metrics
      abodge    09/10/03 - Add tablespace column to rec user metric
      abodge    09/09/03 - Add java class support to Inv Objects metric
      jsoule    09/09/03 - remove fast string lookup for events/stats
      vchao     09/08/03 - Replace Cursor with Consistent Read for
      abodge    09/07/03 - Add inv object config metric
      vchao     09/08/03 - Add NLS for time-series column
      vchao     09/04/03 - Modify metric query for file
      jsoule    09/03/03 - remove unnecessary time counters from
                           wait_bottlenecks metric
      jsoule    08/27/03 - add Recovery_Area data, problemTbsp reversion
      abodge    09/02/03 - Rec TS metric perf (bug 3117736)
      skini     09/02/03 - Typo is host credentials
      vchao     09/02/03 - Implement time_series data
      jochen    08/27/03 - Segment Findings
      jsoule    08/26/03 - handle timed_statistics=FALSE
      jsoule    08/26/03 - handle timed_statistics=FALSE
      skini     08/27/03 - Monitoring credentials for databases
      jsoule    08/25/03 - add finalization for strings
      jaysmith  08/21/03 - add KeyColumn property to AQ PushDescriptor
      abodge    08/22/03 - Correct storage queries
      abodge    08/20/03 - More rework
      abodge    08/14/03 - Rework Rec Seg metric
      xshen     08/15/03 - bug 3100306
      ychan     08/15/03 - Fix bug 3092362
      vchao     08/22/03 - Changed non-threshold-based alert labels
      kmckeen   08/15/03 - Add tbspc space-used metric for 10i db dictionary
                           mngd tbspc
      xshen     08/15/03 - bug 3100306
      pbantis   08/11/03 - No help for Data Guard Name column
      ychan     08/15/03 - Fix bug 3092362
      ysun      08/11/03 - categorize database level server generated alerts
      lhan      08/01/03 - Fix ASM bug 3079858
      jsoule    08/01/03 - modify types of non-threshold based metrics
      vchao     07/31/03 - Modify some NLSIDs from script errors
      jabramso  07/31/03 - Add DOCTYPE
      jsoule    07/29/03 - update active_sessions computation
      rzkrishn  07/25/03 - removing UDM as UI needed
      vchao     07/25/03 - Modified wait_bottlenecks query (10i)
      vchao     07/25/03 - Make wait_sess and sessions_in_wait 9i only
      kmckeen   07/24/03 - Support server-generated tablespace space-used alert
      vchao     07/24/03 -
      vchao     07/24/03 - Bug 3067386. Remove key column for UserBlock (10i)
      vchao     07/23/03 - Add non-threshold based alerts
      pbantis   07/21/03 - Collect HA flashback_on
      vchao     07/21/03 - Change file and service names
      ychan     07/17/03 - remove dup sql
      vchao     07/18/03 - Add NO_HELP for rac_global_cache
      ysun      07/16/03 - remove global cache gets and converts
      vchao     07/15/03 - Add/remove db metrics
      jsoule    07/09/03 -
      jsoule    07/09/03 - limit alert log scanning
      ysun      07/09/03 - update rac global cache
      vchao     07/09/03 - Change metric column types
      kdas      07/10/03 - fix for 3042900
      ysun      07/11/03 - remove gets and converts
      vchao     07/08/03 - Fix dup metric names
      ysun      07/08/03 - remove semi colon
      ysun      07/07/03 - get db unique name and global db cache for 10i
      hying     07/01/03 - Fix bug 2988520
      vchao     06/27/03 - Add more svr-generated alerts
      vchao     06/26/03 - Add server-generated alerts
      gallison  06/25/03 - Make role optional
      gallison  06/23/03 - Add role to SQL fetchlets
      ysun      06/18/03 - update global cache metrics
      xshen     06/16/03 - add next extent
      ychan     06/09/03 - Add more wait metrics
      jsoule    06/06/03 - compute median of sql response time values
      jsoule    06/04/03 - add Queue Monitor events to the idle list
      sbadrina  06/03/03 - change scope to USER for sizeToView in alertlogContent
      aaitghez  05/30/03 - stdin vars
      jochen    05/23/03 - Wasted space recommendation column
      xshen     05/22/03 -
      xshen     05/15/03 - dbconfig is cut over to ecm
      jsoule    05/21/03 - add necessary alertLogStatus columns
      kdas      05/22/03 - tuned sql for hdm rac
      jochen    05/06/03 - Wasted space item properties not required
      jstone    05/14/03 - add rac support
      kdas      05/19/03 - fix hdm sql for performance
      abodge    05/15/03 - Convert strg advsr metrics to config snapshot
      kdas      05/07/03 - fix for HDM metric
      ychan     05/14/03 - Support role
      kdas      05/07/03 - fix for HDM metric
      jsoule    05/06/03 - fix alert log status name
      jsoule    04/25/03 - update alertLog metric column labels
      jstone    04/29/03 - beta 2 revisions
      abodge    04/25/03 - Clean up unused junk
     jsoule    04/23/03 - add no_help attribute
      kdas      04/24/03 - fix for HDM sql
      lhan      04/23/03 - change META_VER since this is different from 4.0
      lhan      04/23/03 - change the display name of columns to fix bug 2910628
      kdas      04/21/03 - support for HDM metric
      jsoule    04/18/03 - fix userBlock metric to eliminate duplicate keys
      lhan      04/18/03 - bug 2877273 - add key to redoLog metric
      pbantis   04/18/03 - Change some of Data Guard columns to numbers
      lhan      04/16/03 - Change query of rbseg to improve performance - bug 2812395
      jsoule    04/15/03 - add rollup alert log metrics per category
      abodge    04/17/03 - Move recSettingsPurge def
      abodge    04/04/03 - Add rec settings metrics
      lhan      04/08/03 - split problemTbsp into two
      ychan     04/05/03 - Add version check for top sql
      jpyang    04/16/03 - fix nlsid
      xshen     04/02/03 - remove free size from dbconfig query
      pbantis   04/01/03 - Ignore rac for Config Mgmt metrics
      vchao     03/31/03 - Change duplicate sql parameter
      jochen    03/24/03 - Add Storage Performance metric
      vchao     03/25/03 - Fix 2852633 - unti for CPU time in sysstat is 1/100
      pbantis   03/20/03 - Add ha_rman_config.
      jstone    03/17/03 - add feature usage metric
      vshah     03/14/03 - Fix bug 2849761
      xshen     02/24/03 - remove db_block_size from db metrics
      yfeng     02/18/03 - Fix bug 2722831 - rewrite query for database resource usage metric
      jsoule    03/07/03 - change CPU Delta label/short label
      gachen    03/03/03 - set username to be cleartext
      gachen    02/28/03 - reenter password
      jsoule    02/21/03 - remove the deduction of background effects
      jsoule    02/18/03 - modify invalid_objects query
      jsoule    02/10/03 - take database-wide rollup out of invalid objects metric (to aggregate)
      ychan     02/11/03 - Fix job sql
      vshah     02/04/03 -
      vshah     02/03/03 - Using binding variables for Top SQL metric
      vshah     02/02/03 - Fix bug 2776576 - use same threshold as in SWRF for Top SQL
      pbantis   02/03/03 - Fix ha_backup sql
      jsoule    01/30/03 - update the 'idle' event list
      jsoule    01/24/03 - ensure no negative CPU Deltas
      jsoule    01/07/03 - catch negative deltas for Throughput metrics, call them counter resets
      pbantis   01/06/03 - Add ha_info, ha_init_params, ha_files, ha_backup, and ha_mttr.
      ysun      12/20/02 - update RAC option criterion
      xshen     12/18/02 - bug 2708271
      ysun      12/04/02 - seperate for RAC instances
      vshah     12/13/02 - Fix bug 2703105
      xshen     11/25/02 - remove dump area from condensed UI
      jsoule    11/22/02 - compute background process times BEFORE total times
      swexler   11/19/02 - add % to sql response
      yfeng     11/13/02 - Fix bug 2663164 - modify query to get sql plan
      hying     11/15/02 - Add archive_dest quota check for 9i
      jsoule    11/05/02 - remove spaces from metric internal names
      xshen     11/05/02 - buffer cache sql
      jsoule    11/04/02 - fix Buffer Cache Hit (%) computation
      jsoule    10/29/02 - deltas, not zeroes
      jsoule    10/23/02 - add SQL*Net message from client to idle events
      ychan     10/24/02 - Remove service name perl trace level
      yfeng     10/23/02 - use group by to get around multiply cost value problem
      jsoule    10/25/02 - make modifications to database target metrics
      jsoule    10/15/02 - change key in alertLog, pass GUID, enable debugging
      ychan     10/15/02 - Change suspended session
      vshah     10/10/02 - dense ui mod
-->
<!DOCTYPE TargetMetadata SYSTEM "../dtds/TargetMetadata.dtd">
<TargetMetadata META_VER="3.0" TYPE="oracle_database" CATEGORY_PROPERTIES="VersionCategory;MCPkg;RACOption;DataGuardStatus" RESOURCE_BUNDLE_PACKAGE="oracle.sysman.db.rsc">
	<Display>
		<Label NLSID="name">Database</Label>
	</Display>
	<!-- Skip all metrics when State columns triggers a severity (MOUNTED database) -->
	<AltSkipCondition METRIC="Response" COLUMN="State"/>
	<!--
  ======================================================================
  == Category:         SQL Response Time
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="sql_response" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="MCPkg" CHOICES="2;3"/>
		</ValidIf>
		<Display>
			<Label NLSID="sql_response">SQL Response Time</Label>
		</Display>
		<TableDescriptor>
			<!-- =========================
        == Time This Capture (t2) ==
        ========================= -->
			<ColumnDescriptor NAME="time2" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP"/>
			<!-- =============================
        == Time Previous Capture (t1) ==
        ============================= -->
			<ColumnDescriptor NAME="time1" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="_time2"/>
			<!-- ===========================
        == Time 2 Captures Ago (t0) ==
        =========================== -->
			<ColumnDescriptor NAME="time0" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="_time1"/>
			<!-- ==============
        == Max(t2, t1) ==
        ============== -->
			<ColumnDescriptor NAME="time1vs2" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="(time1 > time2) ? time1 : time2"/>
			<!-- ==============
        == Max(t2, t0) ==
        ============== -->
			<ColumnDescriptor NAME="time0vs2" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="(time0 > time2) ? time0 : time2"/>
			<!-- ==============
        == Max(t1, t0) ==
        ============== -->
			<ColumnDescriptor NAME="time0vs1" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="_time1vs2"/>
			<!-- =====================
        == Median(t0, t1, t2) ==
        ===================== -->
			<ColumnDescriptor NAME="timeMid" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="((time2 > time0vs1) ? time0vs1 : ((time1 > time0vs2) ? time0vs2 : time1vs2))"/>
			<!-- ==================================================================
        == Time This Capture (if not a spike) otherwise Median of latest 3 ==
        ================================================================== -->
			<ColumnDescriptor NAME="time" TYPE="NUMBER" COMPUTE_EXPR="(time2 > 400) ? timeMid : time2">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sql_response_time">SQL Response Time (%)</Label>
					<ShortName NLSID="sql_response_time_short">Response</ShortName>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
BEGIN
  IF (:1 = 'READ WRITE') THEN
    ----
    -- For a read-write database appropriately configured, try to evaluate.
    ----
    dbsnmp.mgmt_response.get_metric_curs(:2);
  ELSE
    ----
    -- For a read-only database, do not evaluate, but rather return an empty
    -- cursor.
    ----
    DECLARE
      TYPE        data_cursor_type IS REF CURSOR;
      data_cursor data_cursor_type;
    BEGIN
      OPEN data_cursor FOR
        SELECT -1
          FROM dual
         WHERE 0=1;
      :2 := data_cursor;
    END;
  END IF;
END;
]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">OpenMode</Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">2</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>




<Metric NAME="message_statistics" TYPE="TABLE" USAGE_TYPE="VIEW_COLLECT"  IS_METRIC_LONG_RUNNING="FALSE" CONFIG="TRUE">

<ValidIf>
  <CategoryProp NAME="VersionCategory" CHOICES="10gR1" />
</ValidIf>
<Display>
	<Label NLSID="message_statistics">Streams Capture Message Statistics</Label>
</Display>
<TableDescriptor SKIP_TARGET_COLUMN="FALSE" SKIP_METRIC_COLUMN="FALSE" SKIP_COLLTIME_PK="FALSE" SKIP_COLLTIME_COLUMN="FALSE">
 <ColumnDescriptor NAME="CAPTURE_NAME" TYPE="STRING" IS_KEY="TRUE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
 <Display>
	<Label NLSID="message_statistics_capture_name">Capture Name</Label>
</Display>
 </ColumnDescriptor>

 <ColumnDescriptor NAME="TOTAL_MESSAGES_CAPTURED" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
<Display>
	<Label NLSID="message_statistics_total_messages_captured">Total Messages Captured</Label>
</Display>

 </ColumnDescriptor>

 <ColumnDescriptor NAME="TOTAL_MESSAGES_ENQUEUED" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">

 <Display>
	<Label NLSID="message_statistics_total_messages_enqueued">Total Messages Enqueued</Label>
</Display>
</ColumnDescriptor>
</TableDescriptor>



<QueryDescriptor FETCHLET_ID="SQL" NEED_CHARSET_CONVERT="TRUE">
 <Property NAME="STATEMENT" SCOPE="GLOBAL" OPTIONAL="FALSE">
 <![CDATA[
   SELECT  CAPTURE_NAME,TOTAL_MESSAGES_CAPTURED,TOTAL_MESSAGES_ENQUEUED FROM V$STREAMS_CAPTURE
  ]]> 
  </Property>
  <Property NAME="MachineName" SCOPE="INSTANCE" OPTIONAL="FALSE">MachineName</Property> 
  <Property NAME="Port" SCOPE="INSTANCE" OPTIONAL="FALSE">Port</Property>
  <Property NAME="SID" SCOPE="INSTANCE" OPTIONAL="FALSE">SID</Property> 
  <Property NAME="UserName" SCOPE="INSTANCE" OPTIONAL="FALSE">UserName</Property>
  <Property NAME="password" SCOPE="INSTANCE" OPTIONAL="FALSE">password</Property> 
  <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property> 
  </QueryDescriptor>


</Metric>










<Metric NAME="queue_statistics" TYPE="TABLE" USAGE_TYPE="VIEW_COLLECT"  IS_METRIC_LONG_RUNNING="FALSE" CONFIG="TRUE">

<ValidIf>
  <CategoryProp NAME="VersionCategory" CHOICES="10gR1" />
</ValidIf>
<Display>
	<Label NLSID="queue_statistics">Streams Capture Queue Statistics</Label>
</Display>
<TableDescriptor SKIP_TARGET_COLUMN="FALSE" SKIP_METRIC_COLUMN="FALSE" SKIP_COLLTIME_PK="FALSE" SKIP_COLLTIME_COLUMN="FALSE">
 <ColumnDescriptor NAME="CAPTURE_NAME" TYPE="STRING" IS_KEY="TRUE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
<Display>
	<Label NLSID="queue_statistics_capture_name">Capture Name</Label>
</Display>

 </ColumnDescriptor>

 <ColumnDescriptor NAME="NUM_MSGS" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
 <Display>
	<Label NLSID="queue_statistics_num_msgs">Number of Messages</Label>
</Display>
 </ColumnDescriptor>

 <ColumnDescriptor NAME="SPILL_MSGS" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
 <Display>
	<Label NLSID="queue_statistics_spill_msgs">Number of Spilled Messages</Label>
</Display>
 </ColumnDescriptor>

</TableDescriptor>



<QueryDescriptor FETCHLET_ID="SQL" NEED_CHARSET_CONVERT="TRUE">
 <Property NAME="STATEMENT" SCOPE="GLOBAL" OPTIONAL="FALSE">
 <![CDATA[
   SELECT CAPTURE_NAME, NUM_MSGS, SPILL_MSGS FROM V$BUFFERED_QUEUES Q,DBA_CAPTURE C
   WHERE  Q.QUEUE_SCHEMA=C.QUEUE_OWNER AND Q.QUEUE_NAME=C.QUEUE_NAME
  ]]>
  </Property>
  <Property NAME="MachineName" SCOPE="INSTANCE" OPTIONAL="FALSE">MachineName</Property>
  <Property NAME="Port" SCOPE="INSTANCE" OPTIONAL="FALSE">Port</Property>
  <Property NAME="SID" SCOPE="INSTANCE" OPTIONAL="FALSE">SID</Property>
  <Property NAME="UserName" SCOPE="INSTANCE" OPTIONAL="FALSE">UserName</Property>
  <Property NAME="password" SCOPE="INSTANCE" OPTIONAL="FALSE">password</Property>
  <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
  </QueryDescriptor>


</Metric>


<Metric NAME="propagation_statistics" TYPE="TABLE" USAGE_TYPE="VIEW_COLLECT"  IS_METRIC_LONG_RUNNING="FALSE" CONFIG="TRUE">

<ValidIf>
  <CategoryProp NAME="VersionCategory" CHOICES="10gR1" />
</ValidIf>
<Display>
	<Label NLSID="propagation_statistics">Streams Propagation Statistics</Label>
</Display>
<TableDescriptor SKIP_TARGET_COLUMN="FALSE" SKIP_METRIC_COLUMN="FALSE" SKIP_COLLTIME_PK="FALSE" SKIP_COLLTIME_COLUMN="FALSE">
 <ColumnDescriptor NAME="PROPAGATION_NAME" TYPE="STRING" IS_KEY="TRUE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
 <Display>
	<Label NLSID="propagation_statistics_propagation_name">Propagation Name</Label>
</Display>
 </ColumnDescriptor>

 <ColumnDescriptor NAME="READY" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">
<Display>
	<Label NLSID="propagation_statistics_ready">Ready</Label>
</Display>

 </ColumnDescriptor>

 <ColumnDescriptor NAME="WAITING" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">

 <Display>
	<Label NLSID="propagation_statistics_waiting">Waiting</Label>
</Display>
</ColumnDescriptor>

<ColumnDescriptor NAME="EXPIRED" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="FALSE" IS_LONG_TEXT="FALSE" IS_DATE="FALSE" STATELESS_ALERTS="FALSE" IS_TIMESTAMP="FALSE">

 <Display>
	<Label NLSID="propagation_statistics_expired">Expired</Label>
</Display>
</ColumnDescriptor>
</TableDescriptor>



<QueryDescriptor FETCHLET_ID="SQL" NEED_CHARSET_CONVERT="TRUE">
 <Property NAME="STATEMENT" SCOPE="GLOBAL" OPTIONAL="FALSE">
 <![CDATA[
   SELECT PROPAGATION_NAME,WAITING,READY,EXPIRED FROM DBA_PROPAGATION A ,V$BUFFERED_QUEUES B, GV$AQ C
   WHERE A.SOURCE_QUEUE_OWNER = B.QUEUE_SCHEMA AND A.SOURCE_QUEUE_NAME = B.QUEUE_NAME AND B.QUEUE_ID = C.QID
  ]]>
  </Property>
  <Property NAME="MachineName" SCOPE="INSTANCE" OPTIONAL="FALSE">MachineName</Property> 
  <Property NAME="Port" SCOPE="INSTANCE" OPTIONAL="FALSE">Port</Property>
  <Property NAME="SID" SCOPE="INSTANCE" OPTIONAL="FALSE">SID</Property> 
  <Property NAME="UserName" SCOPE="INSTANCE" OPTIONAL="FALSE">UserName</Property>
  <Property NAME="password" SCOPE="INSTANCE" OPTIONAL="FALSE">password</Property> 
  <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property> 
  </QueryDescriptor>


</Metric>















	<!--
  ======================================================================
  == Category:         Throughput
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="instance_throughput" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="instance_throughput">Throughput</Label>
		</Display>
		<TableDescriptor>
			<!-- columns provided by the query descriptor's fetchlet call -->
			<!-- Note: The order of these columns must match the output ADT. -->
			<!--       The field name matches the column name only for clarity. -->
			<ColumnDescriptor NAME="logons_current" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logons_current">All Sessions</Label>
					<ShortName NLSID="instance_throughput_logons_current">All Sessions</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logons_cumulative" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_logons_cumulative">logons cumulative</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="parses" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_parses">parse count (total)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hard_parses" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_hard_parses">parse count (hard)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="executions" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_executions">execution count</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="user_calls" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_user_calls">user calls</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recursive_calls" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_recursive_calls">recursive calls</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sorts_memory" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_sorts_memory">sorts (memory)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sorts_disk" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_sorts_disk">sorts (disk)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sorts_rows" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_sorts_rows">sorts (rows)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logical_reads" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_logical_reads">session logical reads</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physical_reads" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_physical_reads">physical reads</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="table_scans_long" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_table_scans_long">table scans (long tables)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="index_ffs_full" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_index_ffs_full">index fast full scans (full)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physical_writes" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_physical_writes">physical writes</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bytes_to_client" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_bytes_to_client">bytes sent via SQL*Net to client</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bytes_from_client" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_bytes_from_client">bytes received via SQL*Net from client</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bytes_to_dblink" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_bytes_to_dblink">bytes sent via SQL*Net to dblink</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bytes_from_dblink" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_bytes_from_dblink">bytes received via SQL*Net from dblink</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="commits" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_commits">user commits</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbwr_checkpoints" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_dbwr_checkpoints">DBWR checkpoints</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rollbacks" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_rollbacks">user rollbacks</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redo_size" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_redo_size">redo size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redo_writes" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_throughput_redo_writes">redo writes</Label>
				</Display>
			</ColumnDescriptor>
			<!-- intermediate columns to be used in column computations below -->
			<!-- Note: These columns must precede their use. -->
			<ColumnDescriptor NAME="transactions" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP" COMPUTE_EXPR="(commits + rollbacks > _commits + _rollbacks) ? (commits - _commits) + (rollbacks - _rollbacks) : 0">
				<Display>
					<Label NLSID="instance_throughput_transactions">transactions</Label>
				</Display>
			</ColumnDescriptor>
			<!-- columns based on deltas or other computations from counters -->
			<ColumnDescriptor NAME="transactions_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="transactions/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_transactions_ps">Number of Transactions (per second)</Label>
					<ShortName NLSID="instance_throughput_transactions_ps_short">Transactions/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreads_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_physical_reads > physical_reads) ? (1/0) : (physical_reads - _physical_reads)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreads_ps">Physical Reads (per second)</Label>
					<ShortName NLSID="instance_throughput_physreads_ps_short">Physical Reads/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreads_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_physical_reads > physical_reads) ? (1/0) : (physical_reads - _physical_reads)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreads_pt">Physical Reads (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwrites_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_physical_writes > physical_writes) ? (1/0) : (physical_writes - _physical_writes)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwrites_ps">Physical Writes (per second)</Label>
					<ShortName NLSID="instance_throughput_physwrites_ps_short">Phys Writes/sec</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwrites_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_physical_writes > physical_writes) ? (1/0) : (physical_writes - _physical_writes)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwrites_pt">Physical Writes (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redosize_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_redo_size > redo_size) ? (1/0) : (redo_size - _redo_size)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redosize_ps">Redo Generated (per second)</Label>
					<ShortName NLSID="instance_throughput_redosize_ps_short">Redo Size/sec</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redosize_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_redo_size > redo_size) ? (1/0) : (redo_size - _redo_size)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redosize_pt">Redo Generated (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logons_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_logons_cumulative > logons_cumulative) ? (1/0) : (logons_cumulative - _logons_cumulative)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logons_ps">Cumulative Logons (per second)</Label>
					<ShortName NLSID="instance_throughput_logons_ps_short">Logons/sec</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logons_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_logons_cumulative > logons_cumulative) ? (1/0) : (logons_cumulative - _logons_cumulative)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logons_pt">Cumulative Logons (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="commits_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_commits > commits) ? (1/0) : (commits - _commits)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_commits_ps">User Commits (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="commits_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_commits > commits) ? (1/0) : (commits - _commits)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_commits_pt">User Commits (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rollbacks_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_rollbacks > rollbacks) ? (1/0) : (rollbacks - _rollbacks)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_rollbacks_ps">User Rollbacks (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rollbacks_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_rollbacks > rollbacks) ? (1/0) : (rollbacks - _rollbacks)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_rollbacks_pt">User Rollbacks (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="usercalls_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_user_calls > user_calls) ? (1/0) : (user_calls - _user_calls)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_usercalls_ps">User Calls (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="usercalls_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_user_calls > user_calls) ? (1/0) : (user_calls - _user_calls)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_usercalls_pt">User Calls (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recurscalls_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_recursive_calls > recursive_calls) ? (1/0) : (recursive_calls - _recursive_calls)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_recurscalls_ps">Recursive Calls (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recurscalls_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_recursive_calls > recursive_calls) ? (1/0) : (recursive_calls - _recursive_calls)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_recurscalls_pt">Recursive Calls (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logreads_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_logical_reads > logical_reads) ? (1/0) : (logical_reads - _logical_reads)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logreads_ps">Session Logical Reads (per second)</Label>
					<ShortName NLSID="instance_throughput_logreads_ps_short">Logical Reads/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logreads_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_logical_reads > logical_reads) ? (1/0) : (logical_reads - _logical_reads)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logreads_pt">Session Logical Reads (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbwrcheckpoints_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_dbwr_checkpoints > dbwr_checkpoints) ? (1/0) : (dbwr_checkpoints - _dbwr_checkpoints)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_dbwrcheckpoints_ps">DBWR Checkpoints (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redowrites_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_redo_writes > redo_writes) ? (1/0) : (redo_writes - _redo_writes)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redowrites_ps">Redo Writes (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redowrites_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_redo_writes > redo_writes) ? (1/0) : (redo_writes - _redo_writes)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redowrites_pt">Redo Writes (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tabscanslong_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_table_scans_long > table_scans_long) ? (1/0) : (table_scans_long - _table_scans_long)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanslong_ps">Scans on Long Tables (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tabscanslong_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_table_scans_long > table_scans_long) ? (1/0) : (table_scans_long - _table_scans_long)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanslong_pt">Scans on Long Tables (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="parses_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_parses > parses) ? (1/0) : (parses - _parses)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_parses_ps">Total Parses (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="parses_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_parses > parses) ? (1/0) : (parses - _parses)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_parses_pt">Total Parses (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hardparses_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_hard_parses > hard_parses) ? (1/0) : (hard_parses - _hard_parses)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_hardparses_ps">Hard Parses (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hardparses_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_hard_parses > hard_parses) ? (1/0) : (hard_parses - _hard_parses)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_hardparses_pt">Hard Parses (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="executions_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_executions > executions) ? (1/0) : (executions - _executions)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_executions_ps">Executes (per second)</Label>
					<ShortName NLSID="instance_throughput_executions_ps_short">SQL Executions/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sortsdisk_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_sorts_disk > sorts_disk) ? (1/0) : (sorts_disk - _sorts_disk)/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_sortsdisk_ps">Sorts to Disk (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sortsdisk_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_sorts_disk > sorts_disk) ? (1/0) : (sorts_disk - _sorts_disk)/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_sortsdisk_pt">Sorts to Disk (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rows_psort" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_sorts_rows + _sorts_disk + _sorts_memory > sorts_rows + sorts_disk + sorts_memory) ? (1/0) : (sorts_rows - _sorts_rows)/((sorts_disk - _sorts_disk) + (sorts_memory - _sorts_memory))">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_rows_psort">Rows Processed (per sort)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="executeswoparse_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_parses + _executions > parses + executions) ? (1/0) : (((executions - _executions) > (parses - _parses)) ? (100 * (((executions - _executions) - (parses - _parses))/(executions - _executions))) : 0)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_executeswoparse_pct">Executes Performed without Parses (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="softparse_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_parses + _hard_parses > parses + hard_parses) ? (1/0) : 100 * (((parses - _parses) - (hard_parses - _hard_parses))/(parses - _parses))">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_softparse_pct">Soft Parse (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="usercall_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_user_calls + _recursive_calls > user_calls + recursive_calls) ? (1/0) : 100 * ((user_calls - _user_calls)/((user_calls - _user_calls) + (recursive_calls - _recursive_calls)))">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_usercall_pct">User Calls (%)</Label>

				</Display>
			</ColumnDescriptor>               
           
			<ColumnDescriptor NAME="tabscanstotal_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_table_scans_long + _index_ffs_full > table_scans_long + index_ffs_full) ? (1/0) : ((table_scans_long - _table_scans_long) + (index_ffs_full - _index_ffs_full))/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanstotal_ps">Total Table Scans (per second)</Label>

				</Display>
			</ColumnDescriptor>
            
			<ColumnDescriptor NAME="tabscanstotal_pt" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_table_scans_long + _index_ffs_full > table_scans_long + index_ffs_full) ? (1/0) : ((table_scans_long - _table_scans_long) + (index_ffs_full - _index_ffs_full))/transactions">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanstotal_pt">Total Table Scans (per transaction)</Label>

				</Display>
			</ColumnDescriptor>

            <ColumnDescriptor NAME="networkbytes_ps" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_bytes_to_client + _bytes_from_client + _bytes_to_dblink + _bytes_from_dblink > bytes_to_client + bytes_from_client + bytes_to_dblink + bytes_from_dblink) ? (1/0) : ((bytes_to_client - _bytes_to_client) + (bytes_from_client - _bytes_from_client) + (bytes_to_dblink - _bytes_to_dblink) + (bytes_from_dblink - _bytes_from_dblink))/__interval">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_networkbytes_ps">Network Bytes (per second)</Label>

				</Display>
			</ColumnDescriptor>    
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
  logons_current    NUMBER := NULL;
  logons_cumulative NUMBER := NULL;
  parses            NUMBER := NULL;
  hard_parses       NUMBER := NULL;
  executions        NUMBER := NULL;
  user_calls        NUMBER := NULL;
  recursive_calls   NUMBER := NULL;
  sorts_memory      NUMBER := NULL;
  sorts_disk        NUMBER := NULL;
  sorts_rows        NUMBER := NULL;
  logical_reads     NUMBER := NULL;
  physical_reads    NUMBER := NULL;
  table_scans_long  NUMBER := NULL;
  index_ffs_full    NUMBER := NULL;
  physical_writes   NUMBER := NULL;
  bytes_to_client   NUMBER := NULL;
  bytes_from_client NUMBER := NULL;
  bytes_to_dblink   NUMBER := NULL;
  bytes_from_dblink NUMBER := NULL;
  commits           NUMBER := NULL;
  dbwr_checkpoints  NUMBER := NULL;
  rollbacks         NUMBER := NULL;
  redo_size         NUMBER := NULL;
  redo_writes       NUMBER := NULL;

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  FOR name_value_pair IN
    (SELECT sn.name, sv.value
       FROM v$statname sn, v$sysstat sv
      WHERE sn.name IN
            ('DBWR checkpoints',
             'bytes received via SQL*Net from client',
             'bytes received via SQL*Net from dblink',
             'bytes sent via SQL*Net to client',
             'bytes sent via SQL*Net to dblink',
             'execute count',
             'index fast full scans (full)',
             'logons cumulative',
             'logons current',
             'parse count (hard)',
             'parse count (total)',
             'physical reads',
             'physical writes',
             'recursive calls',
             'redo size',
             'redo writes',
             'session logical reads',
             'sorts (disk)',
             'sorts (memory)',
             'sorts (rows)',
             'table scans (long tables)',
             'user calls',
             'user commits',
             'user rollbacks')
        AND sn.statistic# = sv.statistic#)
  LOOP

    IF name_value_pair.name = 'DBWR checkpoints' THEN
      dbwr_checkpoints := name_value_pair.value;
    ELSIF name_value_pair.name = 'bytes received via SQL*Net from client' THEN
      bytes_from_client := name_value_pair.value;
    ELSIF name_value_pair.name = 'bytes received via SQL*Net from dblink' THEN
      bytes_from_dblink := name_value_pair.value;
    ELSIF name_value_pair.name = 'bytes sent via SQL*Net to client' THEN
      bytes_to_client := name_value_pair.value;
    ELSIF name_value_pair.name = 'bytes sent via SQL*Net to dblink' THEN
      bytes_to_dblink := name_value_pair.value;
    ELSIF name_value_pair.name = 'execute count' THEN
      executions := name_value_pair.value;
    ELSIF name_value_pair.name = 'index fast full scans (full)' THEN
      index_ffs_full := name_value_pair.value;
    ELSIF name_value_pair.name = 'logons cumulative' THEN
      logons_cumulative := name_value_pair.value;
    ELSIF name_value_pair.name = 'logons current' THEN
      logons_current := name_value_pair.value;
    ELSIF name_value_pair.name = 'parse count (hard)' THEN
      hard_parses := name_value_pair.value;
    ELSIF name_value_pair.name = 'parse count (total)' THEN
      parses := name_value_pair.value;
    ELSIF name_value_pair.name = 'physical reads' THEN
      physical_reads := name_value_pair.value;
    ELSIF name_value_pair.name = 'physical writes' THEN
      physical_writes := name_value_pair.value;
    ELSIF name_value_pair.name = 'recursive calls' THEN
      recursive_calls := name_value_pair.value;
    ELSIF name_value_pair.name = 'redo size' THEN
      redo_size := name_value_pair.value;
    ELSIF name_value_pair.name = 'redo writes' THEN
      redo_writes := name_value_pair.value;
    ELSIF name_value_pair.name = 'session logical reads' THEN
      logical_reads := name_value_pair.value;
    ELSIF name_value_pair.name = 'sorts (disk)' THEN
      sorts_disk := name_value_pair.value;
    ELSIF name_value_pair.name = 'sorts (memory)' THEN
      sorts_memory := name_value_pair.value;
    ELSIF name_value_pair.name = 'sorts (rows)' THEN
      sorts_rows := name_value_pair.value;
    ELSIF name_value_pair.name = 'table scans (long tables)' THEN
      table_scans_long := name_value_pair.value;
    ELSIF name_value_pair.name = 'user calls' THEN
      user_calls := name_value_pair.value;
    ELSIF name_value_pair.name = 'user commits' THEN
      commits := name_value_pair.value;
    ELSIF name_value_pair.name = 'user rollbacks' THEN
      rollbacks := name_value_pair.value;
    END IF;

  END LOOP;

  -- open the cursor to return
  OPEN data_cursor FOR
    SELECT logons_current,
           logons_cumulative,
           parses,
           hard_parses,
           executions,
           user_calls,
           recursive_calls,
           sorts_memory,
           sorts_disk,
           sorts_rows,
           logical_reads,
           physical_reads,
           table_scans_long,
           index_ffs_full,
           physical_writes,
           bytes_to_client,
           bytes_from_client,
           bytes_to_dblink,
           bytes_from_dblink,
           commits,
           dbwr_checkpoints,
           rollbacks,
           redo_size,
           redo_writes
      FROM dual;

  :1 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Efficiency
  == Collection Level: Complete
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="instance_efficiency" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="instance_efficiency">Efficiency</Label>
		</Display>
		<TableDescriptor>
			<!-- columns provided by the query descriptor's fetchlet call -->
			<!-- Note: The order of these columns must match the output ADT. -->
			<!--       The field name matches the column name only for clarity. -->
			<ColumnDescriptor NAME="sorts_memory" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_sorts_memory">sorts (memory)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sorts_disk" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_sorts_disk">sorts (disk)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logical_reads" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_logical_reads">session logical reads</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physical_reads" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_physical_reads">physical reads</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physical_reads_direct" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_physical_reads_direct">physical reads direct</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redo_entries" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_redo_entries">redo entries</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redo_space_requests" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_redo_space_requests">redo log space requests</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="libcache_pins" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_libcache_pins">libcache pins</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="libcache_pinhits" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_libcache_pinhits">libcache pinhits</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dictionary_gets" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_dictionary_gets">dictionary gets</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dictionary_misses" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="instance_efficiency_dictionary_misses">dictionary misses</Label>
				</Display>
			</ColumnDescriptor>
			<!-- intermediate columns to be used in column computations below -->
			<!-- columns based on deltas or other computations from counters -->
			<ColumnDescriptor NAME="bufcachehit_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_logical_reads + _physical_reads + _physical_reads_direct > logical_reads + physical_reads + physical_reads_direct) ? (1/0) : ((logical_reads > _logical_reads) ? (100 * (1 - (((physical_reads - _physical_reads) - (physical_reads_direct - _physical_reads_direct))/(logical_reads - _logical_reads)))) : 100)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_bufcachehit_pct">Buffer Cache Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="libcache_hit_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_libcache_pins + _libcache_pinhits > libcache_pins + libcache_pinhits) ? (1/0) : ((libcache_pins > _libcache_pins) ? (100 * (libcache_pinhits - _libcache_pinhits)/(libcache_pins - _libcache_pins)) : 100)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_libcache_hit_pct">Library Cache Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dictionaryhit_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_dictionary_gets + _dictionary_misses > dictionary_gets + dictionary_misses) ? (1/0) : ((dictionary_gets > _dictionary_gets) ? (100 * ((dictionary_gets - _dictionary_gets) - (dictionary_misses - _dictionary_misses))/(dictionary_gets - _dictionary_gets)) : 100)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_dictionaryhit_pct">Data Dictionary Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="inmem_sort_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_sorts_memory + _sorts_disk > sorts_memory + sorts_disk) ? (1/0) : ((sorts_memory + sorts_disk > _sorts_memory + _sorts_disk) ? (100 * (sorts_memory - _sorts_memory)/((sorts_memory - _sorts_memory) + (sorts_disk - _sorts_disk))) : 100)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_inmem_sort_pct">Sorts in Memory (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redologalloc_hit_pct" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(_redo_entries + _redo_space_requests > redo_entries + redo_space_requests) ? (1/0) : ((redo_entries > _redo_entries) ? (100 * ((redo_entries - _redo_entries) - (redo_space_requests - _redo_space_requests))/(redo_entries - _redo_entries)) : 100)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_redologalloc_hit_pct">Redo Log Allocation Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
  sorts_memory                 NUMBER := 0;
  sorts_disk                   NUMBER := 0;
  logical_reads                NUMBER := 0;
  physical_reads               NUMBER := 0;
  physical_reads_direct        NUMBER := 0;
  redo_entries                 NUMBER := 0;
  redo_space_requests          NUMBER := 0;
  libcache_pins                NUMBER := 0;
  libcache_pinhits             NUMBER := 0;
  dictionary_gets              NUMBER := 0;
  dictionary_misses            NUMBER := 0;

  TYPE num_sequence IS TABLE OF NUMBER;

  --
  -- The statistic#'s of the v$sysstat statistics we're interested in.
  -- These numbers are ordered alphabetically, according to the stat name.
  --
  ordered_stat#s num_sequence := num_sequence();

  -- keep the MAX(statistic#) as a pseudo-statistic which represents a miss
  -- in the name lookup
  max_stat#      NUMBER := 0;

  -- Note: This must be alphabetical (and ending with NULL)!
  TYPE name_list IS TABLE OF VARCHAR2(64);
  stat_names CONSTANT name_list :=
   name_list('physical reads',
             'physical reads direct',
             'redo entries',
             'redo log space requests',
             'session logical reads',
             'sorts (disk)',
             'sorts (memory)',
             NULL);
  curr_stat#_ord INTEGER := 1;

  -- since misses are not expected, we'll keep a counter and only post-
  -- process the stat# array if there were any
  statname_misses INTEGER := 0;

  sysstat_vals        num_sequence := num_sequence();

  i NUMBER;

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  ----
  -- initialize ordered_stat#s with the statistic#s (+1, since these are
  -- PL/SQL array indices) for the statistics we're interested in
  ----

  FOR name_stat#_pair IN
    (SELECT name, statistic# stat#
       FROM v$statname
      ORDER BY name)
  LOOP

    -- (compute MAX(statistic#) for the purpose of misses)
    max_stat# := GREATEST(max_stat#, name_stat#_pair.stat#);

    IF name_stat#_pair.name = stat_names(curr_stat#_ord) THEN

      ----
      -- log the found statistic#
      ----

      ordered_stat#s.EXTEND;
      ordered_stat#s(curr_stat#_ord) := name_stat#_pair.stat# + 1;
      curr_stat#_ord := curr_stat#_ord + 1;

    ELSIF name_stat#_pair.name > stat_names(curr_stat#_ord) THEN

      ----
      -- we've had a miss, so post-process the array, setting our NULL
      -- statistic#s to our pseudo-statistic#
      -- this can only happen if
      --  a statistic is deprecated by the server (which it doesn't do), or
      --  a misspelling of a valid statistic name in the list, or
      --  an incorrect alphabetical ordering of the list
      ----

      ordered_stat#s.EXTEND;
      ordered_stat#s(curr_stat#_ord) := NULL;
      curr_stat#_ord := curr_stat#_ord + 1;
      statname_misses := statname_misses + 1;

    END IF;

  END LOOP;

  IF statname_misses > 0 THEN

    -- (post-process the misses)
    FOR stat_ord IN 1..ordered_stat#s.COUNT LOOP
      IF ordered_stat#s(stat_ord) IS NULL THEN
        ordered_stat#s(stat_ord) := max_stat# + 2;
      END IF;
    END LOOP;

  END IF;

  ----
  -- query data into sysstat_vals, indexed by statistic#, leaving a zeroed
  -- slot at the end for misses
  ----

  -- (supply a value for misses)
  sysstat_vals.EXTEND(max_stat# + 2);
  sysstat_vals(max_stat# + 2) := 0;

  -- (populate the stat# table)
  FOR stat#_val_pair IN
    (SELECT statistic# stat#, value
       FROM v$sysstat)
  LOOP
    sysstat_vals(stat#_val_pair.stat# + 1) := stat#_val_pair.value;
  END LOOP;

  ----
  -- populate the SYSSTAT regions of the output record
  --
  -- Note: The order of this list must match the alphabetical order of
  --       statistic names!
  ----

  i := 1;
  physical_reads        := sysstat_vals(ordered_stat#s(i)); i := i + 1;
  physical_reads_direct := sysstat_vals(ordered_stat#s(i)); i := i + 1;
  redo_entries          := sysstat_vals(ordered_stat#s(i)); i := i + 1;
  redo_space_requests   := sysstat_vals(ordered_stat#s(i)); i := i + 1;
  logical_reads         := sysstat_vals(ordered_stat#s(i)); i := i + 1;
  sorts_disk            := sysstat_vals(ordered_stat#s(i)); i := i + 1;
  sorts_memory          := sysstat_vals(ordered_stat#s(i)); i := i + 1;

  ----
  -- get library cache pin data
  ----
  SELECT SUM(pins), SUM(pinhits)
    INTO libcache_pins, libcache_pinhits
    FROM v$librarycache;

  ----
  -- get dictionary gets data
  ----
  SELECT SUM(gets), SUM(getmisses)
    INTO dictionary_gets, dictionary_misses
    FROM v$rowcache;

  -- open the cursor to return
  OPEN data_cursor FOR
    SELECT sorts_memory,
           sorts_disk,
           logical_reads,
           physical_reads,
           physical_reads_direct,
           redo_entries,
           redo_space_requests,
           libcache_pins,
           libcache_pinhits,
           dictionary_gets,
           dictionary_misses
      FROM dual;

  :1 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         SGA Pool Wastage
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="sga_pool_wastage" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="sga_pool_wastage">SGA Pool Wastage</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="shared_free_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sga_pool_wastage_shared_free_pct">Shared Pool Free (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="large_free_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sga_pool_wastage_large_free_pct">Large Pool Free (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="java_free_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sga_pool_wastage_java_free_pct">Java Pool Free (%)</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE

  shared_free_pct NUMBER;
  large_free_pct  NUMBER;
  java_free_pct   NUMBER;

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  ----
  -- compute each percentage
  ----
  FOR pool_pct_pair IN
    (SELECT pool,
            DECODE(total_bytes, 0, NULL, 100 * free_bytes / total_bytes) pct
       FROM (SELECT pool,
                    SUM(bytes) total_bytes,
                    SUM(DECODE(name, 'free memory', bytes, 0)) free_bytes
               FROM v$sgastat
              GROUP BY pool))
  LOOP
    IF pool_pct_pair.pool = 'shared pool' THEN
      shared_free_pct := pool_pct_pair.pct;
    ELSIF pool_pct_pair.pool = 'java pool' THEN
      java_free_pct   := pool_pct_pair.pct;
    ELSIF pool_pct_pair.pool = 'large pool' THEN
      large_free_pct  := pool_pct_pair.pct;
    END IF;
  END LOOP;

  -- open the cursor to return
  OPEN data_cursor FOR
    SELECT shared_free_pct,
           large_free_pct,
           java_free_pct
      FROM dual;

  :1 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
  <!--
  ======================================================================
  == Category:         Wait Bottlenecks
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
  <Metric NAME="wait_bottlenecks" TYPE="TABLE">
    <ValidIf>
       <CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
    </ValidIf>
    <Display>
      <Label NLSID="wait_bottlenecks">Wait Bottlenecks</Label>
    </Display>

    <TableDescriptor>

      <!-- columns provided by the query descriptor's fetchlet call -->

      <!-- Note: The order of these columns must match the output ADT. -->
      <!--       The field name matches the column name only for clarity. -->
      <ColumnDescriptor NAME="local_write_wait_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_local_write_wait_time">local_write_wait_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_reset_to_client_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_reset_to_client_time">net_reset_to_client_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_reset_to_dblink_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_reset_to_dblink_time">net_reset_to_dblink_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_dml_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_dml_time">enqueue_dml_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_row_lock_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_row_lock_time">enqueue_row_lock_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_userdef_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_userdef_time">enqueue_userdef_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_sync_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_log_file_sync_time">log_file_sync_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="buffer_busy_waits_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_buffer_busy_waits_time">buffer_busy_waits_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_cache_buffer_chains_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_latch_cache_buffer_chains_time">latch_cache_buffer_chains_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_library_cache_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_latch_library_cache_time">latch_library_cache_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="library_cache_load_lock_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_library_cache_load_lock_time">library_cache_load_lock_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="library_cache_lock_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_library_cache_lock_time">library_cache_lock_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="library_cache_pin_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_library_cache_pin_time">library_cache_pin_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="pipe_put_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_pipe_put_time">pipe_put_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="row_cache_lock_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_row_cache_lock_time">row_cache_lock_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_hw_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_hw_time">enqueue_hw_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_st_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_st_time">enqueue_st_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_alloc_itl_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_alloc_itl_time">enqueue_alloc_itl_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="free_buffer_waits_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_free_buffer_waits_time">free_buffer_waits_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_redo_copy_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_latch_redo_copy_time">latch_redo_copy_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_shared_pool_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_latch_shared_pool_time">latch_shared_pool_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_buffer_space_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_log_buffer_space_time">log_buffer_space_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_switch_arch_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_log_file_switch_arch_time">log_file_switch_arch_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_switch_ckpt_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_log_file_switch_ckpt_time">log_file_switch_ckpt_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_switch_complete_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_log_file_switch_complete_time">log_file_switch_complete_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_switch_arch_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_log_switch_arch_time">log_switch_arch_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="write_complete_waits_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_write_complete_waits_time">write_complete_waits_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_msg_to_client_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_msg_to_client_time">net_msg_to_client_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_msg_to_dblink_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_msg_to_dblink_time">net_msg_to_dblink_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_from_client_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_more_from_client_time">net_more_from_client_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_from_dblink_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_more_from_dblink_time">net_more_from_dblink_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_to_client_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_more_to_client_time">net_more_to_client_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_to_dblink_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_net_more_to_dblink_time">net_more_to_dblink_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_file_scattered_read_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_db_file_scattered_read_time">db_file_scattered_read_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_file_sequential_read_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_db_file_sequential_read_time">db_file_sequential_read_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_file_single_write_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_db_file_single_write_time">db_file_single_write_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_read_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_direct_path_read_time">direct_path_read_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_read_lob_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_direct_path_read_lob_time">direct_path_read_lob_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_write_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_direct_path_write_time">direct_path_write_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_write_lob_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_direct_path_write_lob_time">direct_path_write_lob_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_free_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_latch_free_time">latch_free_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_enqueue_time">enqueue_time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="user_wait_time" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_user_wait_time">Wait Time (sec)</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="user_cpu_time" TYPE="NUMBER" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_user_cpu_time">CPU Time (sec)</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="userio_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_userio_wait_time">User I/O Wait Time (sec)</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="cpu_cnt" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="wait_bottlenecks_cpu_cnt">CPU Count</Label>
        </Display>
      </ColumnDescriptor>

      <ColumnDescriptor NAME="service_time_fg_delta" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP"
                        COMPUTE_EXPR="(_user_wait_time > user_wait_time) ? 0 : ((_user_cpu_time > user_cpu_time) ? 0 : (user_wait_time - _user_wait_time) + (user_cpu_time - _user_cpu_time))">
        <Display>
          <Label NLSID="wait_bottlenecks_service_time_fg">Service Time Delta (sec)</Label>
        </Display>
      </ColumnDescriptor>

      <!-- columns based on deltas or other computations from counters -->

      <ColumnDescriptor NAME="local_write_wait_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(local_write_wait_time > _local_write_wait_time) ? 100*(local_write_wait_time - _local_write_wait_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_local_write_wait_pct">Local write wait (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_reset_to_client_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_reset_to_client_time > _net_reset_to_client_time) ? 100*(net_reset_to_client_time - _net_reset_to_client_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_reset_to_client_pct">SQL*Net break/reset to client (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_reset_to_dblink_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_reset_to_dblink_time > _net_reset_to_dblink_time) ? 100*(net_reset_to_dblink_time - _net_reset_to_dblink_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_reset_to_dblink_pct">SQL*Net break/reset to dblink (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_dml_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_dml_time > _enqueue_dml_time) ? 100*(enqueue_dml_time - _enqueue_dml_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_dml_pct">Enqueue: DML - contention (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_row_lock_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_row_lock_time > _enqueue_row_lock_time) ? 100*(enqueue_row_lock_time - _enqueue_row_lock_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_row_lock_pct">Enqueue: TM, TX, Transaction - row lock contention (%)</Label>
          <ShortName NLSID="wait_bottlenecks_enqueue_row_lock_pct_sht">Enqueue: TM, TX, Txn (%)</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_userdef_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_userdef_time > _enqueue_userdef_time) ? 100*(enqueue_userdef_time - _enqueue_userdef_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_userdef_pct">Enqueue: UL: User-defined - contention (%)</Label>
          <ShortName NLSID="wait_bottlenecks_enqueue_userdef_pct_sht">Enqueue: UL (%)</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_sync_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(log_file_sync_time > _log_file_sync_time) ? 100*(log_file_sync_time - _log_file_sync_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_log_file_sync_pct">Log file sync (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="buffer_busy_waits_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(buffer_busy_waits_time > _buffer_busy_waits_time) ? 100*(buffer_busy_waits_time - _buffer_busy_waits_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_buffer_busy_waits_pct">Buffer busy waits (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_cache_buffer_chains_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(latch_cache_buffer_chains_time > _latch_cache_buffer_chains_time) ? 100*(latch_cache_buffer_chains_time - _latch_cache_buffer_chains_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_latch_cache_buffer_chains_pct">Latch: cache buffer chains (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_library_cache_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(latch_library_cache_time > _latch_library_cache_time) ? 100*(latch_library_cache_time - _latch_library_cache_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_latch_library_cache_pct">Latch: library cache (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="library_cache_load_lock_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(library_cache_load_lock_time > _library_cache_load_lock_time) ? 100*(library_cache_load_lock_time - _library_cache_load_lock_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_library_cache_load_lock_pct">Library cache load lock (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="library_cache_lock_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(library_cache_lock_time > _library_cache_lock_time) ? 100*(library_cache_lock_time - _library_cache_lock_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_library_cache_lock_pct">Library cache lock (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="library_cache_pin_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(library_cache_pin_time > _library_cache_pin_time) ? 100*(library_cache_pin_time - _library_cache_pin_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_library_cache_pin_pct">Library cache pin (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="pipe_put_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(pipe_put_time > _pipe_put_time) ? 100*(pipe_put_time - _pipe_put_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_pipe_put_pct">Pipe put (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="row_cache_lock_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(row_cache_lock_time > _row_cache_lock_time) ? 100*(row_cache_lock_time - _row_cache_lock_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_row_cache_lock_pct">Row cache lock (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_hw_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_hw_time > _enqueue_hw_time) ? 100*(enqueue_hw_time - _enqueue_hw_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_hw_pct">Enqueue: HW, Segment High Water Mark - contention (%)</Label>
          <ShortName NLSID="wait_bottlenecks_enqueue_hw_pct_sht">Enqueue: HW Segment HWM (%)</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_st_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_st_time > _enqueue_st_time) ? 100*(enqueue_st_time - _enqueue_st_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_st_pct">Enqueue: ST, Space Transaction - contention (%)</Label>
          <ShortName NLSID="wait_bottlenecks_enqueue_st_pct_sht">Enqueue: ST, Space Txn (%)</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_alloc_itl_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_alloc_itl_time > _enqueue_alloc_itl_time) ? 100*(enqueue_alloc_itl_time - _enqueue_alloc_itl_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_alloc_itl_pct">Enqueue: TX mode 4, Transaction - allocate ITL entry (%)</Label>
          <ShortName NLSID="wait_bottlenecks_enqueue_alloc_itl_pct_sht">Enqueue: TX mode 4, Txn (%)</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="free_buffer_waits_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(free_buffer_waits_time > _free_buffer_waits_time) ? 100*(free_buffer_waits_time - _free_buffer_waits_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_free_buffer_waits_pct">Free buffer waits (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_redo_copy_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(latch_redo_copy_time > _latch_redo_copy_time) ? 100*(latch_redo_copy_time - _latch_redo_copy_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_latch_redo_copy_pct">Latch: redo copy (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_shared_pool_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(latch_shared_pool_time > _latch_shared_pool_time) ? 100*(latch_shared_pool_time - _latch_shared_pool_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_latch_shared_pool_pct">Latch: shared pool (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_buffer_space_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(log_buffer_space_time > _log_buffer_space_time) ? 100*(log_buffer_space_time - _log_buffer_space_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_log_buffer_space_pct">Log buffer space (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_switch_arch_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(log_file_switch_arch_time > _log_file_switch_arch_time) ? 100*(log_file_switch_arch_time - _log_file_switch_arch_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_log_file_switch_arch_pct">Log file switch (archiving needed) (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_switch_ckpt_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(log_file_switch_ckpt_time > _log_file_switch_ckpt_time) ? 100*(log_file_switch_ckpt_time - _log_file_switch_ckpt_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_log_file_switch_ckpt_pct">Log file switch (checkpoint complete) (%)</Label>
          <ShortName NLSID="wait_bottlenecks_log_file_switch_ckpt_pct_sht">Log file switch (ckpt complete) (%)</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_file_switch_complete_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(log_file_switch_complete_time > _log_file_switch_complete_time) ? 100*(log_file_switch_complete_time - _log_file_switch_complete_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_log_file_switch_complete_pct">Log file switch completion (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="log_switch_arch_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(log_switch_arch_time > _log_switch_arch_time) ? 100*(log_switch_arch_time - _log_switch_arch_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_log_switch_arch_pct">Log switch/archive (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="write_complete_waits_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(write_complete_waits_time > _write_complete_waits_time) ? 100*(write_complete_waits_time - _write_complete_waits_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_write_complete_waits_pct">Write complete waits (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_msg_to_client_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_msg_to_client_time > _net_msg_to_client_time) ? 100*(net_msg_to_client_time - _net_msg_to_client_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_msg_to_client_pct">SQL*Net message to client (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_msg_to_dblink_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_msg_to_dblink_time > _net_msg_to_dblink_time) ? 100*(net_msg_to_dblink_time - _net_msg_to_dblink_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_msg_to_dblink_pct">SQL*Net message to dblink (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_from_client_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_more_from_client_time > _net_more_from_client_time) ? 100*(net_more_from_client_time - _net_more_from_client_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_more_from_client_pct">SQL*Net more data from client (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_from_dblink_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_more_from_dblink_time > _net_more_from_dblink_time) ? 100*(net_more_from_dblink_time - _net_more_from_dblink_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_more_from_dblink_pct">SQL*Net more data from dblink (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_to_client_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_more_to_client_time > _net_more_to_client_time) ? 100*(net_more_to_client_time - _net_more_to_client_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_more_to_client_pct">SQL*Net more data to client (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="net_more_to_dblink_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(net_more_to_dblink_time > _net_more_to_dblink_time) ? 100*(net_more_to_dblink_time - _net_more_to_dblink_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_net_more_to_dblink_pct">SQL*Net more data to dblink (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_file_scattered_read_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(db_file_scattered_read_time > _db_file_scattered_read_time) ? 100*(db_file_scattered_read_time - _db_file_scattered_read_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_db_file_scattered_read_pct">DB file scattered read (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_file_sequential_read_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(db_file_sequential_read_time > _db_file_sequential_read_time) ? 100*(db_file_sequential_read_time - _db_file_sequential_read_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_db_file_sequential_read_pct">DB file sequential read (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_file_single_write_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(db_file_single_write_time > _db_file_single_write_time) ? 100*(db_file_single_write_time - _db_file_single_write_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_db_file_single_write_pct">DB file single write (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_read_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(direct_path_read_time > _direct_path_read_time) ? 100*(direct_path_read_time - _direct_path_read_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_direct_path_read_pct">Direct path read (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_read_lob_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(direct_path_read_lob_time > _direct_path_read_lob_time) ? 100*(direct_path_read_lob_time - _direct_path_read_lob_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_direct_path_read_lob_pct">Direct path read (lob) (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_write_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(direct_path_write_time > _direct_path_write_time) ? 100*(direct_path_write_time - _direct_path_write_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_direct_path_write_pct">Direct path write (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="direct_path_write_lob_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(direct_path_write_lob_time > _direct_path_write_lob_time) ? 100*(direct_path_write_lob_time - _direct_path_write_lob_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_direct_path_write_lob_pct">Direct path write (lob) (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="latch_free_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(latch_free_time > _latch_free_time) ? 100*(latch_free_time - _latch_free_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_latch_free_pct">Latch free - other (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="enqueue_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(enqueue_time > _enqueue_time) ? 100*(enqueue_time - _enqueue_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_enqueue_pct">Enqueue - other (%)</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="user_wait_time_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(user_wait_time > _user_wait_time) ? 100*(user_wait_time - _user_wait_time)/service_time_fg_delta : 0">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_user_wait_time_pct">Wait Time (%)</Label>
          <ShortName NLSID="wait_bottlenecks_user_wait_time_pct_short">Wait Time %</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="user_cpu_time_delta" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="_user_cpu_time > user_cpu_time ? (1/0) : user_cpu_time - _user_cpu_time">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_user_cpu_time_delta">CPU Time Delta (sec)</Label>
          <ShortName NLSID="wait_bottlenecks_user_cpu_time_delta_short">CPU (sec)</ShortName>
        </Display>
      </ColumnDescriptor>

      <ColumnDescriptor NAME="wait_time_delta" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP"
                        COMPUTE_EXPR="_user_wait_time > user_wait_time ? (1/0) : user_wait_time - _user_wait_time">
        <Display>
          <Label NLSID="wait_bottlenecks_wait_time_delta">Wait Time Delta (sec)</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="userio_time_delta" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP"
                        COMPUTE_EXPR="_userio_time > userio_time ? (1/0) : userio_time - _userio_time">
        <Display>
          <Label NLSID="wait_bottlenecks_wait_time_delta">User I/O Wait Time Delta (sec)</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="active_sessions" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="service_time_fg_delta/__interval"
                        TRANSIENT="TRUE">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_active_sessions">Active Sessions</Label>

        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="userio_wait_cnt" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="userio_time_delta/__interval">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_userio_wait_cnt">Active Sessions Waiting: I/O</Label>
          <ShortName NLSID="wait_bottlenecks_userio_wait_cnt_short">Sessions: I/O</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="user_cpu_time_cnt" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="user_cpu_time_delta/__interval">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_user_cpu_time_cnt">Active Sessions Using CPU</Label>
          <ShortName NLSID="wait_bottlenecks_user_cpu_time_cnt_short">Sessions: CPU</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="other_wait_cnt" TYPE="NUMBER"
                        COMPUTE_EXPR="active_sessions - user_cpu_time_cnt - userio_wait_cnt">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_other_wait_cnt">Active Sessions Waiting: Other</Label>
          <ShortName NLSID="wait_bottlenecks_other_wait_cnt_short">Sessions: Other</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="avg_user_cpu_time_pct" TYPE="NUMBER" IS_KEY="FALSE"
                        COMPUTE_EXPR="(user_cpu_time_delta/(__interval*cpu_cnt)*100) > 100 ? 100 : (user_cpu_time_delta/(__interval*cpu_cnt)*100)">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_avg_user_cpu_time_pct">Average Instance CPU (%)</Label>
          <ShortName NLSID="wait_bottlenecks_avg_user_cpu_time_pct_short">Instance CPU (%)</ShortName>
        </Display>
      </ColumnDescriptor>

    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
DECLARE
  local_write_wait_time          NUMBER := NULL;
  net_reset_to_client_time       NUMBER := NULL;
  net_reset_to_dblink_time       NUMBER := NULL;
  enqueue_dml_time               NUMBER := NULL;
  enqueue_row_lock_time          NUMBER := NULL;
  enqueue_userdef_time           NUMBER := NULL;
  log_file_sync_time             NUMBER := NULL;
  buffer_busy_waits_time         NUMBER := NULL;
  latch_cache_buffer_chains_time NUMBER := NULL;
  latch_library_cache_time       NUMBER := NULL;
  library_cache_load_lock_time   NUMBER := NULL;
  library_cache_lock_time        NUMBER := NULL;
  library_cache_pin_time         NUMBER := NULL;
  pipe_put_time                  NUMBER := NULL;
  row_cache_lock_time            NUMBER := NULL;
  enqueue_hw_time                NUMBER := NULL;
  enqueue_st_time                NUMBER := NULL;
  enqueue_alloc_itl_time         NUMBER := NULL;
  free_buffer_waits_time         NUMBER := NULL;
  latch_redo_copy_time           NUMBER := NULL;
  latch_shared_pool_time         NUMBER := NULL;
  log_buffer_space_time          NUMBER := NULL;
  log_file_switch_arch_time      NUMBER := NULL;
  log_file_switch_ckpt_time      NUMBER := NULL;
  log_file_switch_complete_time  NUMBER := NULL;
  log_switch_arch_time           NUMBER := NULL;
  write_complete_waits_time      NUMBER := NULL;
  net_msg_to_client_time         NUMBER := NULL;
  net_msg_to_dblink_time         NUMBER := NULL;
  net_more_from_client_time      NUMBER := NULL;
  net_more_from_dblink_time      NUMBER := NULL;
  net_more_to_client_time        NUMBER := NULL;
  net_more_to_dblink_time        NUMBER := NULL;
  db_file_scattered_read_time    NUMBER := NULL;
  db_file_sequential_read_time   NUMBER := NULL;
  db_file_single_write_time      NUMBER := NULL;
  direct_path_read_time          NUMBER := NULL;
  direct_path_read_lob_time      NUMBER := NULL;
  direct_path_write_time         NUMBER := NULL;
  direct_path_write_lob_time     NUMBER := NULL;
  latch_free_time                NUMBER := NULL;
  enqueue_time                   NUMBER := NULL;
  user_wait_time                 NUMBER := NULL;
  user_cpu_time                  NUMBER := NULL;
  userio_time                    NUMBER := NULL;
  cpu_cnt                        NUMBER       := :1;
  timed_statistics               VARCHAR2(16) := :2;

  TYPE userio_type IS TABLE OF VARCHAR2(64);
  userio userio_type := userio_type('BFILE read', 'buffer read retry', 'db file parallel read', 'db file scattered read', 'db file sequential read', 'db file single write', 'direct path read', 'direct path read (lob)', 'direct path write', 'direct path write (lob)' );

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  IF timed_statistics = 'TRUE' THEN

    ----
    -- initialize the time breakdown accumulators
    ----
    user_wait_time := 0;
    userio_time := 0;

    ----
    -- get CPU time (total)
    ----
    SELECT NVL(value, 0)/100
      INTO user_cpu_time
      FROM v$sysstat
     WHERE statistic# = (SELECT statistic#
                           FROM v$statname
                          WHERE name = 'CPU used when call started');

    ----
    -- get wait time (total)
    -- deduct idle waits and purely background waits
    ----
    FOR event_time_pair IN
      (SELECT event, time_waited/100 time_waited
         FROM v$system_event
        WHERE event NOT IN
             ('ARCH random i/o',
              'ARCH sequential i/o',
              'KXFX: execution message dequeue - Slaves',
              'LGWR random i/o',
              'LGWR sequential i/o',
              'LGWR wait for redo copy',
              'Null event',
              'PL/SQL lock timer',
              'PX Deq Credit: need buffer',
              'PX Deq: Execute Reply',
              'PX Deq: Execution Msg',
              'PX Deq: Index Merge Close',
              'PX Deq: Index Merge Execute',
              'PX Deq: Index Merge Reply',
              'PX Deq: Join ACK',
              'PX Deq: Msg Fragment',
              'PX Deq: Par Recov Change Vector',
              'PX Deq: Par Recov Execute',
              'PX Deq: Par Recov Reply',
              'PX Deq: Parse Reply',
              'PX Deq: Table Q Normal',
              'PX Deq: Table Q Sample',
              'PX Deq: Txn Recovery Reply',
              'PX Deq: Txn Recovery Start',
              'PX Deque wait',
              'PX Idle Wait',
              'Queue Monitor Shutdown Wait',
              'Queue Monitor Slave Wait',
              'Queue Monitor Wait',
              'RFS random i/o',
              'RFS sequential i/o',
              'RFS write',
              'SQL*Net message from client',
              'SQL*Net message from dblink',
              'STREAMS apply coord waiting for slave message',
              'STREAMS apply coord waiting for some work to finish',
              'STREAMS apply slave idle wait',
              'STREAMS capture process filter callback wait for ruleset',
              'STREAMS fetch slave waiting for txns',
              'WMON goes to sleep',
              'async disk IO',
              'client message',
              'control file parallel write',
              'control file sequential read',
              'control file single write',
              'db file single write',
              'db file parallel write',
              'dispatcher timer',
              'gcs log flush sync',
              'gcs remote message',
              'ges reconfiguration to start',
              'ges remote message',
              'io done',
              'jobq slave wait',
              'lock manager wait for remote message',
              'log file parallel write',
              'log file sequential read',
              'log file single write',
              'parallel dequeue wait',
              'parallel recovery coordinator waits for cleanup of slaves',
              'parallel query dequeue',
              'parallel query idle wait - Slaves',
              'pipe get',
              'pmon timer',
              'queue messages',
              'rdbms ipc message',
              'recovery read',
              'single-task message',
              'slave wait',
              'smon timer',
              'statement suspended, wait error to be cleared',
              'unread message',
              'virtual circuit',
              'virtual circuit status',
              'wait for activate message',
              'wait for transaction',
              'wait for unread message on broadcast channel',
              'wait for unread message on multiple broadcast channels',
              'wakeup event for builder',
              'wakeup event for preparer',
              'wakeup event for reader',
              'wakeup time manager'))
    LOOP

      IF event_time_pair.event = 'SQL*Net break/reset to client' THEN
        net_reset_to_client_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net break/reset to dblink' THEN
        net_reset_to_dblink_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net message to client' THEN
        net_msg_to_client_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net message to dblink' THEN
        net_msg_to_dblink_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net more data from client' THEN
        net_more_from_client_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net more data from dblink' THEN
        net_more_from_dblink_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net more data to client' THEN
        net_more_to_client_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'SQL*Net more data to dblink' THEN
        net_more_to_dblink_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'buffer busy waits' THEN
        buffer_busy_waits_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'db file scattered read' THEN
        db_file_scattered_read_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'db file sequential read' THEN
        db_file_sequential_read_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'db file single write' THEN
        db_file_single_write_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'direct path read' THEN
        direct_path_read_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'direct path read (lob)' THEN
        direct_path_read_lob_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'direct path write' THEN
        direct_path_write_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'direct path write (lob)' THEN
        direct_path_write_lob_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'enqueue: DML - contention' THEN
        enqueue_dml_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'enqueue: HW, Segment High Water Mark - contention' THEN
        enqueue_hw_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'enqueue: ST, Space Transaction - contention' THEN
        enqueue_st_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'enqueue: TM,TX, Transaction - row lock contention' THEN
        enqueue_row_lock_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'enqueue: TX mode 4, Transaction - allocate ITL entry' THEN
        enqueue_alloc_itl_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'enqueue: UL: User-defined - contention' THEN
        enqueue_userdef_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event LIKE 'enqueue%' THEN
        enqueue_time := NVL(enqueue_time, 0) + event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'free buffer waits' THEN
        free_buffer_waits_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'latch: cache buffers chains' THEN
        latch_cache_buffer_chains_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'latch: library cache' THEN
        latch_library_cache_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'latch: redo copy' THEN
        latch_redo_copy_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'latch: shared pool' THEN
        latch_shared_pool_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event LIKE 'latch%' THEN
        latch_free_time := NVL(latch_free_time, 0) + event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'library cache load lock' THEN
        library_cache_load_lock_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'library cache lock' THEN
        library_cache_lock_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'library cache pin' THEN
        library_cache_pin_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'local write wait' THEN
        local_write_wait_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'log buffer space' THEN
        log_buffer_space_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'log file switch (archiving needed)' THEN
        log_file_switch_arch_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'log file switch (checkpoint incomplete)' THEN
        log_file_switch_ckpt_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'log file switch completion' THEN
        log_file_switch_complete_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'log file sync' THEN
        log_file_sync_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'log switch/archive' THEN
        log_file_switch_arch_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'pipe put' THEN
        pipe_put_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'row cache lock' THEN
        row_cache_lock_time := event_time_pair.time_waited;
      ELSIF event_time_pair.event = 'write complete waits' THEN
        write_complete_waits_time := event_time_pair.time_waited;
      END IF;

      ----
      -- add to the accumulated wait time
      ----
      user_wait_time := user_wait_time + event_time_pair.time_waited;

      -- compute the user io wait time
      FOR i IN userio.FIRST .. userio.LAST
      LOOP
        IF userio(i) = event_time_pair.event THEN
          userio_time := userio_time + event_time_pair.time_waited;
        END IF;
      END LOOP;
    END LOOP;

    -- open the cursor to return
    OPEN data_cursor FOR
      SELECT local_write_wait_time,
             net_reset_to_client_time,
             net_reset_to_dblink_time,
             enqueue_dml_time,
             enqueue_row_lock_time,
             enqueue_userdef_time,
             log_file_sync_time,
             buffer_busy_waits_time,
             latch_cache_buffer_chains_time,
             latch_library_cache_time,
             library_cache_load_lock_time,
             library_cache_lock_time,
             library_cache_pin_time,
             pipe_put_time,
             row_cache_lock_time,
             enqueue_hw_time,
             enqueue_st_time,
             enqueue_alloc_itl_time,
             free_buffer_waits_time,
             latch_redo_copy_time,
             latch_shared_pool_time,
             log_buffer_space_time,
             log_file_switch_arch_time,
             log_file_switch_ckpt_time,
             log_file_switch_complete_time,
             log_switch_arch_time,
             write_complete_waits_time,
             net_msg_to_client_time,
             net_msg_to_dblink_time,
             net_more_from_client_time,
             net_more_from_dblink_time,
             net_more_to_client_time,
             net_more_to_dblink_time,
             db_file_scattered_read_time,
             db_file_sequential_read_time,
             db_file_single_write_time,
             direct_path_read_time,
             direct_path_read_lob_time,
             direct_path_write_time,
             direct_path_write_lob_time,
             latch_free_time,
             enqueue_time,
             user_wait_time,
             user_cpu_time,
             userio_time,
             cpu_cnt

        FROM dual;

  ELSE

    -- open the cursor to return
    OPEN data_cursor FOR
      SELECT local_write_wait_time,
             net_reset_to_client_time,
             net_reset_to_dblink_time,
             enqueue_dml_time,
             enqueue_row_lock_time,
             enqueue_userdef_time,
             log_file_sync_time,
             buffer_busy_waits_time,
             latch_cache_buffer_chains_time,
             latch_library_cache_time,
             library_cache_load_lock_time,
             library_cache_lock_time,
             library_cache_pin_time,
             pipe_put_time,
             row_cache_lock_time,
             enqueue_hw_time,
             enqueue_st_time,
             enqueue_alloc_itl_time,
             free_buffer_waits_time,
             latch_redo_copy_time,
             latch_shared_pool_time,
             log_buffer_space_time,
             log_file_switch_arch_time,
             log_file_switch_ckpt_time,
             log_file_switch_complete_time,
             log_switch_arch_time,
             write_complete_waits_time,
             net_msg_to_client_time,
             net_msg_to_dblink_time,
             net_more_from_client_time,
             net_more_from_dblink_time,
             net_more_to_client_time,
             net_more_to_dblink_time,
             db_file_scattered_read_time,
             db_file_sequential_read_time,
             db_file_single_write_time,
             direct_path_read_time,
             direct_path_read_lob_time,
             direct_path_write_time,
             direct_path_write_lob_time,
             latch_free_time,
             enqueue_time,
             user_wait_time,
             user_cpu_time,
             userio_time,
             cpu_cnt

        FROM dual
       WHERE 0 = 1;

  END IF;

  :3 := data_cursor;

END;
]]>
      </Property>
      <Property NAME="SQLINPARAM1" SCOPE="INSTANCE">CPUCount</Property>
      <Property NAME="SQLINPARAM2" SCOPE="INSTANCE">TimedStatistics</Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">3</Property>
      <Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE" OPTIONAL="TRUE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    </QueryDescriptor>
  </Metric>

	<!--
  ======================================================================
  == Category:         Dump Area
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="dumpFull" TYPE="TABLE">
		<Display>
			<Label NLSID="dump">Dump Area</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="dumpType" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="dump_dumpType">Type of Dump Area</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dumpDir" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dump_dumpDir">Dump Area Directory</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dumpTotal" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dump_dumpTotal">Total Dump Area (KB)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dumpUsed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dump_dumpUsed">Dump Area Used (KB)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dumpUsedPercent" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dump_dumpUsedPercent">Dump Area Used (%)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dumpAvail" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="dumpTotal - dumpUsed">
				<Display>
					<Label NLSID="dump_dumpAvail">Free Dump Area (KB)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="background_dump_dest" SCOPE="INSTANCE">background_dump_dest</Property>
			<Property NAME="core_dump_dest" SCOPE="INSTANCE">core_dump_dest</Property>
			<Property NAME="user_dump_dest" SCOPE="INSTANCE">user_dump_dest</Property>
			<Property NAME="command" SCOPE="GLOBAL">
             %perlBin%/perl %scriptsDir%/db/dbdumpfull.pl %background_dump_dest% %core_dump_dest% %user_dump_dest%
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Archive Area
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="archFull" TYPE="TABLE">
		<Display>
			<Label NLSID="arch">Archive Area</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="archDir" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="arch_archDir">Archive Area Destination</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archTotal" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="arch_archTotal">Total Archive Area (KB)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archUsed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="arch_archUsed">Archive Area Used (KB)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archUsedPercent" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="arch_archUsedPercent">Archive Area Used (%)</Label>
					<ShortName NLSID="arch_archUsedPercent_short">Archive Area %</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archAvail" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="archTotal - archUsed">
				<Display>
					<Label NLSID="arch_archAvail">Free Archive Area (KB)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">
             %perlBin%/perl %scriptsDir%/db/dbarchfull.pl
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Response
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="Response" TYPE="TABLE">
		<Display>
			<Label NLSID="resp">Response</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="userLogon" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="resp_userLogon">User Logon Time (msec)</Label>
					<ShortName NLSID="resp_userLogon_short">Logon Time(ms)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Status" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="resp_status">Status</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="State" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="resp_state">State</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="oraerr" TYPE="STRING" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="resp_oraerr">ORA- Error</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">
         %perlBin%/perl %scriptsDir%/db/dbresp.pl
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Tablespaces Full - 9i and earlier
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="problemTbsp" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="problemTbsp">Tablespaces Full</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="tbspName">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pctUsed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="pctUsed">Tablespace Space Used (%)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">
        %perlBin%/perl %scriptsDir%/fullTbsp.pl
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_TABLESPACE_CONDITION_CLAUSE" SCOPE="USER" OPTIONAL="TRUE">targetTbspCondition</Property>
			<Property NAME="ENVEM_TARGET_SEGMENT_CONDITION_CLAUSE" SCOPE="USER" OPTIONAL="TRUE">targetSegCondition</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Tablespaces Full - 10i - locally managed
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="problemTbsp" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="problemTbsp">Tablespaces Full</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="tbspName">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pctUsed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="pctUsed">Tablespace Space Used (%)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT tablespace_name, used_percent FROM sys.dba_tablespace_usage_metrics
       WHERE :1 != 'BASIC'
			]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">name</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Tablespaces Full By Size and % - 10gR2 - locally managed
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  == Added by rreilly on 16-Jun-2004
  ======================================================================
    -->
	<Metric NAME="problemTbsp" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="problemTbsp">Tablespaces Full</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="tbspName">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pctUsed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="pctUsed">Tablespace Space Used (%)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bytesFree" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="bytesFree">Tablespace Free Space (MB)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT m.tablespace_name,
       m.used_percent,  
       (m.tablespace_size - m.used_space)*t.block_size/1024/1024 mb_free
 FROM  dba_tablespace_usage_metrics m, dba_tablespaces t
 WHERE :1 != 'BASIC'
   AND t.tablespace_name = m.tablespace_name
			]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">name</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Tablespaces Full - 10i - dictionary managed
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="problemTbsp10iDct" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="problemTbsp10iDct">Tablespaces Full (dictionary managed)</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="tbspName">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pctUsed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="pctUsed10iDct">Tablespace Space Used (%) (dictionary managed)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">
        %perlBin%/perl %scriptsDir%/fullTbsp.pl
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_TABLESPACE_CONDITION_CLAUSE" SCOPE="USER" OPTIONAL="TRUE">targetTbspCondition</Property>
			<Property NAME="ENVEM_TARGET_SEGMENT_CONDITION_CLAUSE" SCOPE="USER" OPTIONAL="TRUE">targetSegCondition</Property>
			<Property NAME="ENVEM_TARGET_EXTENT_MGMT_CONDITION_CLAUSE" SCOPE="GLOBAL">='DICTIONARY'</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Tablespaces With Problem Segments
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="problemSegTbsp" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="problemSegTbsp">Tablespaces With Problem Segments</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="tbspName">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="segsChunkSmlCnt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="segsChunkSmlCnt">Segments Not Able to Extend Count</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="segsChunkSmlMessage" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="segsChunkSmlMessage">Segments Not Able to Extend</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="segsMaxExtsCnt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="segsMaxExtsCnt">Segments Approaching Maximum Extents Count</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="segsMaxExtsMessage" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="segsMaxExtsMessage">Segments Approaching Maximum Extents</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">
        %perlBin%/perl %scriptsDir%/problemTbsp.pl
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_TABLESPACE_CONDITION_CLAUSE" SCOPE="USER" OPTIONAL="TRUE">targetTbspCondition</Property>
			<Property NAME="ENVEM_TARGET_SEGMENT_CONDITION_CLAUSE" SCOPE="USER" OPTIONAL="TRUE">targetSegCondition</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Recommended User Settings
  == Collection Level: Recommended
  == Purpose:          Storage Advisor
  ======================================================================
  -->
	<Metric NAME="db_recUserSettings" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<TableDescriptor TABLE_NAME="mgmt_db_recUserSettings_ecm">
			<ColumnDescriptor NAME="name" COLUMN_NAME="user_name" TYPE="STRING" IS_KEY="TRUE"/>
			<ColumnDescriptor NAME="problem" COLUMN_NAME="problem_code" TYPE="NUMBER" IS_KEY="TRUE">
				<!-- Numeric values correspond to specific problems and recommendations:        -->
				<!--   1    User uses permanent tablespace as a temporary tablespace            -->
				<!--   2    Non-system user uses system tablespace as a default tablespace      -->
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace" COLUMN_NAME="tablespace" TYPE="STRING" IS_KEY="FALSE"/>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT username, 1, temporary_tablespace
  FROM dba_users u, dba_tablespaces t
  WHERE u.temporary_tablespace = t.tablespace_name and t.contents != 'TEMPORARY'
  AND u.account_status = 'OPEN'
UNION ALL
SELECT username, 2, default_tablespace
  FROM dba_users
  WHERE username not in ('SYS', 'SYSTEM', 'SYSMAN', 'CTXSYS', 'MDSYS', 'ORDSYS', 'ORDPLUGINS',
  'OLAPSYS', 'DBSNMP', 'MGMT_VIEW', 'OUTLN', 'ANONYMOUS', 'DMSYS', 'EXFSYS',
  'LBACSYS', 'SI_INFORMTN_SCHEMA', 'SYSMAN', 'WKPROXY', 'WKSYS', 'WK_TEST',
  'WMSYS', 'XDB', 'TRACESVR')
    AND account_status = 'OPEN'
    AND default_tablespace in ('SYSTEM', 'SYSAUX')
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Recommended Tablespace Settings
  == Collection Level: Recommended
  == Purpose:          Storage Advisor
  ======================================================================
  -->
	<Metric NAME="db_recTablespaceSettings" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<TableDescriptor TABLE_NAME="mgmt_db_recTSSettings_ecm">
			<ColumnDescriptor NAME="tablespace" COLUMN_NAME="tablespace" TYPE="STRING" IS_KEY="TRUE"/>
			<ColumnDescriptor NAME="problem" COLUMN_NAME="problem_code" TYPE="NUMBER" IS_KEY="TRUE">
				<!-- Numeric values correspond to specific problems and recommendations:        -->
				<!--   1    Permanent locally managed tablespace using MANUAL seg-space mgmt    -->
				<!--   2    Tablespace is dictionary-managed                                    -->
				<!--   3    Tablespace contains both rollback and data segments                 -->
				<!--        NOTE: Overlaps with Config check for rollback segs in SYSTEM        -->
				<!--   4    Tablespace has non-zero PctIncrease value                           -->
				<!--   5    Tablespace's NextExtent not a multiple of InitialExtent             -->
                                <!--   6    Default Temporary Tablespace is set to a system tablespace          -->
                                <!--   7    Default Permanent Tablespace is set to a system tablespace          -->
			</ColumnDescriptor>
			<ColumnDescriptor NAME="value1" COLUMN_NAME="value1" TYPE="NUMBER" IS_KEY="FALSE"/>
			<ColumnDescriptor NAME="value2" COLUMN_NAME="value2" TYPE="NUMBER" IS_KEY="FALSE"/>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT tablespace_name, 
       decode(extent_management, 'LOCAL', 1, 
                                 'DICTIONARY', 2),
       0, 0
  FROM dba_tablespaces
 WHERE tablespace_name NOT IN ('SYSTEM', 'SYSAUX')
   AND (extent_management='DICTIONARY'
        AND contents='PERMANENT')
    OR (extent_management='LOCAL'
        AND contents='PERMANENT'
        AND segment_space_management='MANUAL')
UNION ALL
SELECT property_value,
       decode(property_name, 'DEFAULT_TEMP_TABLESPACE', 6,
                             'DEFAULT_PERMANENT_TABLESPACE', 7),
       0,0
  FROM database_properties
 WHERE (property_name='DEFAULT_TEMP_TABLESPACE' 
        OR  property_name='DEFAULT_PERMANENT_TABLESPACE')
   AND property_value in('SYSTEM','SYSAUX')
UNION ALL
SELECT * FROM (
  SELECT tablespace, 3, count(rbs) "RBS_COUNT", count(ds) "DS_COUNT" FROM (
    SELECT t.name "TABLESPACE",
           decode(s.type#, 1, un.name, null) "RBS",
           decode(s.type#, 1, null, s.file#*s.block#) "DS"
    FROM sys.ts$ t, sys.undo$ un, sys.seg$ s
    WHERE t.ts# = s.ts#
      AND un.file#(+) = s.file#
      AND un.block#(+) = s.block#
      AND un.name(+) != 'SYSTEM'
      AND s.type# != 10)
    GROUP BY tablespace)
WHERE rbs_count > 0 AND ds_count > 0
UNION ALL
SELECT tablespace_name, 4, 0, 0
  FROM dba_tablespaces
  WHERE pct_increase != 0 AND extent_management = 'DICTIONARY'
UNION ALL
SELECT tablespace_name, 5, 0, 0
  FROM dba_tablespaces
  WHERE extent_management = 'DICTIONARY'
  AND initial_extent > 0
  AND MOD(next_extent, initial_extent) != 0
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Recommended Segment Settings - Extent Growth Policy Violation
  == Collection Level: Recommended
  == Purpose:          Storage Advisor
  ======================================================================
  -->
	<Metric NAME="db_recSegmentSettings" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<TableDescriptor TABLE_NAME="mgmt_db_recSegmentSettings_ecm">
			<ColumnDescriptor NAME="obj_type" COLUMN_NAME="obj_type" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_type">Object Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_owner" COLUMN_NAME="obj_owner" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_owner">Object Owner</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_name" COLUMN_NAME="obj_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_name">Object Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_partition" COLUMN_NAME="obj_partition" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_partition">Partition</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_lob_col" COLUMN_NAME="obj_lob_col" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_lob_col">LOB Column</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="seg_type" COLUMN_NAME="segment_type" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_segment_type">Segment Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace" COLUMN_NAME="tablespace" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_recSegmentSettings_tablespace">Tablespace</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recommendation" COLUMN_NAME="problem_code" TYPE="NUMBER" IS_KEY="TRUE">
				<!-- Numeric value is bitwise OR of specific problems:            -->
				<!--   1    PCTINCREASE is not 0                                  -->
				<!--   2    NEXT not multiple of INITIAL                          -->
				<Display>
					<Label NLSID="db_recSegmentSettings_problem_code">Problem</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
                <!--
Query to get segments with settings that violate best-practices
recommendations.  Result columns are:
1. Object type ::=
      1 (Table) | 2 (Index) | 3 (Cluster)
2. Object schema
3. Object name
4. Partition name or ' ' if not partitioned
5. LOB Column name or ' ' if not a LOB column
6. Segment type (Number):
   1       TABLE
   2       INDEX
   3       TABLE PARTITION
   4       INDEX PARTITION
   5       IOT OVERFLOW
   6       LOB INDEX (not used)
   7       LOB COLUMN
   8       LOB PARTITION
   9       TABLE SUBPARTITION
   10      INDEX SUBPARTITION
   11      LOB SUBPARTITION (not used, but should be)
   12      CLUSTER
   13      IOT OVERFLOW PARTITION
7. Name of tablespace containing the segment (String)
8. Violations (Number) - Bitwise OR of problem codes:
   1       PCTINCREASE not 0
   2       NEXTEXTENT not multiple of INITIALEXTENT

Index of Queries in the Union
1. Obj type=1, seg type=1, no ptn or LOB column:
   Nonpartitioned tables.
2. Obj type=2, seg type=2, no ptn or LOB column:
   Nonpartitioned indexes
3. Obj type=3, seg type=12, no ptn or LOB column:
   Clusters
4. Obj type=1, seg type=1, no ptn or LOB column:
   Non-partitioned IOTs (returned as type TABLE)
5. Obj type=1, seg type=3, ptn, no LOB column:
   Table partitions
6. Obj type=2, seg type=4, ptn, no LOB column:
   Index partitions (no LOB or IOT partitions)
7. Obj type=1, seg type=5, no ptn or LOB column:
   IOT overflow segments
8. Obj type=1, seg type=8, no ptn, LOB column:
   Unpartitioned LOB columns
9. Obj type=1, seg type=3, ptn, no LOB column:
   IOT Partitions (returned as type TABLE PARTITION)
10. Obj type=1, seg type=13, ptn, no LOB column:
    IOT Overflow partitions
11. Obj type=1, seg type=8, ptn, LOB column:
    LOB column partitions (The Final Frontier)
12. Obj type=1, seg type=9, ptn, no LOB column:
    Table subpartitions
13. Obj type=2, seg type=10, ptn, no LOB column:
    Index subpartitions
                -->
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT * FROM (
SELECT /*+ ordered */  1 "OBJECT_TYPE", u.name "USER_NAME", o.name "OBJECT_NAME", ' ' "PARTITION",
  ' ' "LOB_COLUMN", 1 "SEG_TYPE", tts.name "TABLESPACE",
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2) "PROBLEM"
FROM
(SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts, sys.tab$ t, sys.seg$ s,
      sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = t.obj#
  AND t.ts# = tts.ts#
  AND t.file# = s.file#
  AND t.block# = s.block#
  AND t.ts# = s.ts#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
  AND decode (bitand (t.property, 1), 1, 1, 0) = 0
  AND decode (bitand (t.property, 32), 32, 1, 0) = 0
  AND decode (bitand (t.property, 64), 64, 1, 0) = 0
  AND decode (bitand (t.property, 512), 512, 1, 0) = 0
  AND decode (bitand (t.property, 1024), 1024, 1, 0) = 0
UNION ALL
SELECT  /*+ ordered */ 2, u.name, o.name, ' ', ' ', 2, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM  
(SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.ind$ i, sys.seg$ s,sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = i.obj#
  AND i.ts# = tts.ts#
  AND i.file# = s.file#
  AND i.block# = s.block#
  AND i.ts# = s.ts#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
  AND decode (bitand (i.property, 2), 2, 1, 0) = 0
  AND i.type# not in (4, 8)
UNION ALL
SELECT /*+ ordered */  3, u.name, o.name, ' ', ' ', 12, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.clu$ c, sys.seg$ s, sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = c.obj#
  AND c.ts# = tts.ts#
  AND c.file# = s.file#
  AND c.block# = s.block#
  AND c.ts# = s.ts#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT  /*+ ordered */ 1, u.name, tn.name, ' ', ' ', 1, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#, name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.ind$ i, sys.seg$ s, sys.tab$ t, sys.obj$ tn,sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = i.obj#
  AND i.ts# = tts.ts#
  AND i.file# = s.file#
  AND i.block# = s.block#
  AND i.ts# = s.ts#
  AND i.bo# = tn.obj#
  AND tn.obj# = t.obj#
  AND decode (bitand (i.property, 2), 2, 1, 0) = 0
  AND i.type# = 4
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT /*+ ordered */  1, u.name, o.name, o.subname, ' ', 3, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.tabpart$ tp, sys.seg$ s, sys.tab$ t, sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = tp.obj#
  AND tp.ts# = tts.ts#
  AND tp.file# = s.file#
  AND tp.block# = s.block#
  AND tp.ts# = s.ts#
  AND t.obj# = tp.bo#
  AND decode (bitand (t.property, 64), 64, 1, 0) = 0
  AND decode (bitand (t.property, 512), 512, 1, 0) = 0
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT  /*+ ordered */ 2, u.name, o.name, o.subname, ' ', 4, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.indpart$ ip, sys.seg$ s, sys.ind$ i, sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = ip.obj#
  AND ip.ts# = tts.ts#
  AND ip.file# = s.file#
  AND ip.block# = s.block#
  AND ip.ts# = s.ts#
  AND i.obj# = ip.bo#
  AND decode (bitand (i.property, 2), 2, 1, 0) = 1
  AND i.type# not in (4, 8)
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT  /*+ ordered */ 1, u.name, tn.name, ' ', ' ', 5, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.tab$ t, sys.seg$ s, sys.tab$ iot,sys.obj$ tn, sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = t.obj#
  AND t.ts# = tts.ts#
  AND t.file# = s.file#
  AND t.block# = s.block#
  AND t.ts# = s.ts#
  AND tn.obj# = t.bobj#
  AND tn.obj# = iot.obj#
  AND decode (bitand (t.property, 32), 32, 1, 0) = 0
  AND decode (bitand (t.property, 64), 64, 1, 0) = 0
  AND decode (bitand (t.property, 512), 512, 1, 0) = 1
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT  /*+ ordered */  1, u.name, tn.name, ' ',
  decode(bitand(c.property, 1), 1, ac.name, c.name), 8, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM    (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.lob$ l, sys.seg$ s, sys.col$ c, sys.attrcol$ ac, sys.obj$ tn, sys.user$ u
WHERE tn.owner# = u.user#
  AND tn.obj# = c.obj#
  AND c.obj# = l.obj#
  AND c.intcol# = l.intcol#
  AND l.ts# = tts.ts#
  AND l.file# = s.file#
  AND l.block# = s.block#
  AND l.ts# = s.ts#
  AND c.obj# = ac.obj#(+)
  AND c.intcol# = ac.intcol#(+)
  AND bitand(c.property,32768) != 32768
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT  /*+ ordered */ 1, u.name, tn.name, o.subname, ' ', 3, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.indpart$ ip, sys.seg$ s, sys.ind$ i, sys.obj$ tn, sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = ip.obj#
  AND ip.ts# = tts.ts#
  AND ip.file# = s.file#
  AND ip.block# = s.block#
  AND ip.ts# = s.ts#
  AND i.obj# = ip.bo#
  AND decode (bitand (i.property, 2), 2, 1, 0) = 1
  AND i.type# = 4
  AND i.bo# = tn.obj#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT  /*+ ordered */ 1, u.name, tbo.name, o.subname, ' ', 13, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM  (SELECT ts#, name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.tabpart$ tp, sys.seg$ s, sys.tab$ t, sys.obj$ tbo, sys.obj$ o, sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = tp.obj#
  AND tp.ts# = tts.ts#
  AND tp.file# = s.file#
  AND tp.block# = s.block#
  AND tp.ts# = s.ts#
  AND t.obj# = tp.bo#
  AND decode (bitand (t.property, 32), 32, 1, 0) = 1
  AND decode (bitand (t.property, 64), 64, 1, 0) = 0
  AND decode (bitand (t.property, 512), 512, 1, 0) = 1
  AND tbo.obj# = t.bobj#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT /*+ ordered */ 1, u.name, tbo.name, po.subname,
    decode(bitand(c.property, 1), 1, a.name, c.name), 8,  tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#,name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
       sys.lobfrag$ lf, sys.seg$ s, sys.lob$ l, sys.partobj$ pobj,
        sys.obj$ po, sys.obj$ tbo, sys.attrcol$ a, sys.col$ c, sys.user$ u
WHERE tbo.owner# = u.user#
  AND pobj.obj# = tbo.obj#
  AND lf.ts# = tts.ts#
  AND lf.file# = s.file#
  AND lf.block# = s.block#
  AND lf.ts# = s.ts#
  AND mod(pobj.spare2, 256) = 0
  AND tbo.obj# = c.obj#
  AND c.obj# = l.obj#
  AND c.intcol# = l.intcol#
  AND l.lobj# = lf.parentobj#
  AND lf.tabfragobj# = po.obj#
  AND bitand(c.property,32768) != 32768
  AND c.obj# = a.obj#(+)
  AND c.intcol# = a.intcol#(+)
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT /*+ ordered */ 1, u.name, bo.name, o.subname, ' ', 9, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM 
  (SELECT ts#, name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
     sys.tabsubpart$ tsp,sys.seg$ s, sys.obj$ bo,sys.obj$ o,sys.user$ u
WHERE o.owner# = u.user#
  AND o.obj# = tsp.obj#
  AND bo.owner# = o.owner#
  AND bo.name = o.name
  AND bo.type# = 2
  AND tsp.ts# = tts.ts#
  AND tsp.file# = s.file#
  AND tsp.block# = s.block#
  AND tsp.ts# = s.ts#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
UNION ALL
SELECT /*+ ordered */ 2, u.name, bo.name, o.subname, ' ', 10, tts.name,
  decode (s.extpct, 0, 0, 1) + decode(mod(s.extsize, s.iniexts), 0, 0, 2)
FROM   (SELECT ts#, name
    FROM sys.ts$
    WHERE bitmapped = 0
      AND online$ != 3
      AND name != 'SYSTEM' AND name != 'SYSAUX'
      AND dflextpct = 0
      AND (dflinit = 0 OR MOD(dflincr, dflinit) = 0)) tts,
      sys.indsubpart$ isp, sys.seg$ s, sys.user$ u,  sys.obj$ o, sys.obj$ bo
WHERE o.owner# = u.user#
  AND o.obj# = isp.obj#
  AND bo.owner# = o.owner#
  AND bo.name = o.name
  AND bo.type# = 1
  AND isp.ts# = tts.ts#
  AND isp.file# = s.file#
  AND isp.block# = s.block#
  AND isp.ts# = s.ts#
  AND (s.extpct > 0 OR (s.iniexts > 0 AND (mod(s.extsize, s.iniexts) != 0) ) )
) where rownum < 201 AND LENGTH(lob_column) <= 30]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>

	<!--
  ======================================================================
  == Category:         Recommended Segment Settings - Non-Sys Segs in Sys TS
  == Collection Level: Recommended
  == Purpose:          Storage Advisor
  == Notes:            BEWARE!  Very similar to db_recSegmentSettings (for extent growth policy)
  ======================================================================
  -->
	<Metric NAME="db_recSegmentSettings_sysseg" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<TableDescriptor TABLE_NAME="mgmt_db_recSegmentSettings_ecm">
			<ColumnDescriptor NAME="obj_type" COLUMN_NAME="obj_type" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_type">Object Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_owner" COLUMN_NAME="obj_owner" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_owner">Object Owner</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_name" COLUMN_NAME="obj_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_name">Object Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_partition" COLUMN_NAME="obj_partition" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_partition">Partition</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="obj_lob_col" COLUMN_NAME="obj_lob_col" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_lob_col">LOB Column</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="seg_type" COLUMN_NAME="segment_type" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_recSegmentSettings_segment_type">Segment Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace" COLUMN_NAME="tablespace" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_recSegmentSettings_tablespace">Tablespace</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recommendation" COLUMN_NAME="problem_code" TYPE="NUMBER" IS_KEY="TRUE">
				<!-- Numeric value is bitwise OR of specific problems:            -->
				<!--   4    Non-system segment in system tablespace               -->
				<Display>
					<Label NLSID="db_recSegmentSettings_problem_code">Problem</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
                <!--
Query to get segments with settings that violate best-practices
recommendations.  Result columns are:
1. Object type ::=
      1 (Table) | 2 (Index) | 3 (Cluster)
2. Object schema
3. Object name
4. Partition name or ' ' if not partitioned
5. LOB Column name or ' ' if not a LOB column
6. Segment type (Number):
   1       TABLE
   2       INDEX
   3       TABLE PARTITION
   4       INDEX PARTITION
   5       IOT OVERFLOW
   6       LOB INDEX (not used)
   7       LOB COLUMN
   8       LOB PARTITION
   9       TABLE SUBPARTITION
   10      INDEX SUBPARTITION
   11      LOB SUBPARTITION (not used, but should be)
   12      CLUSTER
   13      IOT OVERFLOW PARTITION
7. Name of tablespace containing the segment (String)
8. Violations (Number) - Bitwise OR of problem codes:
   4       Non-system segment in system tablespace

Index of Queries in the Union
1. Obj type=1, seg type=1, no ptn or LOB column:
   Nonpartitioned tables.
2. Obj type=2, seg type=2, no ptn or LOB column:
   Nonpartitioned indexes
3. Obj type=3, seg type=12, no ptn or LOB column:
   Clusters
4. Obj type=1, seg type=1, no ptn or LOB column:
   Non-partitioned IOTs (returned as type TABLE)
5. Obj type=1, seg type=3, ptn, no LOB column:
   Table partitions
6. Obj type=2, seg type=4, ptn, no LOB column:
   Index partitions (no LOB or IOT partitions)
7. Obj type=1, seg type=5, no ptn or LOB column:
   IOT overflow segments
8. Obj type=1, seg type=8, no ptn, LOB column:
   Unpartitioned LOB columns
9. Obj type=1, seg type=3, ptn, no LOB column:
   IOT Partitions (returned as type TABLE PARTITION)
10. Obj type=1, seg type=13, ptn, no LOB column:
    IOT Overflow partitions
11. Obj type=1, seg type=8, ptn, LOB column:
    LOB column partitions (The Final Frontier)
12. Obj type=1, seg type=9, ptn, no LOB column:
    Table subpartitions
13. Obj type=2, seg type=10, ptn, no LOB column:
    Index subpartitions
                -->
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT /*+ INDEX(ts) */
   o.object_type, u.name, o.object_name, o.partition, o.lob_column, o.seg_type, ts.name, 4
FROM (
  SELECT 1 "OBJECT_TYPE", o.owner# "USER_NAME#", o.name "OBJECT_NAME", ' ' "PARTITION", ' ' "LOB_COLUMN", 1 "SEG_TYPE", t.ts#
"TABLESPACE#"
  FROM sys.obj$ o, sys.tab$ t, sys.seg$ s
  WHERE o.obj# = t.obj#
    AND t.ts# in (:1,:2)
    AND t.file# = s.file#
    AND t.block# = s.block#
    AND t.ts# = s.ts#
    AND decode (bitand (t.property, 1), 1, 1, 0) = 0
    AND decode (bitand (t.property, 32), 32, 1, 0) = 0
    AND decode (bitand (t.property, 64), 64, 1, 0) = 0
    AND decode (bitand (t.property, 512), 512, 1, 0) = 0
    AND decode (bitand (t.property, 1024), 1024, 1, 0) = 0
 UNION ALL
 SELECT 2, o.owner#, o.name, ' ', ' ', 2, i.ts#
  FROM sys.obj$ o, sys.ind$ i, sys.seg$ s
  WHERE o.obj# = i.obj#
    AND i.ts# in (:1,:2)
    AND i.file# = s.file#
    AND i.block# = s.block#
    AND i.ts# = s.ts#
    AND decode (bitand (i.property, 2), 2, 1, 0) = 0
    AND i.type# not in (4, 8)
 UNION ALL
 SELECT 3, o.owner#, o.name, ' ', ' ', 12, c.ts#
  FROM sys.obj$ o, sys.clu$ c, sys.seg$ s
  WHERE o.obj# = c.obj#
    AND c.ts# IN (:1,:2)
    AND c.file# = s.file#
    AND c.block# = s.block#
    AND c.ts# = s.ts#
 UNION ALL
  SELECT 1, o.owner#, tn.name, ' ', ' ', 1, i.ts#
  FROM sys.obj$ o, sys.seg$ s, sys.tab$ t, sys.obj$ tn, sys.ind$ i
  WHERE o.obj# = i.obj#
    AND i.ts# IN (:1,:2)
    AND i.file# = s.file#
    AND i.block# = s.block#
    AND i.ts# = s.ts#
    AND i.bo# = tn.obj#
    AND tn.obj# = t.obj#
    AND decode (bitand (i.property, 2), 2, 1, 0) = 0
    AND i.type# = 4
 UNION ALL
  SELECT 1, o.owner#, o.name, o.subname, ' ', 3, tp.ts#
  FROM sys.obj$ o, sys.seg$ s, sys.tab$ t, sys.tabpart$ tp
  WHERE o.obj# = tp.obj#
    AND tp.ts# IN (:1,:2)
    AND tp.file# = s.file#
    AND tp.block# = s.block#
    AND tp.ts# = s.ts#
    AND t.obj# = tp.bo#
    AND decode (bitand (t.property, 64), 64, 1, 0) = 0
    AND decode (bitand (t.property, 512), 512, 1, 0) = 0
 UNION ALL
  SELECT 2, o.owner#, o.name, o.subname, ' ', 4, ip.ts#
  FROM sys.obj$ o, sys.seg$ s, sys.ind$ i, sys.indpart$ ip
  WHERE o.obj# = ip.obj#
    AND ip.ts# IN (:1,:2)
    AND ip.file# = s.file#
    AND ip.block# = s.block#
    AND ip.ts# = s.ts#
    AND i.obj# = ip.bo#
    AND decode (bitand (i.property, 2), 2, 1, 0) = 1
    AND i.type# not in (4, 8)
 UNION ALL
  SELECT 1, o.owner#, tn.name, ' ', ' ', 5, t.ts#
  FROM sys.obj$ o, sys.seg$ s, sys.tab$ t, sys.obj$ tn, sys.tab$ iot
  WHERE o.obj# = t.obj#
    AND t.ts# IN (:1,:2)
    AND t.file# = s.file#
    AND t.block# = s.block#
    AND t.ts# = s.ts#
    AND tn.obj# = t.bobj#
    AND tn.obj# = iot.obj#
    AND decode (bitand (t.property, 32), 32, 1, 0) = 0
    AND decode (bitand (t.property, 64), 64, 1, 0) = 0
    AND decode (bitand (t.property, 512), 512, 1, 0) = 1
 UNION ALL
  SELECT 1, tn.owner#, tn.name, ' ', decode(bitand(c.property, 1), 1, ac.name, c.name), 8, l.ts#
  FROM sys.seg$ s, sys.obj$ tn, sys.attrcol$ ac,  sys.col$ c, sys.lob$ l
  WHERE tn.obj# = c.obj#
    AND c.obj# = l.obj#
    AND c.intcol# = l.intcol#
    AND l.ts# IN (:1,:2)
    AND l.file# = s.file#
    AND l.block# = s.block#
    AND l.ts# = s.ts#
    AND c.obj# = ac.obj#(+)
    AND c.intcol# = ac.intcol#(+)
    AND bitand(c.property,32768) != 32768
 UNION ALL
  SELECT 1, o.owner#, tn.name, o.subname, ' ', 3, ip.ts#
  FROM sys.seg$ s, sys.obj$ o, sys.ind$ i, sys.obj$ tn, sys.indpart$ ip
  WHERE o.obj# = ip.obj#
    AND ip.ts# IN (:1,:2)
    AND ip.file# = s.file#
    AND ip.block# = s.block#
    AND ip.ts# = s.ts#
    AND i.obj# = ip.bo#
    AND decode (bitand (i.property, 2), 2, 1, 0) = 1
    AND i.type# = 4
    AND i.bo# = tn.obj#
 UNION ALL
  SELECT 1, o.owner#, tbo.name, o.subname, ' ', 13, tp.ts#
  FROM sys.seg$ s, sys.obj$ o, sys.obj$ tbo, sys.tab$ t, sys.tabpart$ tp
  WHERE o.obj# = tp.obj#
    AND tp.ts# IN (:1,:2)
    AND tp.file# = s.file#
    AND tp.block# = s.block#
    AND tp.ts# = s.ts#
    AND t.obj# = tp.bo#
    AND decode (bitand (t.property, 32), 32, 1, 0) = 1
    AND decode (bitand (t.property, 64), 64, 1, 0) = 0
    AND decode (bitand (t.property, 512), 512, 1, 0) = 1
    AND tbo.obj# = t.bobj#
 UNION ALL
  SELECT 1, tbo.owner#, tbo.name, po.subname, decode(bitand(c.property, 1), 1, a.name, c.name), 8, lf.ts#
  FROM  sys.seg$ s, sys.obj$ tbo, sys.attrcol$ a, sys.col$ c, sys.lob$ l, sys.obj$ po, sys.partobj$ pobj, sys.lobfrag$ lf
  WHERE pobj.obj# = tbo.obj#
    AND lf.ts# IN (:1,:2)
    AND lf.file# = s.file#
    AND lf.block# = s.block#
    AND lf.ts# = s.ts#
    AND mod(pobj.spare2, 256) = 0
    AND tbo.obj# = c.obj#
    AND c.obj# = l.obj#
    AND c.intcol# = l.intcol#
    AND l.lobj# = lf.parentobj#
    AND lf.tabfragobj# = po.obj#
    AND bitand(c.property,32768) != 32768
    AND c.obj# = a.obj#(+)
    AND c.intcol# = a.intcol#(+)
 UNION ALL
  SELECT 1, o.owner#, bo.name, o.subname, ' ', 9, tsp.ts#
  FROM sys.seg$ s, sys.obj$ o, sys.obj$ bo, sys.tabsubpart$ tsp
  WHERE o.obj# = tsp.obj#
    AND bo.owner# = o.owner#
    AND bo.name = o.name
    AND bo.type# = 2
    AND tsp.file# = s.file#
    AND tsp.block# = s.block#
    AND tsp.ts# IN (:1,:2)
 UNION ALL
  SELECT 2, o.owner#, bo.name, o.subname, ' ', 10, isp.ts#
  FROM sys.seg$ s, sys.obj$ o, sys.obj$ bo, sys.indsubpart$ isp
  WHERE o.obj# = isp.obj#
    AND bo.owner# = o.owner#
    AND bo.name = o.name
    AND bo.type# = 1
    AND isp.file# = s.file#
    AND isp.block# = s.block#
    AND isp.ts# IN (:1,:2)
) o, sys.ts$ ts, sys.user$ u
WHERE o.USER_NAME# = u.user#
  AND u.name NOT IN
      ('SYS', 'SYSTEM', 'SYSMAN', 'CTXSYS', 'MDSYS', 'ORDSYS', 'ORDPLUGINS',
       'OLAPSYS', 'DBSNMP', 'MGMT_VIEW', 'OUTLN', 'ANONYMOUS', 'DMSYS', 'EXFSYS',
       'LBACSYS', 'SI_INFORMTN_SCHEMA', 'SYSMAN', 'WKPROXY', 'WKSYS', 'WK_TEST',
       'WMSYS', 'XDB', 'TRACESVR')
  AND o.TABLESPACE# = ts.ts#
  AND ts.ts# IN (:1,:2)
  AND rownum < 201
]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">SystemTs#</Property>
			<Property NAME="SQLINPARAM2" SCOPE="INSTANCE">SysauxTs#</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>


	<!--
  ======================================================================
  == Category:         Recommended Settings Purge
  == Collection Level: Recommended
  == Purpose:          Storage Advisor
  == Note:             This metric fires after the recXxxSettingsRaw
  ==                   metrics to purge old records.
  ======================================================================
  -->
	<Metric NAME="recSettingsPurge" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<TableDescriptor TABLE_NAME="mgmt_space_purge" SKIP_METRIC_COLUMN="TRUE" SKIP_COLLTIME_COLUMN="TRUE">
			<ColumnDescriptor NAME="mgmt_space_purge_metric_name" COLUMN_NAME="metric_name" TYPE="STRING" IS_KEY="FALSE"/>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="metricName" SCOPE="USER" OPTIONAL="FALSE">metricName</Property>
			<Property NAME="command" SCOPE="GLOBAL">
        %perlBin%/perl %scriptsDir%/spacePurge.pl %metricName%
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
		</QueryDescriptor>
	</Metric>
	<Metric NAME="dataguard" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9iR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
			<CategoryProp NAME="DataGuardStatus" CHOICES="Primary"/>
		</ValidIf>
		<Display>
			<Label NLSID="dg">Data Guard</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="dg_name" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="dg_name">Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_dnr1" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_dnr1">Data Not Received (logs)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_dna1" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_dna1">Data Not Applied (logs) </Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_status">Data Guard Status</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL"> %perlBin%/perl %scriptsDir%/db/dg/dgDatabases.pl</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))</Property>
			<Property NAME="ENVVersionCategory" SCOPE="INSTANCE">VersionCategory</Property>
		</QueryDescriptor>
	</Metric>
	<Metric NAME="dataguard" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
			<CategoryProp NAME="DataGuardStatus" CHOICES="Primary"/>
		</ValidIf>
		<Display>
			<Label NLSID="dg">Data Guard</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="dg_name" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="dg_name">Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_dnr1" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_dnr1">Data Not Received (logs)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_dnr2" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_dnr2">Data Not Received (MB)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_dna1" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_dna1">Data Not Applied (logs) </Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_dna2" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_dna2">Data Not Applied (MB) </Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dg_status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="dg_status">Data Guard Status</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL"> %perlBin%/perl %scriptsDir%/db/dg/dgDatabases.pl</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))</Property>
			<Property NAME="ENVVersionCategory" SCOPE="INSTANCE">VersionCategory</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Database Limits
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="Database_Resource_Usage" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="resource_usage">Database Limits</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="lock_usage" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="lock_usage_name">Lock Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="process_usage" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="process_usage">Process Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="session_usage" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="session_usage">Session Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="user_limit" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="user_limit">User Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="transpose" SCOPE="GLOBAL">TRUE</Property>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
     SELECT usage
     FROM (select RESOURCE_NAME name, 100*DECODE(initial_allocation,' UNLIMITED',0, current_utilization /
             initial_allocation) usage
           from v$resource_limit
           where LTRIM(limit_value) != '0' and LTRIM(initial_allocation) != '0'
             and resource_name in ('dml_locks', 'processes', 'sessions')
           union all
             select  'user'  name
                ,100* DECODE(sessions_max,0,0,sessions_current/sessions_max)  usage
             from v$license
           )
     order by name
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Deferred Transactions
  == Collection Level: Recommended
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="DeferredTrans" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="deferredTrans_count">Deferred Transactions</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="errortrans_count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="errortrans_error">Deferred Transaction Error Count</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="deftrans_count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="deftrans_count_name">Deferred Transaction Count</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="transpose" SCOPE="GLOBAL">TRUE</Property>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT trans_count
  FROM (SELECT 'def_trans_err' name, COUNT(*) trans_count
          FROM sys.deferror
         UNION ALL
        SELECT 'def_trans_noerr' name, COUNT(*) trans_count
          FROM sys.deftran)
 ORDER BY name
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Alert Log
  == Collection Level: Minimum
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="alertLog" TYPE="TABLE">
		<Display>
			<Label NLSID="alertLog">Alert Log</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="timeLine" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="alertLog_timeLine">Time/Line Number</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="genericErrStack" TYPE="STRING" STATELESS_ALERTS="TRUE">
				<Display>
					<Label NLSID="alertLog_genericErrStack">Generic Alert Log Error</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archiveHungErrStack" TYPE="STRING" STATELESS_ALERTS="TRUE">
				<Display>
					<Label NLSID="alertLog_archiveHungErrStack">Archiver Hung Alert Log Error</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="blockCorruptErrStack" TYPE="STRING" STATELESS_ALERTS="TRUE">
				<Display>
					<Label NLSID="alertLog_blockCorruptErrStack">Data Block Corruption Alert Log Error</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sessTerminateErrStack" TYPE="STRING" STATELESS_ALERTS="TRUE">
				<Display>
					<Label NLSID="alertLog_sessTerminateErrStack">Session Terminated Alert Log Error</Label>
				</Display>
			</ColumnDescriptor>
      <ColumnDescriptor NAME="mediaFailureErrStack" TYPE="STRING" STATELESS_ALERTS="TRUE">
        <Display>
          <Label NLSID="alertLog_mediaFailureErrStack">Media Failure Alert Log Error</Label>
        </Display>
      </ColumnDescriptor>
			<ColumnDescriptor NAME="traceFileName" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="alertLog_traceFileName">Alert Log Error Trace File</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="errCodes" TYPE="STRING" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="alertLog_errCodes">Witnessed Error Codes</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="alertLogName" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="alertLog_fileName">Alert Log Name</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="background_dump_dest" SCOPE="INSTANCE">background_dump_dest</Property>
			<Property NAME="user_dump_dest" SCOPE="INSTANCE">user_dump_dest</Property>
			<Property NAME="limitSwitch" SCOPE="USER">limitSwitch</Property>
			<Property NAME="ignorePattern" SCOPE="USER" OPTIONAL="TRUE">ignorePattern</Property>
			<Property NAME="command" SCOPE="GLOBAL">
         %perlBin%/perl %scriptsDir%/alertlog.pl %background_dump_dest% %user_dump_dest% %limitSwitch% %ignorePattern%
      </Property>
			<Property NAME="ENVEM_TARGET_GUID" SCOPE="INSTANCE">GUID</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_SID" SCOPE="INSTANCE">SID</Property>
                        <Property NAME="ENVEM_AGENT_STATE_DIR" SCOPE="SYSTEMGLOBAL">agentStateDir</Property>
                        <Property NAME="ENVEM_ALERTLOG_ERROR_TYPES" SCOPE="GLOBAL">4</Property>
                        <Property NAME="ENVEM_ALERTLOG_ERROR_TYPE1" SCOPE="GLOBAL">00257,16038</Property>
                        <Property NAME="ENVEM_ALERTLOG_ERROR_TYPE2" SCOPE="GLOBAL">01157,01578,27048</Property>
                        <Property NAME="ENVEM_ALERTLOG_ERROR_TYPE3" SCOPE="GLOBAL">00603</Property>
                        <Property NAME="ENVEM_ALERTLOG_ERROR_TYPE4" SCOPE="GLOBAL">01242,01243</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Alert Log Status
  == Collection Level: Minimum
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="alertLogStatus" TYPE="TABLE">
		<Display>
			<Label NLSID="alertLogStatus">Alert Log Error Status</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="genericErrors" TYPE="NUMBER">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="alertLogStatus_genericErrors">Generic Alert Log Error Status</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archiveHungErrors" TYPE="NUMBER">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="alertLogStatus_archiveHungErrors">Archiver Hung Alert Log Error Status</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="blockCorruptErrors" TYPE="NUMBER">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="alertLogStatus_blockCorruptErrors">Data Block Corruption Alert Log Error Status</Label>
					<ShortName NLSID="alertLogStatus_blockCorruptErrors_sht">Data Block Corruption Error Status</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sessTerminateErrors" TYPE="NUMBER">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="alertLogStatus_sessTerminateErrors">Session Terminated Alert Log Error Status</Label>
					<ShortName NLSID="alertLogStatus_sessTerminateErrors_sht">Session Terminated Error Status</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="mediaFailureErrors" TYPE="NUMBER">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="alertLogStatus_mediaFailureErrors">Media Failure Alert Log Error Status</Label>
					<ShortName NLSID="alertLogStatus_mediaFailureErrors_sht">Media Failure Error Status</ShortName>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<ExecutionDescriptor>
			<GetTable NAME="alert_log_errors" METRIC_NAME="alertLog" USE_CACHE="TRUE"/>
			<GetView NAME="generic_alert_log_errors" FROM_TABLE="alert_log_errors">
				<Column NAME="genericErrStack"/>
				<Filter COLUMN_NAME="genericErrStack" OPERATOR="ISNOTNULL"/>
			</GetView>
			<GroupBy NAME="generic_alert_log_rollup" FROM_TABLE="generic_alert_log_errors">
				<AggregateColumn NAME="genericErrors" COLUMN_NAME="genericErrStack" OPERATOR="COUNT"/>
			</GroupBy>
			<GetView NAME="archive_hung_alert_log_errors" FROM_TABLE="alert_log_errors">
				<Column NAME="archiveHungErrStack"/>
				<Filter COLUMN_NAME="archiveHungErrStack" OPERATOR="ISNOTNULL"/>
			</GetView>
			<GroupBy NAME="archive_hung_alert_log_rollup" FROM_TABLE="archive_hung_alert_log_errors">
				<AggregateColumn NAME="archiveHungErrors" COLUMN_NAME="archiveHungErrStack" OPERATOR="COUNT"/>
			</GroupBy>
			<GetView NAME="block_corrupt_alert_log_errors" FROM_TABLE="alert_log_errors">
				<Column NAME="blockCorruptErrStack"/>
				<Filter COLUMN_NAME="blockCorruptErrStack" OPERATOR="ISNOTNULL"/>
			</GetView>
			<GroupBy NAME="block_corrupt_alert_log_rollup" FROM_TABLE="block_corrupt_alert_log_errors">
				<AggregateColumn NAME="blockCorruptErrors" COLUMN_NAME="blockCorruptErrStack" OPERATOR="COUNT"/>
			</GroupBy>
			<GetView NAME="sess_terminate_alert_log_errors" FROM_TABLE="alert_log_errors">
				<Column NAME="sessTerminateErrStack"/>
				<Filter COLUMN_NAME="sessTerminateErrStack" OPERATOR="ISNOTNULL"/>
			</GetView>
			<GroupBy NAME="sess_terminate_alert_log_rollup" FROM_TABLE="sess_terminate_alert_log_errors">
				<AggregateColumn NAME="sessTerminateErrors" COLUMN_NAME="sessTerminateErrStack" OPERATOR="COUNT"/>
			</GroupBy>
			<GetView NAME="media_failure_alert_log_errors" FROM_TABLE="alert_log_errors">
				<Column NAME="mediaFailureErrStack"/>
				<Filter COLUMN_NAME="mediaFailureErrStack" OPERATOR="ISNOTNULL"/>
			</GetView>
			<GroupBy NAME="media_failure_alert_log_rollup" FROM_TABLE="media_failure_alert_log_errors">
				<AggregateColumn NAME="mediaFailureErrors" COLUMN_NAME="mediaFailureErrStack" OPERATOR="COUNT"/>
			</GroupBy>
			<JoinTables NAME="alertLogStatus">
				<Table NAME="generic_alert_log_rollup"/>
				<Table NAME="archive_hung_alert_log_rollup"/>
				<Table NAME="block_corrupt_alert_log_rollup"/>
				<Table NAME="sess_terminate_alert_log_rollup"/>
				<Table NAME="media_failure_alert_log_rollup"/>
			</JoinTables>
		</ExecutionDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Alert Log Content
  == Collection Level: {Not Collected}
  == Purpose:          On-Demand
  ======================================================================
    -->
	<Metric NAME="alertLogContent" TYPE="TABLE" HELP="NO_HELP">
		<Display>
			<Label NLSID="alertLogContent">Alert Log Content</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="alertLogContent" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="alertLog_content">Content</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OS">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="OracleHome" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="GetDumpDestination" SCOPE="INSTANCE">background_dump_dest</Property>
			<Property NAME="sizeToView" SCOPE="USER">sizeToView</Property>
			<Property NAME="command" SCOPE="GLOBAL">
         %perlBin%/perl %scriptsDir%/alertlogViewer.pl %OracleHome% %GetDumpDestination% %SID% %sizeToView%
      </Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         User Block
  == Collection Level: Minimum
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="UserBlock" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="userBlock">User Block</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="sid" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="userBlock_blocking_sid">Blocking Session ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="userBlock_count">Blocking Session Count</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
      SELECT blocking_sid, SUM(num_blocked) num_blocked
        FROM (SELECT id1, id2,
                     MAX(DECODE(block, 1, sid, 0)) blocking_sid,
                     SUM(DECODE(request, 0, 0, 1)) num_blocked
                FROM v$lock
               WHERE block = 1
                  OR request > 0
               GROUP BY id1, id2)
       GROUP BY blocking_sid
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         User Audit
  == Collection Level: Recommended
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="UserAudit" TYPE="TABLE">
		<Display>
			<Label NLSID="user_audit">User Audit</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="username" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="userAudit_username">Audited User</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="machine" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="userAudit_machine">Audited User Host</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Session Count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="userAudit_session_count">Audited User Session Count</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Username_machine" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="userAudit_username_machine">Username_Machine</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
            select uname, mname, TO_CHAR(count(uname)) , concat(concat(uname,'_'), mname) username_machine from 
            (select trim(username) uname, trim(machine) mname
            from v$session where type <> 'BACKGROUND' and username is not null )
            group by uname, mname
      ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         mgmt_sql_summary
  == Collection Level: Recommended
  == Purpose:          Reporting
  ======================================================================
    -->
	<Metric NAME="mgmt_sql_metric_helper" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="MCPkg" CHOICES="1;3"/>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="mgmt_sql_metric_helper">mgmt_sql_metric_helper</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_sql_metric_helper" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="snap_time" COLUMN_NAME="snap_time" TYPE="STRING" IS_DATE="TRUE" IS_KEY="FALSE">
				<Display>
					<Label NLSID="mgmt_sql_metric_helper_data_available">Data Available</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
        TYPE        data_cursor_type IS REF CURSOR;
        data_cursor data_cursor_type;
BEGIN
  OPEN data_cursor FOR
    SELECT NVL(MAX(s.snap_time), sysdate)
      FROM perfstat.stats$snapshot s, v$database d, v$instance i
      WHERE s.dbid = d.dbid and s.instance_number = i.instance_number;
  :1 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<Metric NAME="mgmt_sql_summary" TYPE="RAW" HELP="NO_HELP">
		<ValidIf>
			<CategoryProp NAME="MCPkg" CHOICES="1;3"/>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="mgmt_sql_summary">mgmt_sql_summary</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_sql_summary" SKIP_COLLTIME_COLUMN="TRUE" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="snap_id" COLUMN_NAME="snap_id" IS_KEY="TRUE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_summary_snap_id">Snap ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="collection_timestamp" COLUMN_NAME="collection_timestamp" TYPE="STRING" IS_DATE="TRUE" IS_KEY="FALSE">
				<Display>
					<Label NLSID="mgmt_sql_summary_collection_timestamp">Collection Timestamp</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sql" COLUMN_NAME="sql_text" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_summary_sql">SQL Statement</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="piece" COLUMN_NAME="piece" IS_KEY="TRUE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_piece">Piece</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sharableMem" COLUMN_NAME="sharable_mem" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_sharableMem">Sharable Memory</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sorts" COLUMN_NAME="sorts" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_sorts">Sorts</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="modName" COLUMN_NAME="module" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_summary_mod">Module</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="loadedVers" COLUMN_NAME="loaded_versions" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_loadedVers">Loaded Versions</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="executions" COLUMN_NAME="executions" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_executions">Executions</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="loads" COLUMN_NAME="loads" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_loads">Loads</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="invalidations" COLUMN_NAME="invalidations" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_invalidations">Invalidations</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="parseCalls" COLUMN_NAME="parse_calls" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_parseCalls">Parse Calls</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="diskReads" COLUMN_NAME="disk_reads" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_diskReads">Disk Reads</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bufferGets" COLUMN_NAME="buffer_gets" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_bufferGets">Buffer Gets</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rowsProc" COLUMN_NAME="rows_processed" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_rowsProc">Rows Processed</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cmdType" COLUMN_NAME="command_type" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_cmdType">Command Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="address" COLUMN_NAME="address" IS_KEY="TRUE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_summary_address">Address</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hashValue" COLUMN_NAME="hash_value" IS_KEY="TRUE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_hashValue">Hash Value</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="versionCount" COLUMN_NAME="version_count" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_versionCount">Sql Version Count</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cpuTime" COLUMN_NAME="cpu_time" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_cpuTime">CPU Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="elapsedTime" COLUMN_NAME="elapsed_time" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_elapsedTime">Elapsed Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="outlineSid" COLUMN_NAME="outline_sid" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_outlineSid">Outline SID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="outlineCat" COLUMN_NAME="outline_category" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_summary_outlineCat">Outline Category</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="planId" COLUMN_NAME="plan_hash_value" IS_KEY="TRUE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_planId">Plan Hash Value</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="optimizerMode" COLUMN_NAME="optimizer_mode" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_summary_optimizerMode">Optimizer Mode</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="optimizerCost" COLUMN_NAME="optimizer_cost" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_summary_optimizerCost">Optimizer Cost </Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
  TYPE                t_statistics_cursor_type IS REF CURSOR;
  v_stat_cursor_8i    t_statistics_cursor_type;
  v_stat_cursor_9i    t_statistics_cursor_type;
  v_db_version        VARCHAR2(10);
  db_version_min_8i   CONSTANT VARCHAR2(10) := '08.1.5.0.0';
  db_version_9i       CONSTANT VARCHAR2(10) := '09.0.0.0.0';
  db_version_92       CONSTANT VARCHAR2(10) := '09.2.0.0.0';
  v_dbid              NUMBER := 0;
  v_instance_number   NUMBER := 0;
  c_interval          NUMBER := 24;
  v_snap_id           NUMBER;
  v_snap_time         DATE;
  v_snap_time_dis     varchar2(50);
  v_snap_level        NUMBER;
  v_b_snap_id         NUMBER := -1;
  v_b_snap_time       DATE;
  v_b_snap_level      NUMBER := -1;
  v_e_snap_id         NUMBER := -1;
  v_e_snap_time       DATE   := sysdate;
  v_e_snap_time_dis   varchar2(50) := to_char(sysdate, 'YYYY-MM-DD HH24:MI:SS');
  v_e_snap_level      NUMBER := -1;
  v_time_interval     NUMBER := -1;
  v_current_interval  NUMBER := -1;
  v_total_disk_reads  NUMBER := -1;
  v_total_buf_gets    NUMBER := -1;
  v_e_total_disk_reads  NUMBER := -1;
  v_e_total_buf_gets    NUMBER := -1;
  v_b_total_disk_reads  NUMBER := 0;
  v_b_total_buf_gets    NUMBER := 0;
  v_b_cpu_time        NUMBER := -1;
  v_e_cpu_time        NUMBER := -1;
  v_b_parse_calls     NUMBER := -1;
  v_e_parse_calls     NUMBER := -1;
  v_b_executions      NUMBER := -1;
  v_e_executions      NUMBER := -1;
  v_pect_cpu_time     NUMBER := -1;
  v_pect_parse_calls  NUMBER := -1;
  v_pect_executions   NUMBER := -1;
  v_sql_stmt_8        Varchar2(2000);
  v_sql_stmt_90       varchar2(3500);
  v_sql_stmt_92       varchar2(3500);
  v_pect_disk_reads NUMBER := -1;
  v_pect_buf_gets   NUMBER := -1;
  c_phy_read_pct NUMBER := :1;
  c_log_read_pct NUMBER := :2;
  c_cpu_time_pct NUMBER := :3;
  c_par_call_pct NUMBER := :4;
  c_exec_pct NUMBER := :5;
  v_startup_time DATE;
  v_e_startup_time DATE;

  CURSOR get_snap_ids IS
    SELECT snap_id, snap_time, to_char(snap_time, 'YYYY-MM-DD HH24:MI:SS'), snap_level, startup_time
      FROM perfstat.stats$snapshot
      WHERE dbid = v_dbid and instance_number = v_instance_number order by snap_time desc;

  CURSOR get_stat_total_value (p_name IN VARCHAR2,
                               p_snap_id IN NUMBER,
                               p_dbid IN NUMBER,
                               p_instance_number IN NUMBER) IS
    SELECT value
    FROM perfstat.stats$sysstat
    WHERE name = p_name AND snap_id = p_snap_id AND
          dbid = p_dbid AND instance_number = p_instance_number;

BEGIN
  -- --------------------------
  -- Get database version
  -- --------------------------
  SELECT LPAD(version, 10, '0')
    INTO v_db_version
    FROM v$instance;

  -- ------------------------------
  -- Find the database ID and instance number
  -- ------------------------------
  SELECT d.dbid, i.instance_number
    INTO v_dbid, v_instance_number
    FROM v$database d, v$instance i;

  -- ------------------------------
  -- Pick the latest snapshot and another snapshot where
  -- the interval between them is closest to 24 Hrs.
  -- ------------------------------

    OPEN get_snap_ids;
    LOOP
      FETCH get_snap_ids INTO v_snap_id, v_snap_time, v_snap_time_dis, v_snap_level, v_startup_time;
      EXIT WHEN get_snap_ids%NOTFOUND;
      IF v_e_snap_id = -1 THEN
        v_e_snap_id := v_snap_id;
        v_e_snap_time := v_snap_time;
        v_e_snap_time_dis := v_snap_time_dis;
        v_e_snap_level := v_snap_level;
        v_e_startup_time := v_startup_time;
      ELSIF v_b_snap_id = -1 OR
            ABS((v_e_snap_time - v_snap_time) * 24 - c_interval) <
            ABS(v_current_interval - c_interval) THEN
        v_b_snap_id := v_snap_id;
        v_b_snap_time := v_snap_time;
        v_b_snap_level := v_snap_level;
        v_current_interval := (v_e_snap_time - v_b_snap_time) * 24;
        -- dbms_output.put_line('DB v_current_interval : ' || v_current_interval);
      END IF;
    END LOOP;
    CLOSE get_snap_ids;

    -- Check if the instance rebounced between two snapshots or there is only one snapshot available
    IF v_b_snap_time IS NULL OR v_e_startup_time > v_b_snap_time THEN
      v_b_snap_id := -1;
      v_b_snap_time := v_e_startup_time;
    END IF;

    v_time_interval := v_e_snap_time - v_b_snap_time;
    IF v_time_interval is NULL THEN
      v_time_interval := 1;
    END IF;

  IF v_e_snap_id <> -1 THEN
    IF v_db_version >= db_version_9i THEN
      OPEN get_stat_total_value('CPU used when call started', v_e_snap_id, v_dbid, v_instance_number);
      FETCH get_stat_total_value INTO v_e_cpu_time;
      CLOSE get_stat_total_value;
    END IF;

    OPEN get_stat_total_value('session logical reads', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_total_buf_gets;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('physical reads', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_total_disk_reads;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('parse count (total)', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_parse_calls;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('execute count', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_executions;
    CLOSE get_stat_total_value;
  END IF;

  IF v_b_snap_id <> -1 THEN
    IF v_db_version >= db_version_9i THEN
      OPEN get_stat_total_value('CPU used when call started', v_b_snap_id, v_dbid, v_instance_number);
      FETCH get_stat_total_value INTO v_b_cpu_time;
      CLOSE get_stat_total_value;
    END IF;

    OPEN get_stat_total_value('session logical reads', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_total_buf_gets;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('physical reads', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_total_disk_reads;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('parse count (total)', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_parse_calls;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('execute count', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_executions;
    CLOSE get_stat_total_value;
  END IF;

  v_total_disk_reads := v_e_total_disk_reads - v_b_total_disk_reads;
  v_total_buf_gets := v_e_total_buf_gets - v_b_total_buf_gets;

  v_pect_disk_reads := c_phy_read_pct * v_total_disk_reads;
  v_pect_buf_gets   := c_log_read_pct * v_total_buf_gets;
  v_pect_cpu_time   := c_cpu_time_pct * (v_e_cpu_time - v_b_cpu_time) * 10000;
  v_pect_parse_calls := c_par_call_pct * (v_e_parse_calls - v_b_parse_calls);
  v_pect_executions := c_exec_pct * (v_e_executions - v_b_executions);

  IF v_db_version < db_version_9i THEN -- 8i case
    v_sql_stmt_8 :=
      'select e.snap_id, :end_snap_time_dis, st.sql_text, st.piece, e.sharable_mem, ' ||
      'e.sorts - nvl(b.sorts,0), e.module, e.loaded_versions, ' ||
      'e.executions - nvl(b.executions,0), e.loads - nvl(b.loads,0), ' ||
      'e.invalidations - nvl(b.invalidations,0), ' ||
      'e.parse_calls - nvl(b.parse_calls,0), ' ||
      'e.disk_reads - nvl(b.disk_reads,0), ' ||
      'e.buffer_gets - nvl(b.buffer_gets,0), ' ||
      'e.rows_processed - nvl(b.rows_processed,0), st.command_type, ' ||
      'RAWTOHEX(e.address), e.hash_value, ' ||
      'e.version_count, -1 cpu_time, ' ||
      '-1 elapsed_time, -1 outline_sid, NULL outline_category, -1 plan_hash_value, ' ||
      ''' '' optimizer, 0 cost ' ||
      'from perfstat.stats$sql_summary e, perfstat.stats$sql_summary b, perfstat.stats$sqltext st ' ||
      'where b.snap_id(+) = :b_snap_id ' ||
            ' and b.dbid(+)            = e.dbid ' ||
            ' and b.instance_number(+) = e.instance_number ' ||
            ' and b.hash_value(+)      = e.hash_value ' ||
            ' and b.address(+)         = e.address ' ||
            ' and b.text_subset(+)     = e.text_subset ' ||
            ' and e.snap_id            = :e_snap_id ' ||
            ' and e.dbid               = :dbid ' ||
            ' and e.instance_number    = :instance_number ' ||
            ' and e.hash_value         = st.hash_value ' ||
            ' and e.text_subset        = st.text_subset ' ||
            ' and e.executions - nvl(b.executions,0) > 0 ' ||
            ' and (e.buffer_gets - nvl(b.buffer_gets,0) >= :pect_buf_gets ' ||
            ' or e.disk_reads - nvl(b.disk_reads,0) >= :pect_disk_reads ' ||
            ' or e.parse_calls - nvl(b.parse_calls,0) >= :pect_parse_calls ' ||
            ' or e.executions - nvl(b.executions,0) >= :pect_executions)' ||
      ' UNION ALL ' ||
      'select :end_snap_id, :snap_time_dis, ''DUMMY_STMT_FOR_SUMMARY_STATISTICS'', -1, -1, ' ||
      '-1, '' '', -1, -1, -1, -1, -1, :total_disk_reads total_disk_reads, ' ||
      ':total_buf_gets total_buffer_gets, -1, -1, ''0'', 0, -1, -1 cpu_time, ' ||
      ':time_interval elapsed_time, -1 outline_sid, ' ||
      'NULL outline_category, -1 plan_id, '' '' optimizer_mode, 0 optimizer_cost ' ||
      'from dual';
    OPEN v_stat_cursor_8i FOR v_sql_stmt_8
      USING v_e_snap_time_dis, v_b_snap_id, v_e_snap_id, v_dbid, v_instance_number,
            v_pect_buf_gets, v_pect_disk_reads, v_pect_parse_calls, v_pect_executions,
            v_e_snap_id, v_e_snap_time_dis, v_total_disk_reads, v_total_buf_gets, v_time_interval;
    :6 := v_stat_cursor_8i;
  ELSIF v_db_version < db_version_92 THEN -- 901 case
    v_sql_stmt_90 :=
      'select e.snap_id, :e_snap_time_dis, st.sql_text, st.piece, e.sharable_mem, ' ||
      'e.sorts - nvl(b.sorts,0), e.module, e.loaded_versions, ' ||
      'e.executions - nvl(b.executions,0), e.loads - nvl(b.loads,0), ' ||
      'e.invalidations - nvl(b.invalidations,0), ' ||
      'e.parse_calls - nvl(b.parse_calls,0), ' ||
      'e.disk_reads - nvl(b.disk_reads,0), ' ||
      'e.buffer_gets - nvl(b.buffer_gets,0), ' ||
      'e.rows_processed - nvl(b.rows_processed,0), st.command_type, ' ||
      'RAWTOHEX(e.address), e.hash_value, ' ||
      'e.version_count, ' ||
      'e.cpu_time - nvl(b.cpu_time,0), ' ||
      'e.elapsed_time -  nvl(b.elapsed_time,0), ' ||
      'e.outline_sid, e.outline_category, nvl(pu.plan_hash_value, -1), ' ||
      'pu.optimizer, pu.cost ' ||
      'from perfstat.stats$sql_summary e, perfstat.stats$sql_summary b, perfstat.stats$sqltext st, ' ||
           '(select u.plan_hash_value,max(u.optimizer) optimizer, max(u.cost) cost, s.hash_value,s.text_subset ' ||
            'from perfstat.stats$sql_plan_usage u, perfstat.stats$sql_summary s ' ||
            'where s.snap_id = :e_snap_id and s.dbid = :dbid and s.instance_number = :instance_number and ' ||
                  'u.hash_value(+) = s.hash_value and u.text_subset(+) = s.text_subset ' ||
            'group by s.hash_value, s.text_subset, u.plan_hash_value) pu ' ||
      'where b.snap_id(+) = :b_snap_id ' ||
            ' and b.dbid(+)            = e.dbid ' ||
            ' and b.instance_number(+) = e.instance_number ' ||
            ' and b.hash_value(+)      = e.hash_value ' ||
            ' and b.address(+)         = e.address ' ||
            ' and b.text_subset(+)     = e.text_subset ' ||
            ' and e.snap_id            = :end_snap_id ' ||
            ' and e.dbid               = :dbid_2 ' ||
            ' and e.instance_number    = :instance_number_2 ' ||
            ' and e.hash_value         = st.hash_value ' ||
            ' and e.text_subset        = st.text_subset ' ||
            ' and e.hash_value         = pu.hash_value ' ||
            ' and e.text_subset        = pu.text_subset ' ||
            ' and e.executions - nvl(b.executions,0) > 0 ' ||
            ' and (e.disk_reads - nvl(b.disk_reads,0) >= :pect_disk_reads ' ||
            ' or e.cpu_time - nvl(b.cpu_time,0) >= :pect_cpu_time ' ||
            ' or e.parse_calls - nvl(b.parse_calls,0) >= :pect_parse_calls ' ||
            ' or e.executions - nvl(b.executions,0) >= :pect_executions)' ||
      ' UNION ALL ' ||
      'select :e_snap_id_3, :e_snap_time_dis_2, ''DUMMY_STMT_FOR_SUMMARY_STATISTICS'', -1, -1, ' ||
      '-1, '' '', -1, -1, -1, -1, -1, :total_disk_reads total_disk_reads, ' ||
      ':total_buf_gets total_buffer_gets, -1, -1, ''0'', 0, -1, -1 cpu_time, ' ||
      ':time_interval elapsed_time, -1 outline_sid, ' ||
      'NULL outline_category, -1 plan_id, '' '' optimizer_mode, 0 optimizer_cost ' ||
      'from dual';

    OPEN v_stat_cursor_9i FOR v_sql_stmt_90
      USING v_e_snap_time_dis, v_e_snap_id, v_dbid, v_instance_number,
            v_b_snap_id, v_e_snap_id, v_dbid, v_instance_number,
            v_pect_disk_reads, v_pect_cpu_time, v_pect_parse_calls, v_pect_executions,
            v_e_snap_id, v_e_snap_time_dis, v_total_disk_reads, v_total_buf_gets, v_time_interval;
    :6 := v_stat_cursor_9i;
  ELSE
    v_sql_stmt_92 :=
      'select e.snap_id, :e_snap_time_dis, st.sql_text, st.piece, e.sharable_mem, ' ||
      'e.sorts - nvl(b.sorts,0), e.module, e.loaded_versions, ' ||
      'e.executions - nvl(b.executions,0), e.loads - nvl(b.loads,0), ' ||
      'e.invalidations - nvl(b.invalidations,0), ' ||
      'e.parse_calls - nvl(b.parse_calls,0), ' ||
      'e.disk_reads - nvl(b.disk_reads,0), ' ||
      'e.buffer_gets - nvl(b.buffer_gets,0), ' ||
      'e.rows_processed - nvl(b.rows_processed,0), st.command_type, ' ||
      'RAWTOHEX(e.address), e.hash_value, ' ||
      'e.version_count, ' ||
      'e.cpu_time - nvl(b.cpu_time,0), ' ||
      'e.elapsed_time -  nvl(b.elapsed_time,0), ' ||
      'e.outline_sid, e.outline_category, nvl(pu.plan_hash_value, -1), ' ||
      'pu.optimizer, pu.cost ' ||
      'from perfstat.stats$sql_summary e, perfstat.stats$sql_summary b, perfstat.stats$sqltext st, ' ||
           '(select u.plan_hash_value,max(u.optimizer) optimizer, max(u.cost) cost, s.hash_value, ' ||
            's.text_subset, max(s.dbid) dbid, max(s.instance_number) instance_number ' ||
            'from perfstat.stats$sql_plan_usage u, perfstat.stats$sql_summary s ' ||
            'where u.snap_id(+) = s.snap_id and u.dbid (+)= s.dbid and u.instance_number (+)= s.instance_number and ' ||
                  's.snap_id = :e_snap_id and s.dbid = :dbid and s.instance_number = :instance_number and ' ||
                  'u.hash_value(+) = s.hash_value and u.text_subset(+) = s.text_subset ' ||
            'group by s.hash_value, s.text_subset, u.plan_hash_value) pu ' ||
      'where b.snap_id(+) = :b_snap_id ' ||
            ' and b.dbid(+)            = e.dbid ' ||
            ' and b.instance_number(+) = e.instance_number ' ||
            ' and b.hash_value(+)      = e.hash_value ' ||
            ' and b.address(+)         = e.address ' ||
            ' and b.text_subset(+)     = e.text_subset ' ||
            ' and e.snap_id            = :e_snap_id_2 ' ||
            ' and e.dbid               = :dbid_2 ' ||
            ' and e.instance_number    = :instance_number_2 ' ||
            ' and e.hash_value         = st.hash_value ' ||
            ' and e.text_subset        = st.text_subset ' ||
            ' and e.hash_value         = pu.hash_value ' ||
            ' and e.text_subset        = pu.text_subset ' ||
            ' and e.dbid               = pu.dbid ' ||
            ' and e.instance_number    = pu.instance_number ' ||
            ' and e.executions - nvl(b.executions,0) > 0 ' ||
            ' and (e.disk_reads - nvl(b.disk_reads,0) >= :pect_disk_reads ' ||
            ' or e.cpu_time - nvl(b.cpu_time,0) >= :pect_cpu_time ' ||
            ' or e.parse_calls - nvl(b.parse_calls,0) >= :pect_parse_calls ' ||
            ' or e.executions - nvl(b.executions,0) >= :pect_executions)' ||
      ' UNION ALL ' ||
      'select :e_snap_id_3, :e_snap_time_dis_2, ''DUMMY_STMT_FOR_SUMMARY_STATISTICS'', -1, -1, ' ||
      '-1, '' '', -1, -1, -1, -1, -1, :total_disk_reads total_disk_reads, ' ||
      ':total_buf_gets total_buffer_gets, -1, -1, ''0'', 0, -1, -1 cpu_time, ' ||
      ':time_interval elapsed_time, -1 outline_sid, ' ||
      'NULL outline_category, -1 plan_id, '' '' optimizer_mode, 0 optimizer_cost ' ||
      'from dual';

    OPEN v_stat_cursor_9i FOR v_sql_stmt_92
      USING v_e_snap_time_dis, v_e_snap_id, v_dbid, v_instance_number, v_b_snap_id,
            v_e_snap_id, v_dbid, v_instance_number, v_pect_disk_reads,
            v_pect_cpu_time, v_pect_parse_calls, v_pect_executions,
            v_e_snap_id, v_e_snap_time_dis, v_total_disk_reads,
            v_total_buf_gets, v_time_interval;
    :6 := v_stat_cursor_9i;
  END IF;
END;
]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="USER">PHY_READ_PCT</Property>
			<Property NAME="SQLINPARAM2" SCOPE="USER">LOG_READ_PCT</Property>
			<Property NAME="SQLINPARAM3" SCOPE="USER">CPU_TIME_PCT</Property>
			<Property NAME="SQLINPARAM4" SCOPE="USER">PAR_CALL_PCT</Property>
			<Property NAME="SQLINPARAM5" SCOPE="USER">EXEC_PCT</Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">6</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         mgmt_sql_plan
  == Collection Level: Recommended
  == Purpose:          Reporting
  ======================================================================
    -->
	<Metric NAME="mgmt_sql_plan" TYPE="RAW" HELP="NO_HELP">
		<ValidIf>
			<CategoryProp NAME="MCPkg" CHOICES="1;3"/>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="mgmt_sql_plan">mgmt_sql_plan</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_sql_plan" SKIP_COLLTIME_COLUMN="TRUE" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="snap_id" COLUMN_NAME="snap_id" IS_KEY="TRUE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_snap_id">Snap ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="collection_timestamp" COLUMN_NAME="collection_timestamp" TYPE="STRING" IS_DATE="TRUE" IS_KEY="FALSE">
				<Display>
					<Label NLSID="mgmt_sql_plan_collection_timestamp">Collection Timestamp</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="planId" COLUMN_NAME="plan_hash_value" IS_KEY="TRUE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_planId">Plan Hash Value</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpOperation" COLUMN_NAME="operation" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpOperation">Explain Plan Operation</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpOptions" COLUMN_NAME="options" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpOptions">Explain Plan Options</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpObjectNode" COLUMN_NAME="object_node" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpObjectNode">Explain Plan Object Node</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpObjectOwner" COLUMN_NAME="object_owner" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpObjectOwner">Explain Plan Object Owner</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpObjectName" COLUMN_NAME="object_name" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpObjectName">Explain Plan Object Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpOptimizer" COLUMN_NAME="optimizer" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpOptimizer">Explain Plan Optimizer Mode</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpId" COLUMN_NAME="id" IS_KEY="TRUE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpId">Explain Plan Id</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpParentId" COLUMN_NAME="parent_id" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpParentId">Explain Plan Parent Id</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpPosition" COLUMN_NAME="position" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpPosition">Explain Plan Position</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpCost" COLUMN_NAME="cost" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpCost">Explain Plan Cost</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpCardinality" COLUMN_NAME="cardinality" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpCardinality">Explain Plan Cardinality</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpBytes" COLUMN_NAME="bytes" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpBytes">Explain Plan Bytes</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpOtherTag" COLUMN_NAME="other_tag" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpOtherTag">Explain Plan Other Tag</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpPartitionStart" COLUMN_NAME="partition_start" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpPartitionStart">Explain Plan Partition Start</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpPartitionStop" COLUMN_NAME="partition_stop" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpPartitionStop">Explain Plan Partition Stop</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpPartitionId" COLUMN_NAME="partition_id" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpPartitionId">Explain Plan Partition Id</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpOther" COLUMN_NAME="other" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpOther">Explain Plan Other</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpDistribution" COLUMN_NAME="distribution" IS_KEY="FALSE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpDistribution">Explain Plan Distribution</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpCPUCost" COLUMN_NAME="cpu_cost" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpCPUCost">Explain Plan CPU Cost</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpIOCost" COLUMN_NAME="io_cost" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpIOCost">Explain Plan I-O Cost</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpTempSpace" COLUMN_NAME="temp_space" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpTempSpace">Explain Plan Temporary Space</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpObject#" COLUMN_NAME="object_number" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpObject_num">Explain Plan Object #</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="xpDepth" COLUMN_NAME="depth" IS_KEY="FALSE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_xpDepth">Explain Plan Depth</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="address" COLUMN_NAME="address" IS_KEY="TRUE" TYPE="STRING">
				<Display>
					<Label NLSID="mgmt_sql_plan_address">Address</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hashValue" COLUMN_NAME="hash_value" IS_KEY="TRUE" TYPE="NUMBER">
				<Display>
					<Label NLSID="mgmt_sql_plan_hashValue">Hash Value</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
  TYPE                t_plan_cursor_type IS REF CURSOR;
  v_plan_cursor_8i    t_plan_cursor_type;
  v_plan_cursor_9i    t_plan_cursor_type;
  v_db_version        VARCHAR2(10);
  db_version_9i       CONSTANT VARCHAR2(10) := '09.0.0.0.0';
  db_version_92       CONSTANT VARCHAR2(10) := '09.2.0.0.0';
  v_dbid              NUMBER := 0;
  v_instance_number   NUMBER := 0;
  c_interval          NUMBER := 24;
  v_snap_id           NUMBER;
  v_snap_time         DATE;
  v_snap_level        NUMBER;
  v_b_snap_id         NUMBER := -1;
  v_b_snap_time       DATE;
  v_b_snap_level      NUMBER := -1;
  v_e_snap_id         NUMBER := -1;
  v_e_snap_time       DATE;
  v_e_snap_level      NUMBER := -1;
  v_current_interval  NUMBER := -1;
  v_total_disk_reads  NUMBER := -1;
  v_total_buf_gets    NUMBER := -1;
  v_sql_stmt_9        varchar2(3500);
  v_e_total_disk_reads  NUMBER := -1;
  v_e_total_buf_gets    NUMBER := -1;
  v_b_total_disk_reads  NUMBER := 0;
  v_b_total_buf_gets    NUMBER := 0;
  v_pect_disk_reads NUMBER := -1;
  v_pect_buf_gets   NUMBER := -1;
  v_snap_time_dis   varchar2(50);
  v_e_snap_time_dis   varchar2(50);
  v_b_cpu_time        NUMBER := -1;
  v_e_cpu_time        NUMBER := -1;
  v_b_parse_calls     NUMBER := -1;
  v_e_parse_calls     NUMBER := -1;
  v_b_executions      NUMBER := -1;
  v_e_executions      NUMBER := -1;
  v_pect_cpu_time     NUMBER := -1;
  v_pect_parse_calls  NUMBER := -1;
  v_pect_executions   NUMBER := -1;
  c_phy_read_pct NUMBER := :1;
  c_log_read_pct NUMBER := :2;
  c_cpu_time_pct NUMBER := :3;
  c_par_call_pct NUMBER := :4;
  c_exec_pct NUMBER := :5;
  v_startup_time DATE;
  v_e_startup_time DATE;

  CURSOR get_snap_ids IS
    SELECT snap_id, snap_time, to_char(snap_time, 'YYYY-MM-DD HH24:MI:SS'), snap_level, startup_time
      FROM perfstat.stats$snapshot
      WHERE dbid = v_dbid and instance_number = v_instance_number order by snap_time desc;

  CURSOR get_stat_total_value (p_name IN VARCHAR2,
                               p_snap_id IN NUMBER,
                               p_dbid IN NUMBER,
                               p_instance_number IN NUMBER) IS
    SELECT value
    FROM perfstat.stats$sysstat
    WHERE name = p_name AND snap_id = p_snap_id AND
          dbid = p_dbid AND instance_number = p_instance_number;

BEGIN
  -- --------------------------
  -- Get database version
  -- --------------------------
  SELECT LPAD(version, 10, '0')
    INTO v_db_version
    FROM v$instance;

  IF v_db_version < db_version_9i THEN
    OPEN v_plan_cursor_8i FOR
      SELECT 0 snap_id, to_char(sysdate, 'YYYY-MM-DD HH24:MI:SS'),
             0 plan_hash_value, NULL operation, NULL options, NULL object_node,
             NULL object_owner, NULL object_name, NULL optimizer, 0 id, -1 parent_id,
             0 position, 0 cost, 0 cardinality, 0 bytes, NULL other_tag,
             NULL partition_start, NULL partition_stop, 0 partition_id,
             NULL other, NULL distribution, 0 cpu_cost, 0 io_cost,
             0 temp_space, 0 object#, 0 depth, '0', 0
      FROM dual
      WHERE 0 = 1;
    :6 := v_plan_cursor_8i;
  ELSE
    -- ------------------------------
    -- Find the database ID and instance number
    -- ------------------------------
    SELECT d.dbid, i.instance_number
      INTO v_dbid, v_instance_number
      FROM v$database d, v$instance i;

    -- ------------------------------
    -- Pick the latest snapshot and another snapshot where
    -- the interval between them is closest to 24 Hrs.
    -- ------------------------------

    OPEN get_snap_ids;
    LOOP
      FETCH get_snap_ids INTO v_snap_id, v_snap_time, v_snap_time_dis, v_snap_level, v_startup_time;
      EXIT WHEN get_snap_ids%NOTFOUND;
      IF v_e_snap_id = -1 THEN
        v_e_snap_id := v_snap_id;
        v_e_snap_time := v_snap_time;
        v_e_snap_time_dis := v_snap_time_dis;
        v_e_snap_level := v_snap_level;
        v_e_startup_time := v_startup_time;
      ELSIF v_b_snap_id = -1 OR
            ABS((v_e_snap_time - v_snap_time) * 24 - c_interval) <
            ABS(v_current_interval - c_interval) THEN
        v_b_snap_id := v_snap_id;
        v_b_snap_time := v_snap_time;
        v_b_snap_level := v_snap_level;
        v_current_interval := (v_e_snap_time - v_b_snap_time) * 24;
        -- dbms_output.put_line('DB v_current_interval : ' || v_current_interval);
      END IF;
    END LOOP;
    CLOSE get_snap_ids;

    -- Check if the instance rebounced between two snapshots or there is only one snapshot available
    IF v_b_snap_time IS NULL OR v_e_startup_time > v_b_snap_time THEN
      v_b_snap_id := -1;
      v_b_snap_time := v_e_startup_time;
    END IF;

  IF v_e_snap_id <> -1 THEN
    IF v_db_version >= db_version_9i THEN
      OPEN get_stat_total_value('CPU used when call started', v_e_snap_id, v_dbid, v_instance_number);
      FETCH get_stat_total_value INTO v_e_cpu_time;
      CLOSE get_stat_total_value;
    END IF;

    OPEN get_stat_total_value('session logical reads', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_total_buf_gets;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('physical reads', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_total_disk_reads;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('parse count (total)', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_parse_calls;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('execute count', v_e_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_e_executions;
    CLOSE get_stat_total_value;
  END IF;

  IF v_b_snap_id <> -1 THEN
    IF v_db_version >= db_version_9i THEN
      OPEN get_stat_total_value('CPU used when call started', v_b_snap_id, v_dbid, v_instance_number);
      FETCH get_stat_total_value INTO v_b_cpu_time;
      CLOSE get_stat_total_value;
    END IF;

    OPEN get_stat_total_value('session logical reads', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_total_buf_gets;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('physical reads', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_total_disk_reads;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('parse count (total)', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_parse_calls;
    CLOSE get_stat_total_value;

    OPEN get_stat_total_value('execute count', v_b_snap_id, v_dbid, v_instance_number);
    FETCH get_stat_total_value INTO v_b_executions;
    CLOSE get_stat_total_value;
  END IF;

  v_total_disk_reads := v_e_total_disk_reads - v_b_total_disk_reads;
  v_total_buf_gets := v_e_total_buf_gets - v_b_total_buf_gets;

  v_pect_disk_reads := c_phy_read_pct * v_total_disk_reads;
  v_pect_buf_gets   := c_log_read_pct * v_total_buf_gets;
  v_pect_cpu_time   := c_cpu_time_pct * (v_e_cpu_time - v_b_cpu_time)*10000;
  v_pect_parse_calls := c_par_call_pct * (v_e_parse_calls - v_b_parse_calls);
  v_pect_executions := c_exec_pct * (v_e_executions - v_b_executions);

    IF v_db_version < db_version_92 THEN -- 901 case
      v_sql_stmt_9 :=
        'select :e_snap_id, :e_snap_time_str, ' ||
               'nvl(sp.plan_hash_value, -1), sp.operation, sp.options, sp.object_node, ' ||
               'sp.object_owner, sp.object_name, sp.optimizer, sp.id, sp.parent_id, ' ||
               'sp.position, sp.cost, sp.cardinality, sp.bytes, sp.other_tag, ' ||
               'sp.partition_start, sp.partition_stop, sp.partition_id, ' ||
               'sp.other, sp.distribution, sp.cpu_cost, sp.io_cost, ' ||
               'sp.temp_space, sp.object#, sp.depth, plans.address, plans.hash_value ' ||
        'from perfstat.stats$sql_plan sp, ' ||
               '(SELECT u.plan_hash_value, MAX(u.cost) cost, MAX(s.address) address, u.hash_value ' ||
                'FROM perfstat.stats$sql_plan_usage u, perfstat.stats$sql_summary s, perfstat.stats$sql_summary b ' ||
                'WHERE s.snap_id = :e_snap_id ' ||
                      ' and s.dbid = :dbid ' ||
                      ' and s.instance_number = :instance_number ' ||
                      ' and u.hash_value = s.hash_value and u.text_subset = s.text_subset ' ||
                      ' and b.snap_id(+) = :b_snap_id ' ||
                      ' and b.dbid(+)            = s.dbid ' ||
                      ' and b.instance_number(+) = s.instance_number ' ||
                      ' and b.hash_value(+)      = s.hash_value ' ||
                      ' and b.address(+)         = s.address ' ||
                      ' and b.text_subset(+)     = s.text_subset ' ||
                      ' and s.executions - nvl(b.executions,0) > 0 ' ||
                      ' and (s.disk_reads - nvl(b.disk_reads,0) >= :pect_disk_reads ' ||
                      ' or s.cpu_time - nvl(b.cpu_time,0) >= :pect_cpu_time ' ||
                      ' or s.parse_calls - nvl(b.parse_calls,0) >= :pect_parse_calls ' ||
                      ' or s.executions - nvl(b.executions,0) >= :pect_executions)' ||
                ' GROUP BY u.plan_hash_value, u.text_subset, u.hash_value) plans ' ||
        'where plans.plan_hash_value = sp.plan_hash_value';

        OPEN v_plan_cursor_9i FOR v_sql_stmt_9
          USING v_e_snap_id, v_e_snap_time_dis, v_e_snap_id, v_dbid, v_instance_number,
                v_b_snap_id, v_pect_disk_reads, v_pect_cpu_time, v_pect_parse_calls,
                v_pect_executions;
        :6 := v_plan_cursor_9i;
    ELSE -- 92 case
      v_sql_stmt_9 :=
        'select :e_snap_id, :e_snap_time_str, ' ||
               'nvl(sp.plan_hash_value, -1), sp.operation, sp.options, sp.object_node, ' ||
               'sp.object_owner, sp.object_name, sp.optimizer, sp.id, sp.parent_id, ' ||
               'sp.position, sp.cost, sp.cardinality, sp.bytes, sp.other_tag, ' ||
               'sp.partition_start, sp.partition_stop, sp.partition_id, ' ||
               'sp.other, sp.distribution, sp.cpu_cost, sp.io_cost, ' ||
               'sp.temp_space, sp.object#, sp.depth, plans.address, plans.hash_value ' ||
        'from perfstat.stats$sql_plan sp, ' ||
               '(SELECT u.plan_hash_value, MAX(u.cost) cost, MAX(s.address) address, u.hash_value, MAX(s.snap_id) snap_id ' ||
                'FROM perfstat.stats$sql_plan_usage u, perfstat.stats$sql_summary s, perfstat.stats$sql_summary b ' ||
                'WHERE u.dbid = :dbid ' ||
                      ' AND u.snap_id = :e_snap_id_2 ' ||
                      ' AND u.instance_number = :instance_number ' ||
                      ' and s.snap_id = u.snap_id ' ||
                      ' and s.dbid = u.dbid ' ||
                      ' and s.instance_number = u.instance_number ' ||
                      ' and u.hash_value = s.hash_value and u.text_subset = s.text_subset ' ||
                      ' and b.snap_id(+) = :b_snap_id ' ||
                      ' and b.dbid(+)            = s.dbid ' ||
                      ' and b.instance_number(+) = s.instance_number ' ||
                      ' and b.hash_value(+)      = s.hash_value ' ||
                      ' and b.address(+)         = s.address ' ||
                      ' and b.text_subset(+)     = s.text_subset ' ||
                      ' and s.executions - nvl(b.executions,0) > 0 ' ||
                      ' and (s.disk_reads - nvl(b.disk_reads,0) >= :pect_disk_reads ' ||
                      ' or s.cpu_time - nvl(b.cpu_time,0) >= :pect_cpu_time ' ||
                      ' or s.parse_calls - nvl(b.parse_calls,0) >= :pect_parse_calls ' ||
                      ' or s.executions - nvl(b.executions,0) >= :pect_executions)' ||
                ' GROUP BY u.dbid, u.snap_id, u.instance_number, u.plan_hash_value, u.text_subset, u.hash_value) plans ' ||
        'where plans.plan_hash_value = sp.plan_hash_value';

        OPEN v_plan_cursor_9i FOR v_sql_stmt_9
          USING v_e_snap_id, v_e_snap_time_dis, v_dbid, v_e_snap_id, v_instance_number,
                v_b_snap_id, v_pect_disk_reads, v_pect_cpu_time, v_pect_parse_calls,
                v_pect_executions;
        :6 := v_plan_cursor_9i;
    END IF;
  END IF;
END;
]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="USER">PHY_READ_PCT</Property>
			<Property NAME="SQLINPARAM2" SCOPE="USER">LOG_READ_PCT</Property>
			<Property NAME="SQLINPARAM3" SCOPE="USER">CPU_TIME_PCT</Property>
			<Property NAME="SQLINPARAM4" SCOPE="USER">PAR_CALL_PCT</Property>
			<Property NAME="SQLINPARAM5" SCOPE="USER">EXEC_PCT</Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">6</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Instance Properties
  ======================================================================
    -->
	<!--
  ========================================================================
  == Manual Instance Configuration
  ==
  == Copy this block into your targets.xml and replace values for strings
  ==  with %% to get a target instance
  ========================================================================

  <Target TYPE="oracle_database" NAME="%NAME%" VERSION="1.0">

    <Property NAME="MachineName" VALUE="%Hostname of listener%" />
    <Property NAME="Port" VALUE="%Port of listener for this database%" />
    <Property NAME="SID" VALUE="%SID of database%" />
    <Property NAME="OracleHome" VALUE="%Oracle Home for this database%"/>
    <Property Name="NAME" VALUE="%NAME%" />

    <Property NAME="UserName" VALUE="%Username to access metrics%"
               ENCRYPTED="FALSE" />
    <Property NAME="password" VALUE="%Password%"
               ENCRYPTED="FALSE" />

  </Target>
  -->
	<!-- ***************************************** -->
	<!-- Start Feature Usage Metric Definitions    -->
	<!-- ***************************************** -->
	<Metric NAME="db_FeatureUsage" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="db_FeatureUsage">Feature Usage</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_featureusage" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<!-- DBID -->
			<ColumnDescriptor NAME="DBID" COLUMN_NAME="DBID" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_FeatureUsage_database_name">DBID</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Feature Name -->
			<ColumnDescriptor NAME="name" COLUMN_NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_FeatureUsage_feature_name">Feature Name</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Currently Used -->
			<ColumnDescriptor NAME="currently_used" COLUMN_NAME="currently_used" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_currently_used">Currently Used</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Detected Usages -->
			<ColumnDescriptor NAME="detected_usages" COLUMN_NAME="detected_usages" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_detected_usages">Detected Usages</Label>
				</Display>
			</ColumnDescriptor>
			<!-- First Usage Date -->
			<ColumnDescriptor NAME="first_usage_date" COLUMN_NAME="first_usage_date" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_first_usage_date">First Usage Date</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Last Usage Date -->
			<ColumnDescriptor NAME="last_usage_date" COLUMN_NAME="last_usage_date" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_last_usage_date">Last Usage Date</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Version -->
			<ColumnDescriptor NAME="version" COLUMN_NAME="version" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_FeatureUsage_version">Version</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Last Sample Date -->
			<ColumnDescriptor NAME="last_sample_date" COLUMN_NAME="last_sample_date" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_last_sample_date">Last Sample Date</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Last Sample Period  -->
			<ColumnDescriptor NAME="last_sample_period" COLUMN_NAME="last_sample_period" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_last_sample_period">Last Sample Period</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Total Samples  -->
			<ColumnDescriptor NAME="total_samples" COLUMN_NAME="total_samples" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_total_samples">Total Samples</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Aux Count  -->
			<ColumnDescriptor NAME="aux_count" COLUMN_NAME="aux_count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_aux_count">Count</Label>
				</Display>
			</ColumnDescriptor>
			<!-- Description -->
			<ColumnDescriptor NAME="description" COLUMN_NAME="description" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_FeatureUsage_description">Description</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
        SELECT
            dbid               ,
            name               ,
            currently_used     ,
            detected_usages    ,
            first_usage_date   ,
            last_usage_date    ,
            version            ,
            last_sample_date   ,
            last_sample_period ,
            total_samples      ,
            aux_count          ,
            description
        FROM
            dba_feature_usage_statistics
        WHERE :1 != 'BASIC'
]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- ***************************************** -->
	<!-- End of Feature Usage Metric Definitions   -->
	<!-- ***************************************** -->
	<!-- ***************************************** -->
	<!-- Start db Configuration Metric Definitions -->
	<!-- Instance and Database Info -->
	<Metric NAME="db_dbNInstanceInfo" TYPE="RAW" CONFIG="TRUE">
		<Display>
			<Label NLSID="db_dbNInstanceInfo">mgmt_db_dbNInstanceInfo</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_dbNInstanceInfo_ecm">
			<ColumnDescriptor NAME="database_name" COLUMN_NAME="database_name" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_database_name">DB Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="global_name" COLUMN_NAME="global_name" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_global_name">Global Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="banner" COLUMN_NAME="banner" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_banner">DB Version</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="host_name" COLUMN_NAME="host_name" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_host_name">Host Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="instance_name" COLUMN_NAME="instance_name" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_instance_name">Instance Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="startup_time" COLUMN_NAME="startup_time" TYPE="STRING" IS_DATE="TRUE" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_startup_time">Instance Startup Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logins" COLUMN_NAME="logins" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_logins">Restricted Mode</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="log_mode" COLUMN_NAME="log_mode" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_log_mode">Log Mode</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="open_mode" COLUMN_NAME="open_mode" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_dbNInstanceInfo_open_mode">Read Only Mode</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  a.name "DB Name",
            e.global_name "Global Name",
            b.banner "DB Version",
            c.host_name "Host Name",
            c.instance_name "Instance Name" ,
            to_char(c.startup_time,'YYYY-MM-DD HH24:MI:SS') "Instance Start Time",
            decode(c.logins,'RESTRICTED','YES','NO') "Restricted Mode",
            a.log_mode  "Archive Log Mode" ,
            decode(a.open_mode,'READ ONLY','YES','NO') "Read Only Mode"
    FROM    v$database a,
            v$version b,
            v$instance c,
            global_name e
    WHERE   b.banner LIKE '%Oracle%'
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- Initialization Parameters -->
	<Metric NAME="db_init_params" TYPE="RAW" CONFIG="TRUE">
		<Display>
			<Label NLSID="db_init_params">mgmt_db_init_params</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_init_params_ecm">
			<ColumnDescriptor NAME="name" COLUMN_NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_init_params_name">Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_init_params_value">Value</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="isdefault" COLUMN_NAME="isdefault" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_init_params_isdefault">Default</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  name,
            value,
            isdefault
    FROM    v$parameter
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- Modified / added fields -->
	<!-- Redo Logs -->
	<Metric NAME="db_redoLogs" TYPE="RAW" CONFIG="TRUE">
		<!--
    <ValidIf>
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
-->
		<Display>
			<Label NLSID="db_redoLogs">mgmt_db_redoLogs</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_redoLogs_ecm">
			<ColumnDescriptor NAME="group_num" COLUMN_NAME="group_num" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_redoLogs_group_num">Group</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="status" COLUMN_NAME="status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_redoLogs_status">Status</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="members" COLUMN_NAME="members" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_redoLogs_members">Members</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="file_name" COLUMN_NAME="file_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_redoLogs_file_name">File Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="archived" COLUMN_NAME="Archived" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_redoLogs_archived">Archived</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logsize" COLUMN_NAME="logsize" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_redoLogs_logsize">Log Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sequence_num" COLUMN_NAME="sequence_num" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_redoLogs_sequence_num">Sequence Number</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="first_change_scn" COLUMN_NAME="first_change_scn" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_redoLogs_first_change">First Change</Label>
				</Display>
			</ColumnDescriptor>
                        <ColumnDescriptor NAME="os_storage_entity" COLUMN_NAME="os_storage_entity" TYPE="STRING" IS_KEY="FALSE">
				<Display>
                                	  <Label NLSID="db_redoLogs_os_storage_entity">Storage Entity</Label>
	                        </Display>
                        </ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">%perlBin%/perl %scriptsDir%/oracle_db_files.pl db_redologs</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
                        <Property NAME="ENVEM_AGENT_STATE" SCOPE="SYSTEMGLOBAL">agentStateDir</Property>
		</QueryDescriptor>
	</Metric>
	<!-- Modified / added fields -->
	<!-- Data files -->

  <!-- Datafile -->
	<Metric NAME='db_datafiles_1' TYPE='TABLE' USAGE_TYPE='HIDDEN'>
		<TableDescriptor>
			<ColumnDescriptor NAME='file_name' TYPE='STRING' IS_KEY='TRUE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='status' TYPE='STRING' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='tablespace_name' TYPE='STRING' IS_KEY='TRUE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='file_size' TYPE='NUMBER' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='autoextensible' TYPE='STRING' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='increment_by' TYPE='NUMBER' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='max_file_size' TYPE='NUMBER' IS_KEY='FALSE'>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID='SQL'>
			<Property NAME='STATEMENT' SCOPE='GLOBAL'><![CDATA[
    SELECT ddf.file_name,
           vdf.status,
           ddf.tablespace_name,
           NVL(ddf.bytes,0),
           ddf.autoextensible,
           ddf.increment_by,
           ddf.maxbytes
      FROM sys.dba_data_files ddf,
           v$datafile vdf
     WHERE (ddf.file_name = vdf.name)
  ]]></Property>
			<Property NAME='MachineName' SCOPE='INSTANCE'>MachineName</Property>
			<Property NAME='Port'        SCOPE='INSTANCE'>Port</Property>
			<Property NAME='SID'         SCOPE='INSTANCE'>SID</Property>
			<Property NAME='UserName'    SCOPE='INSTANCE'>UserName</Property>
			<Property NAME='password'    SCOPE='INSTANCE'>password</Property>
			<Property NAME='Role'        SCOPE='INSTANCE' OPTIONAL='TRUE'>Role</Property>
		</QueryDescriptor>
	</Metric>

  <!-- Temporary datafile  -->
	<Metric NAME='db_datafiles_2' TYPE='TABLE' USAGE_TYPE='HIDDEN'>
		<TableDescriptor>
			<ColumnDescriptor NAME='file_name' TYPE='STRING' IS_KEY='TRUE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='status' TYPE='STRING' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='tablespace_name' TYPE='STRING' IS_KEY='TRUE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='file_size' TYPE='NUMBER' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='autoextensible' TYPE='STRING' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='increment_by' TYPE='NUMBER' IS_KEY='FALSE'>
			</ColumnDescriptor>
			<ColumnDescriptor NAME='max_file_size' TYPE='NUMBER' IS_KEY='FALSE'>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID='SQL'>
			<Property NAME='STATEMENT' SCOPE='GLOBAL'><![CDATA[
    SELECT dtf.file_name,
           vtf.status,
           dtf.tablespace_name,
           NVL(dtf.bytes,0),
           dtf.autoextensible,
           dtf.increment_by,
           dtf.maxbytes
      FROM sys.dba_temp_files dtf,
           v$tempfile vtf
     WHERE (dtf.file_id = vtf.file#)
  ]]></Property>
			<Property NAME='MachineName' SCOPE='INSTANCE'>MachineName</Property>
			<Property NAME='Port'        SCOPE='INSTANCE'>Port</Property>
			<Property NAME='SID'         SCOPE='INSTANCE'>SID</Property>
			<Property NAME='UserName'    SCOPE='INSTANCE'>UserName</Property>
			<Property NAME='password'    SCOPE='INSTANCE'>password</Property>
			<Property NAME='Role'        SCOPE='INSTANCE' OPTIONAL='TRUE'>Role</Property>
		</QueryDescriptor>
	</Metric>

	<Metric NAME="db_datafiles" TYPE="RAW" CONFIG="TRUE">
		<Display>
			<Label NLSID="db_datafiles">mgmt_db_datafiles</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_datafiles_ecm">
			<ColumnDescriptor NAME="file_name" 
                        COLUMN_NAME="file_name" 
                        TYPE="STRING" 
                        IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_datafiles_name">Datafile Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="status" 
                        COLUMN_NAME="status" 
                        TYPE="STRING" 
                        IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_datafiles_status">Status</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace_name" 
                        COLUMN_NAME="tablespace_name" 
                        TYPE="STRING" 
                        IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_datafiles_tablespace_name">Tablespace</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="file_size" 
                        COLUMN_NAME="file_size" 
                        TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_datafiles_file_size">File Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="autoextensible" 
                        COLUMN_NAME="autoextensible" 
                        TYPE="STRING" 
                        IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_datafiles_autoextensible">Autoextensible</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="increment_by" 
                        COLUMN_NAME="increment_by" 
                        TYPE="NUMBER" 
                        IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_datafiles_increment_by">Increment By</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="max_file_size" 
                        COLUMN_NAME="max_file_size" 
                        TYPE="NUMBER" 
                        IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_datafiles_max_file_size">Max File Size</Label>
				</Display>
			</ColumnDescriptor>
                        <ColumnDescriptor NAME="os_storage_entity" COLUMN_NAME="os_storage_entity" TYPE="STRING" IS_KEY="FALSE">
				<Display>
                                	  <Label NLSID="db_datafiles_os_storage_entity">Storage Entity</Label>
	                        </Display>
                        </ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">%perlBin%/perl %scriptsDir%/oracle_db_files.pl db_datafiles</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
                        <Property NAME="ENVEM_AGENT_STATE" SCOPE="SYSTEMGLOBAL">agentStateDir</Property>
		</QueryDescriptor>
	</Metric>

	<!-- Modified / added fields -->
	<!-- Table Spaces -->
	<Metric NAME="db_tablespaces" TYPE="RAW" CONFIG="TRUE">
		<!--
    <ValidIf>
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
-->
		<Display>
			<Label NLSID="db_tablespaces">mgmt_db_tablespaces</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_tablespaces_ecm">
			<ColumnDescriptor NAME="tablespace_name" COLUMN_NAME="tablespace_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_tablespaces_name">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="status" COLUMN_NAME="status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_status">Status</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="contents" COLUMN_NAME="contents" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_contents">Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="extent_management" COLUMN_NAME="extent_management" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_extent_management">Extent Management</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="allocation_type" COLUMN_NAME="allocation_type" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_allocation_type">Allocation Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logging" COLUMN_NAME="logging" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_logging">Logging</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace_size" COLUMN_NAME="tablespace_size" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_tablespace_size">Size</Label>
				</Display>
			</ColumnDescriptor>
      <ColumnDescriptor NAME="tablespace_used_size" COLUMN_NAME="tablespace_used_size" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_tablespace_used_size">Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="initial_ext_size" COLUMN_NAME="initial_ext_size" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_initial_ext_size">Initial Ext Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="next_extent" COLUMN_NAME="next_extent" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_next_extent">Next Extent</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="increment_by" COLUMN_NAME="increment_by" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_increment_by">Increment By</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="max_extents" COLUMN_NAME="max_extents" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_tablespaces_max_extents">Max Extents</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  dtp.tablespace_name "TABLESPACE_NAME",
            dtp.status "STATUS",
            dtp.contents "CONTENTS",
            dtp.extent_management "EXTENT MANAGEMENT",
            dtp.allocation_type "ALLOCATION TYPE",
            dtp.logging "LOGGING",
            NVL(ts.bytes, 0) "SIZE (M)",
            NVL(ts.bytes - NVL(f.bytes,0),0),
            dtp.initial_extent "INITIAL EXT SIZE (K)",
            dtp.next_extent "Next Extent",
            dtp.pct_increase "INCREMENT PCT",
            dtp.max_extents "MAX EXTENTS"
    FROM    sys.dba_tablespaces dtp,
            (SELECT 	tablespace_name,
                        sum(bytes) bytes
             FROM	dba_data_files
             GROUP BY	tablespace_name) ts,
             (SELECT tablespace_name,sum(bytes) bytes from dba_free_space GROUP BY tablespace_name) f 
    WHERE   dtp.tablespace_name = ts.tablespace_name (+) AND 
            dtp.tablespace_name = f.tablespace_name (+) AND 
            NOT (dtp.extent_management LIKE 'LOCAL' AND
                 dtp.contents LIKE 'TEMPORARY')
    UNION ALL
    SELECT  dtp.tablespace_name "TABLESPACE_NAME",
            dtp.status "STATUS",
            dtp.contents "CONTENTS",
            dtp.extent_management "EXTENT MANAGEMENT",
            dtp.allocation_type "ALLOCATION TYPE",
            dtp.logging "LOGGING",
            NVL(a.bytes, 0) "SIZE (M)",
            NVL(t.cached,0),
            dtp.initial_extent "INITIAL EXT SIZE (K)",
            dtp.next_extent "Next Extent",
            dtp.pct_increase "INCREMENT PCT",
            dtp.max_extents "MAX EXTENTS"
    FROM    sys.dba_tablespaces dtp,
            (SELECT 	tablespace_name,
                        sum(bytes) bytes
             FROM		  dba_temp_files
             GROUP BY	tablespace_name) a,
             (SELECT tablespace_name,sum(bytes_cached) cached from v$temp_extent_pool GROUP BY tablespace_name ) t 
    WHERE   dtp.tablespace_name = a.tablespace_name (+) AND 
            dtp.tablespace_name = t.tablespace_name (+) AND
            dtp.extent_management LIKE 'LOCAL' AND
            dtp.contents LIKE 'TEMPORARY'
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- Added new Metrics -->
	<!-- Control files -->
	<Metric NAME="db_controlfiles" TYPE="RAW" CONFIG="TRUE">
		<!--
    <ValidIf>
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
-->
		<Display>
			<Label NLSID="db_controlfiles">mgmt_db_controlfiles</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_controlfiles_ecm">
			<ColumnDescriptor NAME="file_name" COLUMN_NAME="file_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_controlfiles_file_name">File Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="status" COLUMN_NAME="status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_controlfiles_status">Status</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="creation_date" COLUMN_NAME="creation_date" TYPE="STRING" IS_DATE="TRUE" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_controlfiles_creation_date">Creation Date</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sequence_num" COLUMN_NAME="sequence_num" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_controlfiles_sequence_num">Sequence Number</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="change_num" COLUMN_NAME="change_num" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_controlfiles_change_num">Change Number</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="mod_date" COLUMN_NAME="mod_date" TYPE="STRING" IS_DATE="TRUE" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_controlfiles_mod_date">Modification Date</Label>
				</Display>
			</ColumnDescriptor>
                        <ColumnDescriptor NAME="os_storage_entity" COLUMN_NAME="os_storage_entity" TYPE="STRING" IS_KEY="FALSE">
				<Display>
                                	  <Label NLSID="db_controlfiles_os_storage_entity">Storage Entity</Label>
	                        </Display>
                        </ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<Property NAME="command" SCOPE="GLOBAL">%perlBin%/perl %scriptsDir%/oracle_db_files.pl db_controlfiles</Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
                        <Property NAME="ENVEM_AGENT_STATE" SCOPE="SYSTEMGLOBAL">agentStateDir</Property>
		</QueryDescriptor>
	</Metric>
  
  <Metric NAME="db_controlfiles_size" TYPE="RAW" CONFIG="TRUE">
		
		<Display>
			<Label NLSID="db_controlfiles_size">mgmt_db_controlfiles_size</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_controlfiles_size_ecm">
			<ColumnDescriptor NAME="cf_size" COLUMN_NAME="cf_size" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_controlfiles_size">Controlfile Size</Label>
				</Display>
			</ColumnDescriptor>
		 </TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
      <ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="8i;8iR2;9i"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
      DECLARE
        blocksize NUMBER := 0;
        TYPE data_cursor_type IS REF CURSOR;
        data_cursor data_cursor_type;
      BEGIN
        SELECT VALUE INTO blocksize FROM v$parameter where NAME = 'db_block_size';
         OPEN data_cursor FOR
          SELECT (SUM(FLOOR((a.record_size * a.records_total + blocksize -24 -1) / (blocksize -24)) * 2) * blocksize)/1024/1024 CF_SIZE FROM v$controlfile_record_section a;
          
        :1 := data_cursor;
      END;
  ]]></Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
    <QueryDescriptor FETCHLET_ID="SQL">
      <ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="9iR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
      DECLARE
        blocksize NUMBER := 0;
        TYPE data_cursor_type IS REF CURSOR;
        data_cursor data_cursor_type;
      BEGIN
        SELECT VALUE INTO blocksize FROM v$parameter where NAME = 'db_block_size';
         OPEN data_cursor FOR   
          SELECT (SUM(FLOOR((a.record_size * a.records_total + blocksize -24 -1) / (blocksize -24)) * 2) + 4) * blocksize/1024/1024 CF_SIZE from v$controlfile_record_section a;
      
      :1 := data_cursor;
      END;
  ]]></Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
    <!-- The database team exposed the controlfile size information in 10gR1 
         only in x$kcccf table, which is not accessible by the 'dbsnmp' user in emagent metric 
         collections. There is no workaround for now. in 10gR2, its going to be exposed in
         v$database. we have to query these tables as from 10gR1 onwards, cf block size is not
         the same as db_block_size -->
    <!--QueryDescriptor FETCHLET_ID="SQL">
      <ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
      SELECT (cfbsz * cffsz)/1024/1024 "CF_SIZE" from x$kcccf
  ]]></Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor-->
	</Metric>
  
	<!-- Rollback Segments -->
	<Metric NAME="db_rollback_segs" TYPE="RAW" CONFIG="TRUE">
		<!--
    <ValidIf>
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
-->
		<Display>
			<Label NLSID="db_rollback_segs">mgmt_db_rollback_segs</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_rollback_segs_ecm">
			<ColumnDescriptor NAME="rollname" COLUMN_NAME="rollname" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_rollback_segs_rollname">Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="status" COLUMN_NAME="status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_status">Status</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace_name" COLUMN_NAME="tablespace_name" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_tablespace_name">Tablespace Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="extents" COLUMN_NAME="extents" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_extents">Extents</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rollsize" COLUMN_NAME="rollsize" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_rollsize">Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="initial_size" COLUMN_NAME="initial_size" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_initial_size">Initial Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="next_size" COLUMN_NAME="next_size" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_next_size">Next Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="maximum_extents" COLUMN_NAME="maximum_extents" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_maximum_size">Maximum Size</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="minimum_extents" COLUMN_NAME="minimum_extents" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_minimum_extents">Minimum Extents</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pct_increase" COLUMN_NAME="pct_increase" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_pct_increase">Pct Increase</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="optsize" COLUMN_NAME="optsize" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_optsize">Optsize</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="aveactive" COLUMN_NAME="aveactive" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_aveactive">Aveactive</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="wraps" COLUMN_NAME="wraps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_wraps">Wraps</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="shrinks" COLUMN_NAME="shrinks" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_shrinks">Shrinks</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="aveshrink" COLUMN_NAME="aveshrink" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_aveshrink">Aveshrink</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hwmsize" COLUMN_NAME="hwmsize" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_rollback_segs_hwmsize">Hwmsize</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
      SELECT  drs.segment_name "NAME",
              drs.status "STATUS",
              drs.tablespace_name "TABLESPACE",
              rs.extents "EXTENTS",
              rs.rssize "SIZE (M)",
              drs.initial_extent "INITIAL SIZE (K)",
              drs.next_extent "NEXT SIZE (K)",
              drs.max_extents "MAXIMUM EXTENTS",
              drs.min_extents "MINIMUM EXTENTS",
              drs.pct_increase "PCT INCREASE",
              rs.optsize "OPTSIZE",
              rs.aveactive "AVEACTIVE",
              rs.wraps "WRAPS",
              rs.shrinks "SHRINKS",
              rs.aveshrink "AVESHRINK",
              rs.hwmsize "HWMSIZE"
      FROM    sys.dba_rollback_segs drs,
              v$rollstat rs
      WHERE   drs.segment_id   = rs.usn (+)
              and substr(drs.segment_name,1,7) != '_SYSSMU'
  ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- SGA Info -->
	<Metric NAME="db_sga" TYPE="RAW" CONFIG="TRUE">
		<Display>
			<Label NLSID="db_sga">mgmt_db_sga</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_sga_ecm">
			<ColumnDescriptor NAME="sganame" COLUMN_NAME="sganame" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_sga_sganame">SGA Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sgasize" COLUMN_NAME="sgasize" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_sga_sgasize">Size</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
(SELECT 	'Shared Pool (MB)' "NAME",
          NVL(sum(bytes)/1024/1024,0) "SIZE"
 FROM 		v$sgastat
 WHERE		pool = 'shared pool')
UNION
(SELECT		'Buffered Cache (MB)' "NAME",
          NVL(bytes/1024/1024,0) "SIZE"
 FROM		  v$sgastat
 WHERE	( name = 'db_block_buffers'  AND pool IS NULL ) OR name = 'buffer_cache' )
UNION
(SELECT 	'Large Pool (KB)' "NAME",
          NVL(sum(bytes)/1024,0) "SIZE"
 FROM		  v$sgastat
 WHERE		pool = 'large pool')
UNION
(SELECT 	'Java Pool (MB)' "NAME",
          NVL(sum(bytes)/1024/1024,0) "SIZE"
 FROM		  v$sgastat
 WHERE		pool = 'java pool')
UNION
 (SELECT        'Fixed SGA (KB)' "NAME",
          NVL(value/1024,0) "SIZE"
  FROM           v$sga
  WHERE            name='Fixed Size')
UNION
 (SELECT        'Variable SGA (MB)' "NAME",
          NVL(value/1024/1024,0) "SIZE"
  FROM           v$sga
  WHERE            name='Variable Size')
UNION
 (SELECT        'Redo Buffers (KB)' "NAME",
          NVL(value/1024,0) "SIZE"
  FROM           v$sga
  WHERE            name='Redo Buffers')
UNION
 (SELECT 	'Total SGA (MB)' "NAME",
          NVL(sum(bytes)/1024/1024,0) "SIZE"
 FROM 		v$sgastat)
UNION
 (SELECT 	'Maximum SGA (MB)' "NAME",
          NVL(sum(value)/1024/1024,0) "SIZE"
 FROM 		v$sga)
ORDER BY	"SIZE"
  ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- Add License Info Metric -->
	<Metric NAME="db_license" TYPE="RAW" CONFIG="TRUE">
		<!--
    <ValidIf>
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
-->
		<Display>
			<Label NLSID="db_license">mgmt_db_license</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_license_ecm">
			<ColumnDescriptor NAME="sessions_max" COLUMN_NAME="sessions_max" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_license_sessions_max">Maximum Sessions</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sessions_warning" COLUMN_NAME="sessions_warning" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_license_sessions_warning">Warning Sessions</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sessions_current" COLUMN_NAME="sessions_current" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_license_sessions_current">Current Sessions</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sessions_highwater" COLUMN_NAME="sessions_highwater" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_license_sessions_highwater">Highwater Sessions</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="users_max" COLUMN_NAME="users_max" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_license_users_max">Maximum Users</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
	SELECT  sessions_max "Maximum Sessions",
		sessions_warning "Warning Sessions",
		sessions_current "Current Sessions",
		sessions_highwater "Highwater Sessions",
		users_max "Maximum Users"
	FROM    v$license
  ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- End of db configuration metric definitions -->
	<!-- ****************************************** -->
	<!-- High Availability - Data Guard (DG) -->
	<Metric NAME="ha_info" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="8i;8iR2;9i;9iR2;10gR1;10gR2"/>
			<!--
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
-->
		</ValidIf>
		<Display>
			<Label NLSID="ha_info">mgmt_ha_info</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_ha_info_ecm">
			<ColumnDescriptor NAME="dbid" COLUMN_NAME="dbid" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_ha_dbid">Database ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="log_mode" COLUMN_NAME="log_mode" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_ha_log_mode">Log Mode</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="force_logging" COLUMN_NAME="force_logging" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_ha_force_logging">Force Logging</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="database_role" COLUMN_NAME="database_role" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_ha_database_role">Database Role</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="flashback_on" COLUMN_NAME="flashback_on" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="db_ha_flashback_on">Flashback On</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="8i;8iR2;9i"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  dbid "Database ID",
            log_mode "Log Mode"
    FROM    v$database
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="9iR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  dbid "Database ID",
            log_mode "Log Mode",
            force_logging "Force Logging",
            database_role "Database Role"
    FROM    v$database
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  dbid "Database ID",
            log_mode "Log Mode",
            force_logging "Force Logging",
            database_role "Database Role",
            flashback_on "Flashback On"
    FROM    v$database
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- High Availability - Initialization Parameters -->
	<Metric NAME="ha_init_params" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
			<!--
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
-->
		</ValidIf>
		<Display>
			<Label NLSID="ha_init_params">mgmt_ha_init_params</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_ha_init_params_ecm">
			<ColumnDescriptor NAME="name" COLUMN_NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="ha_init_params_name">Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_init_params_value">Value</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>

		<QueryDescriptor FETCHLET_ID="SQL">
      <ValidIf>
         <CategoryProp NAME="VersionCategory" CHOICES="9i"/>
      </ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
(select name, value from v$parameter where name='db_create_file_dest')
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>

		<QueryDescriptor FETCHLET_ID="SQL">
      <ValidIf>
         <CategoryProp NAME="VersionCategory" CHOICES="9iR2;10gR1;10gR2"/>
      </ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
(select name, value from v$parameter where name='dg_broker_start')
UNION
(select name, value from v$parameter where name='db_recovery_file_dest')
UNION
(select name, value from v$parameter where name='db_recovery_file_dest_size')
UNION
(select name, value from v$parameter where name='db_create_file_dest')
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- High Availability - Database Files -->
	<Metric NAME="ha_files" TYPE="RAW" CONFIG="TRUE">
		<!--
    <ValidIf>
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
-->
		<Display>
			<Label NLSID="ha_files">mgmt_ha_files</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_ha_files_ecm">
			<ColumnDescriptor NAME="filetype" COLUMN_NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="ha_files_type">File Type Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="filessize" COLUMN_NAME="totalsize" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_files_size">Total Size</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
(SELECT 	'Data Files (MB)' "NAME",
          NVL(sum(bytes)/1024/1024,0) "TOTAL SIZE"
 FROM 		v$datafile)
UNION
(SELECT		'Online Redo Logs (MB)' "NAME",
          NVL(sum(bytes)/1024/1024,0) "TOTAL SIZE"
 FROM		  v$log)
UNION
(SELECT 	'Temporary Files (MB)' "NAME",
          NVL(sum(bytes)/1024,0) "TOTAL SIZE"
 FROM		  v$tempfile)
  ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- High Availability - RMAN Backup -->
	<Metric NAME="ha_backup" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="8i;8iR2;9i;9iR2;10gR1;10gR2"/>
			<!--
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
-->
		</ValidIf>
		<Display>
			<Label NLSID="ha_backup">mgmt_ha_backup</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_ha_backup" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="end_time" COLUMN_NAME="end_time" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_backup_end_time">End Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="status" COLUMN_NAME="status" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_backup_status">Status</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="8i;8iR2;9i;9iR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
  SELECT MAX(completion_time)
  FROM
  (SELECT completion_time FROM v$backup_set
   UNION
   SELECT completion_time FROM v$datafile_copy)
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
  SELECT  end_time,
          status
  FROM    v$rman_status
  WHERE   end_time = (select max(end_time) from v$rman_status where OPERATION='BACKUP')
  AND     operation='BACKUP'
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- High Availability - Instance Recovery (MTTR) -->
	<Metric NAME="ha_mttr" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="ha_mttr">mgmt_ha_mttr</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_ha_mttr" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="estimated_mttr" COLUMN_NAME="estimated_mttr" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_mttr_estimated_mttr">Estimated MTTR</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
			</ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
    SELECT  estimated_mttr "Estimated MTTR"
    FROM    v$instance_recovery
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!-- High Availability - RMAN Configuration -->
	<Metric NAME="ha_rman_config" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
			<!--
       <CategoryProp NAME="RACOption" CHOICES="NO"/>
-->
		</ValidIf>
		<Display>
			<Label NLSID="ha_rman_config">mgmt_ha_rman_config</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_ha_rman_config_ecm">
			<ColumnDescriptor NAME="name" COLUMN_NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="ha_rman_config_name">Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_rman_config_value">Value</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
(select 'CONTROLFILE AUTOBACKUP',
      nvl((select value from v$rman_configuration where name='CONTROLFILE AUTOBACKUP'),'') from dual)
UNION
(select name, value from v$rman_configuration where name='CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE')
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Invalid Objects (Policy Framework metric)
  == Collection Level: Recommended
  == Purpose:          Objects Policy - Invalid Objects
  ======================================================================
  -->
	<Metric NAME="db_invalidObjects" TYPE="RAW" KEYS_ONLY="TRUE" CONFIG="TRUE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<TableDescriptor TABLE_NAME="mgmt_db_invobjs_ecm">
			<ColumnDescriptor NAME="object_type" COLUMN_NAME="object_type" TYPE="NUMBER" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_invObjects_type">Object Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="object_owner" COLUMN_NAME="object_owner" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_invObjects_owner">Object Owner</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="object_name" COLUMN_NAME="object_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="db_invObjects_name">Object Name</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
  javasnm_exists  NUMBER := 0;
  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN
  SELECT count(*) INTO javasnm_exists 
    FROM sys.all_views WHERE view_name='JAVASNM';

IF javasnm_exists >= 1 THEN

 OPEN data_cursor FOR
 'SELECT /*+ all_rows */ o.type# object_type, u.name object_owner, o.name object_name ' ||
 'FROM sys.obj$ o, sys.user$ u ' ||
 'WHERE u.user# = o.owner# AND o.status NOT IN (0,1) AND o.type# IN (4, 7, 8, 9, 11, 12, 42) ' ||
 'UNION ALL ' ||
 'SELECT * FROM ( ' ||
   'SELECT o.type# object_type, u.name object_owner, nvl(l.longname, o.name) object_name ' ||
   'FROM sys.obj$ o, javasnm l, sys.user$ u ' ||
   'WHERE o.name = l.short AND o.type# = 29 AND o.owner# = u.user# AND o.status NOT IN (0,1)) ' ||
   'WHERE LENGTH(object_name) <= 1000';

ELSE

 OPEN data_cursor FOR
 'SELECT /*+ all_rows */ o.type# object_type, u.name object_owner, o.name object_name ' ||
 'FROM sys.obj$ o, sys.user$ u ' ||
 'WHERE u.user# = o.owner# AND o.status NOT IN (0,1) AND o.type# IN (4, 7, 8, 9, 11, 12, 42)';

END IF;

:1 := data_cursor;

END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Invalid Objects by Schema
  == Collection Level: Recommended
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="invalid_objects" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="invalid_objects">Invalid Objects by Schema</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="owner" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="invalid_objects_owner">Invalid Object Owner</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="invalid_objects_count">Owner's Invalid Object Count</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT /*+ all_rows */ u.name owner, count(1) invalid_count
  FROM sys.obj$ o, sys.user$ u
 WHERE u.user# = o.owner#
   AND o.status NOT IN (0,1)
 GROUP BY u.name
      ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Invalid Objects
  == Collection Level: Recommended
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="all_invalid_objects" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="all_invalid_objects">Invalid Objects</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="total_count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="all_invalid_objects_total_count">Total Invalid Object Count</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<ExecutionDescriptor>
			<GetTable NAME="invalid_objects_per_schema" METRIC_NAME="invalid_objects" USE_CACHE="TRUE"/>
			<GroupBy NAME="all_invalid_objects" FROM_TABLE="invalid_objects_per_schema">
				<AggregateColumn NAME="total_count" COLUMN_NAME="count" OPERATOR="SUM"/>
			</GroupBy>
		</ExecutionDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Database Job Status
  == Collection Level: Recommended
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="dbjob_status" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="dbjob_status">Database Job Status</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="broken" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="dbjob_status_broken">Broken Job Count</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="failed" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="dbjob_status_failed">Failed Job Count</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT SUM(broken), SUM(failed)
  FROM (SELECT DECODE(broken, 'N', 0, 1) broken,
               DECODE(NVL(failures,0), 0, 0, 1) failed
            FROM dba_jobs
           )
      ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Suspended Session
  == Collection Level: Recommended
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="suspended_session" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="suspended_session">Suspended Session</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="suspended_session_count">Suspended Session Count</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT COUNT(*)
  FROM v$resumable
 WHERE status = 'SUSPENDED'
   AND enabled = 'YES'
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Wait by Session Count
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="wait_sess" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="wait_sess">Wait by Session Count</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="event" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="wait_sess_event">Wait Event</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="wait_sess_count">Session Waiting for Event Count</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT event, count(1)
  FROM v$session_wait
 WHERE wait_time = 0
   AND event NOT IN
      ('ARCH random i/o',
       'ARCH sequential i/o',
       'KXFX: execution message dequeue - Slaves',
       'LGWR random i/o',
       'LGWR sequential i/o',
       'LGWR wait for redo copy',
       'Null event',
       'PL/SQL lock timer',
       'PX Deq Credit: need buffer',
       'PX Deq: Execute Reply',
       'PX Deq: Execution Msg',
       'PX Deq: Index Merge Close',
       'PX Deq: Index Merge Execute',
       'PX Deq: Index Merge Reply',
       'PX Deq: Join ACK',
       'PX Deq: Msg Fragment',
       'PX Deq: Par Recov Change Vector',
       'PX Deq: Par Recov Execute',
       'PX Deq: Par Recov Reply',
       'PX Deq: Parse Reply',
       'PX Deq: Table Q Normal',
       'PX Deq: Table Q Sample',
       'PX Deq: Txn Recovery Reply',
       'PX Deq: Txn Recovery Start',
       'PX Deque wait',
       'PX Idle Wait',
       'Queue Monitor Shutdown Wait',
       'Queue Monitor Slave Wait',
       'Queue Monitor Wait',
       'RFS random i/o',
       'RFS sequential i/o',
       'RFS write',
       'SQL*Net message from client',
       'SQL*Net message from dblink',
       'STREAMS apply coord waiting for slave message',
       'STREAMS apply coord waiting for some work to finish',
       'STREAMS apply slave idle wait',
       'STREAMS capture process filter callback wait for ruleset',
       'STREAMS fetch slave waiting for txns',
       'WMON goes to sleep',
       'async disk IO',
       'client message',
       'control file parallel write',
       'control file sequential read',
       'control file single write',
       'db file single write',
       'db file parallel write',
       'dispatcher timer',
       'gcs log flush sync',
       'gcs remote message',
       'ges reconfiguration to start',
       'ges remote message',
       'io done',
       'jobq slave wait',
       'lock manager wait for remote message',
       'log file parallel write',
       'log file sequential read',
       'log file single write',
       'parallel dequeue wait',
       'parallel recovery coordinator waits for cleanup of slaves',
       'parallel query dequeue',
       'parallel query idle wait - Slaves',
       'pipe get',
       'pmon timer',
       'queue messages',
       'rdbms ipc message',
       'recovery read',
       'single-task message',
       'slave wait',
       'smon timer',
       'statement suspended, wait error to be cleared',
       'unread message',
       'virtual circuit',
       'virtual circuit status',
       'wait for activate message',
       'wait for transaction',
       'wait for unread message on broadcast channel',
       'wait for unread message on multiple broadcast channels',
       'wakeup event for builder',
       'wakeup event for preparer',
       'wakeup event for reader',
       'wakeup time manager')
 GROUP BY event
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         System Sessions Waiting
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="sessions_in_wait" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="pre8;8i;8iR2;9i;9iR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="sessions_in_wait">System Sessions Waiting</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="total_count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sessions_in_wait_total_count">Waiting Session Count</Label>
					<ShortName NLSID="sessions_in_wait_total_count_short">Waiting Sessions</ShortName>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<ExecutionDescriptor>
			<GetTable NAME="sessions_waiting_per_event" METRIC_NAME="wait_sess" USE_CACHE="TRUE"/>
			<GroupBy NAME="all_sessions_waiting" FROM_TABLE="sessions_waiting_per_event">
				<AggregateColumn NAME="total_count" COLUMN_NAME="count" OPERATOR="SUM"/>
			</GroupBy>
		</ExecutionDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         RAC Global Cache Traffic per instance
  == Collection Level: Minimum
  == Purpose:          Alerts ( Only apply for RAC Instances)
  ======================================================================
    -->
	<!-- Cluster database specific metrics -->
	<Metric NAME="rac_global_cache" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2"/>
			<CategoryProp NAME="RACOption" CHOICES="YES"/>
		</ValidIf>
		<Display>
			<Label NLSID="global_cache">Global Cache Statistics</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="lost" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_blocks_lost">Global Cache Blocks Lost</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="corrupt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_blocks_corrupt">Global Cache Blocks Corrupt</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="convert_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_convert_time">Global Cache Convert Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="converts" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_converts">Global Cache Converts</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cr_receive_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_cr_receive_time">Global Cache CR Receive Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cr_receives" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_cr_receives">Global Cache CR Receives</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="current_receive_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_current_receive_time">Global Cache Current Receive Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="current_receives" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_current_receives">Global Cache Current Receives</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="get_time" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_get_time">Global Cache Get Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="gets" TYPE="NUMBER" IS_KEY="FALSE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="global_cache_gets">Global Cache Gets</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="converts_cs" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(convert_time - _convert_time)/(converts - _converts)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_converts_cs">Global Cache Average Convert Time (centi-seconds)</Label>
					<ShortName NLSID="global_cache_converts_cs_sht">GC Average Convert Time (cs)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cr_request_cs" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(cr_receive_time - _cr_receive_time)/(cr_receives - _cr_receives)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_cr_request_cs">Global Cache Average CR Block Request Time (centi-seconds)</Label>
					<ShortName NLSID="global_cache_cr_request_cs_sht">GC Average CR Block Get Time (cs)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="currentgets_cs" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(current_receive_time - _current_receive_time)/(current_receives - _current_receives)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_current_request_cs">Global Cache Average Current Block Request Time (centi-seconds)</Label>
					<ShortName NLSID="global_cache_current_request_cs_sht">GC Average Current Block Get Time (cs)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="gets_cs" TYPE="NUMBER" IS_KEY="FALSE" COMPUTE_EXPR="(get_time - _get_time)/(gets - _gets)">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_gets_cs">Global Cache Average Get Time (centi-seconds)</Label>
					<ShortName NLSID="global_cache_gets_cs_sht">GC Average Get Time (cs)</ShortName>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
   SELECT SUM(DECODE(name, 'global cache blocks lost', value, 0)) lost,
   SUM(DECODE(name, 'global cache blocks corrupt', value, 0)) corrupt,
   SUM(DECODE(name, 'global cache convert time', value, 0)) convert_time,
   SUM(DECODE(name, 'global cache converts', value, 0)) converts,
   SUM(DECODE(name, 'global cache cr block receive time', value, 0)) cr_receive_time,
   SUM(DECODE(name, 'global cache cr blocks received', value, 0)) cr_receives,
   SUM(DECODE(name, 'global cache current block receive time', value, 0)) current_receive_time,
   SUM(DECODE(name, 'global cache current blocks received', value, 0)) current_receives,
   SUM(DECODE(name, 'global cache get time', value, 0)) get_time,
   SUM(DECODE(name, 'global cache gets', value, 0)) gets
   from v$sysstat WHERE name IN ('global cache blocks lost', 'global cache blocks corrupt',
   'global cache convert time', 'global cache converts',
   'global cache cr block receive time', 'global cache cr blocks received',
   'global cache current block receive time', 'global cache current blocks received',
   'global cache get time', 'global cache gets')
      ]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
 ======================================================================
  == Category:         RAC Global Cache Traffic per instance ( Server-generated alert )
  == Collection Level: Minimum
  == Purpose:          Alerts ( Only apply for RAC Instances)
  ======================================================================
    -->
	<!-- Cluster database specific metrics -->
	<Metric NAME="rac_global_cache" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="YES"/>
		</ValidIf>
		<Display>
			<Label NLSID="global_cache">Global Cache Statistics</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="corrupt" TYPE="NUMBER" STATELESS_ALERTS="TRUE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_blocks_corrupt">Global Cache Blocks Corrupt</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="lost" TYPE="NUMBER" STATELESS_ALERTS="TRUE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_blocks_lost">Global Cache Blocks Lost</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cr_request_cs" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_cr_request_cs">Global Cache Average CR Block Request Time (centi-seconds)</Label>
					<ShortName NLSID="global_cache_cr_request_cs_sht">GC Average CR Block Get Time (cs)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="currentgets_cs" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="global_cache_current_request_cs">Global Cache Average Current Block Request Time (centi-seconds)</Label>
					<ShortName NLSID="global_cache_current_request_cs_sht">GC Average Current Block Get Time (cs)</ShortName>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="transpose" SCOPE="GLOBAL">TRUE</Property>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
      SELECT /*+ ORDERED NO_MERGE */
             m.value FROM v$alert_types a, v$threshold_types t,
      v$sysmetric m WHERE a.internal_metric_category = 'rac_global_cache'
      AND a.reason_id = t.alert_reason_id AND t.metrics_id = m.metric_id AND m.group_id = 2
      AND a.internal_metric_name !='gets_cs' and a.internal_metric_name !='converts_cs'
      AND :1 != 'BASIC'
      order by a.reason_id
      ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ============================================================================
  == Category:         Storage (Performance): Unused Space in Object
  == Collection Level: Complete
  == Purpose:          Storage Problems report
  == Description:      Determines % unused space in a segment
  == Usage Notes:      The tsNames and schema properties should be set to ";"
  ==                   if no tablespaces or schemas are to be checked.
  ==                   Otherwise, send a ; separated lists of tablespaces
  ==                   and a ; separated of schemas
  ==                   wasteMinValue - any segment with unused% less than
  ==                                   wasteMinValue is not reported at all.
  ==                   rcMinValue - any segment with row chain % less than
  ==                                rcMinValue is not reported at all.
  ==                   ckWasteSpc - 'true' to check wasted space
  ==                   ckRowChain - 'true' to check row chaining
  ==                   minSegSize - if seg space in MB under HWM is below
  ==                                this value, don't bother checking it
  ==                                for wasted space.
  ============================================================================
  -->
	<Metric NAME="wastedSpace" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="stgPerf">Segment Findings</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_space_metrics">
			<ColumnDescriptor NAME="obj_type_schema_name" COLUMN_NAME="object" TYPE="STRING" IS_KEY="TRUE">
      </ColumnDescriptor>
			<ColumnDescriptor NAME="seg_type" COLUMN_NAME="segment_type" TYPE="NUMBER" IS_KEY="TRUE">
      </ColumnDescriptor>
			<ColumnDescriptor NAME="tablespace" COLUMN_NAME="tablespace" TYPE="STRING" IS_KEY="FALSE">
      </ColumnDescriptor>
			<ColumnDescriptor NAME="problem" COLUMN_NAME="problem_code" TYPE="NUMBER" IS_KEY="TRUE">
				<!-- Numeric value is bitwise OR of specific problems:  -->
				<!--   1 = wasted space                                 -->
				<!--   2 = excess row chaining                          -->
			</ColumnDescriptor>
			<!-- Numeric value is bitwise OR of specific problems:  -->
			<!--   1 = shrink                                       -->
			<!--   2 = reorg                                        -->
			<ColumnDescriptor NAME="recommendations" COLUMN_NAME="recommendations" TYPE="NUMBER" IS_KEY="FALSE">
      </ColumnDescriptor>
			<!-- Value1 - Supporting data for problem (; separated)   -->
			<!-- Wasted Space problem values                          -->
			<!--      %unused space;#MB unused;#MB allocated          -->
			<ColumnDescriptor NAME="problemValue" COLUMN_NAME="value1" TYPE="STRING" IS_KEY="FALSE">
      </ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="OSLineToken">
			<Property NAME="perlBin" SCOPE="SYSTEMGLOBAL">perlBin</Property>
			<Property NAME="scriptsDir" SCOPE="SYSTEMGLOBAL">scriptsDir</Property>
			<!--
        Making the item properties optional="FALSE" causes problems because
        a collection without any item properties is initiated on demand
        when the metrics are viewed from the All Metrics page and no data
        is being collected.
      -->
			<Property NAME="tsNames" SCOPE="USER" OPTIONAL="TRUE">tsNames</Property>
			<Property NAME="schemas" SCOPE="USER" OPTIONAL="TRUE">schemas</Property>
			<Property NAME="wasteMinValue" SCOPE="USER" OPTIONAL="TRUE">wasteMinValue</Property>
			<Property NAME="rcMinValue" SCOPE="USER" OPTIONAL="TRUE">rcMinValue</Property>
			<Property NAME="ckWasteSpc" SCOPE="USER" OPTIONAL="TRUE">ckWasteSpc</Property>
			<Property NAME="ckRowChain" SCOPE="USER" OPTIONAL="TRUE">ckRowChain</Property>
			<Property NAME="minSegSize" SCOPE="USER" OPTIONAL="TRUE">minSegSize</Property>
			<Property NAME="command" SCOPE="GLOBAL">
        %perlBin%/perl %scriptsDir%/wastedSpace.pl %tsNames% %schemas% %wasteMinValue% %rcMinValue% %ckWasteSpc% %ckRowChain% %minSegSize%
      </Property>
			<Property NAME="startsWith" SCOPE="GLOBAL">em_result=</Property>
			<Property NAME="delimiter" SCOPE="GLOBAL">|</Property>
			<Property NAME="ENVEM_TARGET_NAME" SCOPE="INSTANCE">NAME</Property>
			<Property NAME="STDINEM_TARGET_USERNAME" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="STDINEM_TARGET_PASSWORD" SCOPE="INSTANCE">password</Property>
			<Property NAME="ENVEM_TARGET_ROLE" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="ENVEM_TARGET_ORACLE_HOME" SCOPE="INSTANCE">OracleHome</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="ENVEM_TARGET_ADDRESS" SCOPE="GLOBAL">(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=%MachineName%)(Port=%Port%))(CONNECT_DATA=(SID=%SID%)))
      </Property>
			<Property NAME="ENVVersionCategory" SCOPE="INSTANCE">VersionCategory</Property>
		</QueryDescriptor>
	</Metric>

  <!--
  ======================================================================
  == Category:  Segment Findings Privilege check
  == Purpose:   Determine whether the monitor user has enough
  ==            privileges to perform the wastedSpace check.
  == Note:      This is only collected on-demand from the
  ==            segment findings configuration page to determine
  ==            whether the monitor user needs to be granted
  ==            more privileges.  It is not loaded in the repository.
  ======================================================================
    -->
  <Metric NAME="seg_find_privs" TYPE="TABLE" USAGE_TYPE="HIDDEN"
          HELP="NO_HELP">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
    <TableDescriptor>
      <ColumnDescriptor NAME="hasPriv" TYPE="NUMBER">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
      <![CDATA[
        SELECT 1 hasPriv FROM session_privs
        WHERE privilege = 'ANALYZE ANY'
      ]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    </QueryDescriptor>
  </Metric>

  <!--
  ======================================================================
  == Category:  Segment Findings Grant Privilege
  == Purpose:   Grant the ANALYZE ANY priv to the monitor user
  == Note:      This is only collected on-demand from the
  ==            segment findings configuration page to determine
  ==            whether the monitor user needs to be granted
  ==            more privileges.  It is not loaded in the repository.
  ==
  ==            We return a useless cursor since the metric must return
  ==            a result.
  ======================================================================
    -->
  <Metric NAME="seg_grant_privs" TYPE="TABLE" USAGE_TYPE="HIDDEN"
          HELP="NO_HELP">
		<ValidIf>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
    <TableDescriptor>
      <ColumnDescriptor NAME="dummy" TYPE="NUMBER">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
      <![CDATA[
        DECLARE
            TYPE        data_cursor_type IS REF CURSOR;
            dummyCursor data_cursor_type;
        BEGIN
            EXECUTE IMMEDIATE 'GRANT ANALYZE ANY TO ' || :1;
            OPEN dummyCursor FOR
                SELECT 1 dummy from DUAL;
            :2 := dummyCursor;

        END;
      ]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="USER">UserName</Property>
      <Property NAME="password" SCOPE="USER">password</Property>
      <Property NAME="SQLINPARAM1" SCOPE="USER">monitorUser</Property>
      <Property NAME="Role" SCOPE="USER" OPTIONAL="TRUE">Role</Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">2</Property>
      <Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
    </QueryDescriptor>
  </Metric>

	<Metric NAME="latest_hdm_findings" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="hdm_findings_1">Latest HDM Findings</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_latest_hdm_findings" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="task_id" TYPE="NUMBER" COLUMN_NAME="task_id" IS_KEY="TRUE">
				<Display>
					<Label NLSID="latest_hdm_findings_task_id">Task ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="finding_id" TYPE="NUMBER" COLUMN_NAME="finding_id" IS_KEY="TRUE">
				<Display>
					<Label NLSID="latest_hdm_findings_finding_id">Finding ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rec_type" TYPE="STRING" COLUMN_NAME="rec_type" IS_KEY="TRUE">
				<Display>
					<Label NLSID="latest_hdm_findings_rec_type">Rec Type</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rec_count" TYPE="NUMBER" COLUMN_NAME="rec_count" IS_KEY="FALSE">
				<Display>
					<Label NLSID="latest_hdm_findings_rec_count">Rec Count</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="impact_pct" TYPE="NUMBER" COLUMN_NAME="impact_pct" IS_KEY="FALSE">
				<Display>
					<Label NLSID="latest_hdm_findings_impact_pct">Impact (%)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="message" TYPE="STRING" COLUMN_NAME="message" IS_KEY="FALSE">
				<Display>
					<Label NLSID="latest_hdm_findings_message">Finding Message</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="start_time" TYPE="STRING" IS_DATE="TRUE" COLUMN_NAME="start_time" IS_KEY="FALSE">
				<Display>
					<Label NLSID="latest_hdm_findings_start_time">Start Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="end_time" TYPE="STRING" IS_DATE="TRUE" COLUMN_NAME="end_time" IS_KEY="FALSE">
				<Display>
					<Label NLSID="latest_hdm_findings_end_time">End Time</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
        instance_number NUMBER;
	latest_task_id NUMBER;
	db_elapsed_time NUMBER;
	start_time VARCHAR2(1024);
	end_time VARCHAR2(1024);
	db_id NUMBER;
        TYPE        data_cursor_type IS REF CURSOR;
        data_cursor data_cursor_type;


        CURSOR get_latest_task_id  IS
        SELECT TASK_LIST.TASK_ID
   FROM (SELECT /*+ NO_MERGE(T) ORDERED */ T.TASK_ID
        FROM   (select * from dba_advisor_tasks order by task_id desc) T,
             dba_advisor_parameters_proj P1,
             dba_advisor_parameters_proj P2
        WHERE T.ADVISOR_NAME='ADDM'
          AND T.STATUS = 'COMPLETED'
          AND T.EXECUTION_START >= (sysdate - 1)
          AND T.HOW_CREATED = 'AUTO'
          AND T.TASK_ID = P1.TASK_ID
          AND P1.PARAMETER_NAME = 'INSTANCE'
          AND P1.PARAMETER_VALUE = SYS_CONTEXT('USERENV','INSTANCE')
          AND T.TASK_ID = P2.TASK_ID
          AND P2.PARAMETER_NAME = 'DB_ID'
          AND P2.PARAMETER_VALUE = to_char(db_id)
        ORDER BY T.TASK_ID DESC) TASK_LIST
WHERE ROWNUM = 1;
BEGIN

	SELECT dbid INTO db_id from v$database;

	OPEN get_latest_task_id;
	FETCH get_latest_task_id INTO latest_task_id;
	CLOSE get_latest_task_id;

	FOR param_info IN
        (SELECT parameter_value, parameter_name
         FROM dba_advisor_parameters_proj WHERE task_id= latest_task_id AND (parameter_name='START_TIME'
         OR parameter_name='END_TIME' OR parameter_name='DB_ELAPSED_TIME') ORDER BY 2)

	 LOOP
		IF param_info.parameter_name = 'DB_ELAPSED_TIME' THEN
		    db_elapsed_time:= param_info.parameter_value;
		ELSIF param_info.parameter_name = 'END_TIME' THEN
		   end_time := param_info.parameter_value;
		ELSIF param_info.parameter_name = 'START_TIME' THEN
		   start_time := param_info.parameter_value;


		END IF;
	END LOOP;

	  -- open the cursor to return
  OPEN data_cursor FOR
	 SELECT latest_task_id task_id, f.finding_id finding_id,DECODE(recInfo.type,NULL, 'Uncategorized',recInfo.type) rec_type, recInfo.recCount rec_count,
          f.impact*100/db_elapsed_time impact_pct, f.message message,
          TO_DATE(start_time ,'MM-DD-YYYY HH24:MI:SS') start_time,
          TO_DATE(end_time,'MM-DD-YYYY HH24:MI:SS') end_time
     FROM dba_advisor_findings f,
     (SELECT finding_id, count(r.rec_id) recCount,r.type
     FROM dba_advisor_recommendations r WHERE task_id=latest_task_id GROUP BY r.finding_id, r.type) recInfo
     WHERE f.task_id=latest_task_id AND f.type<>'INFORMATION' AND f.parent=0 AND  f.finding_id=recInfo.finding_id (+)
     AND :1 != 'BASIC'
     ORDER BY f.finding_id;

  :2 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">2</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>

	<Metric NAME="latest_hdm_metric_helper" TYPE="RAW">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="latest_hdm_metric_helper">latest_hdm_metric_helper</Label>
		</Display>
		<TableDescriptor TABLE_NAME="mgmt_db_hdm_metric_helper" SKIP_COLLTIME_PK="TRUE" SKIP_METRIC_COLUMN="TRUE">
			<ColumnDescriptor NAME="task_available" TYPE="NUMBER" COLUMN_NAME="task_available" IS_KEY="FALSE">
				<Display>
					<Label NLSID="mgmt_db_hdm_metric_helper_task_available">Task Available</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
        instance_number NUMBER;
        task_id NUMBER;
	db_id NUMBER;
        TYPE        data_cursor_type IS REF CURSOR;
        data_cursor data_cursor_type;

        CURSOR get_task_id IS
SELECT t.task_id
FROM   dba_advisor_tasks t,
       dba_advisor_parameters_proj p,
       dba_advisor_parameters_proj p1
WHERE  t.advisor_name='ADDM'
  AND  t.task_id = p.task_id
  AND  p.parameter_name = 'INSTANCE'
  AND  p.parameter_value = sys_context('USERENV','INSTANCE')
  AND  t.task_id = p1.task_id
  AND  p1.parameter_name = 'DB_ID'
  AND  p1.parameter_value = to_char(db_id)
  AND  rownum = 1;
BEGIN
	SELECT dbid INTO db_id from v$database;

        task_id:=-1;
	OPEN get_task_id;
	FETCH get_task_id INTO task_id;
	CLOSE get_task_id;

	  -- open the cursor to return
  OPEN data_cursor FOR
	 SELECT task_id task_available from dual;
  :1 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Server-generated alert Throughput
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="instance_throughput" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="instance_throughput">Throughput</Label>
		</Display>
		<TableDescriptor>
			<!-- Note: The order of these columns must match the output ADT. -->
			<!--       The field name matches the column name only for clarity. -->
			<ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="time_series_time">Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="transactions_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_transactions_ps">Number of Transactions (per second)</Label>
					<ShortName NLSID="instance_throughput_transactions_ps_short">Transactions/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreads_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreads_ps">Physical Reads (per second)</Label>
					<ShortName NLSID="instance_throughput_physreads_ps_short">Physical Reads/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreads_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreads_pt">Physical Reads (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwrites_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwrites_ps">Physical Writes (per second)</Label>
					<ShortName NLSID="instance_throughput_physwrites_ps_short">Phys Writes/sec</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwrites_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwrites_pt">Physical Writes (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreadsdir_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreadsdir_ps">Physical Reads Direct (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreadsdir_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreadsdir_pt">Physical Reads Direct (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwritesdir_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwritesdir_ps">Physical Writes Direct (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwritesdir_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwritesdir_pt">Physical Writes Direct (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreadslob_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreadslob_ps">Physical Reads Direct Lobs (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physreadslob_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physreadslob_pt">Physical Reads Direct Lobs (per transaction)</Label>
					<ShortName NLSID="instance_throughput_physreadslob_pt_sht">Physical Reads Direct Lobs (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwriteslob_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwriteslob_ps">Physical Writes Direct Lobs (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="physwriteslob_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_physwriteslob_pt">Physical Writes Direct Lobs (per transaction)</Label>
					<ShortName NLSID="instance_throughput_physwriteslob_pt_sht">Physical Writes Direct Lobs (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redosize_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redosize_ps">Redo Generated (per second)</Label>
					<ShortName NLSID="instance_throughput_redosize_ps_short">Redo Size/sec</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logons_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logons_ps">Cumulative Logons (per second)</Label>
					<ShortName NLSID="instance_throughput_logons_ps_short">Logons/sec</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logons_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logons_pt">Cumulative Logons (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="opncurs_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_opncurs_ps">Open Cursors (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="opncurs_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_opncurs_pt">Open Cursors (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="commits_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_commits_ps">User Commits (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="commits_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_commits_pt">User Commits (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rollbacks_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_rollbacks_ps">User Rollbacks (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rollbacks_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_rollbacks_pt">User Rollbacks (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="usercalls_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_usercalls_ps">User Calls (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="usercalls_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_usercalls_pt">User Calls (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recurscalls_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_recurscalls_ps">Recursive Calls (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="recurscalls_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_recurscalls_pt">Recursive Calls (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logreads_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logreads_ps">Session Logical Reads (per second)</Label>
					<ShortName NLSID="instance_throughput_logreads_ps_short">Logical Reads/s</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logreads_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_logreads_pt">Session Logical Reads (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbwrcheckpoints_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_dbwrcheckpoints_ps">DBWR Checkpoints (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bgcheckpoints_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_bgcheckpoints_ps">BG Checkpoints (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redowrites_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redowrites_ps">Redo Writes (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redowrites_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redowrites_pt">Redo Writes (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tabscanslong_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanslong_ps">Scans on Long Tables (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tabscanslong_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanslong_pt">Scans on Long Tables (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tabscanstotal_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanstotal_ps">Total Table Scans (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="tabscanstotal_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_tabscanstotal_pt">Total Table Scans (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="indxscansfull_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_indxscansfull_pt">Full Index Scans (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="indxscansfull_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_indxscansfull_ps">Full Index Scans (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="indxscanstotal_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_indxscanstotal_ps">Total Index Scans (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="indxscanstotal_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_indxscanstotal_pt">Total Index Scans (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="parses_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_parses_ps">Total Parses (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="parses_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_parses_pt">Total Parses (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hardparses_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_hardparses_ps">Hard Parses (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="hardparses_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_hardparses_pt">Hard Parses (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="failedparses_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_failedparses_ps">Parse Failure Count (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="failedparses_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_failedparses_pt">Parse Failure Count (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sortsdisk_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_sortsdisk_ps">Sorts to Disk (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="sortsdisk_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_sortsdisk_pt">Sorts to Disk (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="rows_psort" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_rows_psort">Rows Processed (per sort)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="executeswoparse_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_executeswoparse_pct">Executes Performed without Parses (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="softparse_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_softparse_pct">Soft Parse (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="usercall_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_usercall_pct">User Calls (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="networkbytes_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_networkbytes_ps">Network Bytes (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqtimeouts_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqtimeouts_ps">Enqueue Timeout (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqtimeouts_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqtimeouts_pt">Enqueue Timeout (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqwaits_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqwaits_ps">Enqueue Waits (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqwaits_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqwaits_pt">Enqueue Waits (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqdeadlocks_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqdeadlocks_ps">Enqueue Deadlocks (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqdeadlocks_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqdeadlocks_pt">Enqueue Deadlocks (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqreqs_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqreqs_ps">Enqueue Requests (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="enqreqs_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_enqreqs_pt">Enqueue Requests (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbblkgets_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_dbblkgets_ps">Database Block Gets (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbblkgets_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_dbblkgets_pt">Database Block Gets (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="consistentreadgets_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_consistentreadgets_ps">Consistent Read Gets (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="consistentreadgets_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_consistentreadgets_pt">Consistent Read Gets (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbblkchanges_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_dbblkchanges_ps">Database Block Changes (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dbblkchanges_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_dbblkchanges_pt">Database Block Changes (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="consistentreadchanges_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_consistentreadchanges_ps">Consistent Read Changes (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="consistentreadchanges_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_consistentreadchanges_pt">Consistent Read Changes (per transaction)</Label>
					<ShortName NLSID="instance_throughput_consistentreadchanges_pt_sht">Cons Read Changes (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="crblks_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_crblks_ps">Consistent Read Blocks Created (per second)</Label>
					<ShortName NLSID="instance_throughput_crblks_ps_sht">Cons Read Blocks Created (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="crblks_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_crblks_pt">Consistent Read Blocks Created (per transaction)</Label>
					<ShortName NLSID="instance_throughput_crblks_pt_sht">Cons Read Blocks Created (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="crundorecs_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_crundorecs_pt">Consistent Read Undo Records Applied (per transaction)</Label>
					<ShortName NLSID="instance_throughput_crundorecs_pt_sht">Cons Read Undo Applied (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="userrollbackundorec_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_userrollbackundorec_ps">User Rollback Undo Records Applied (per second)</Label>
					<ShortName NLSID="instance_throughput_userrollbackundorec_ps_sht">Rollback Undo Applied (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="userrollbackundorec_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_userrollbackundorec_pt">User Rollback Undo Records Applied (per transaction)</Label>
					<ShortName NLSID="instance_throughput_userrollbackundorec_pt_sht">Rollback Undo Applied (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="leafnodesplits_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_leafnodesplits_ps">Leaf Node Splits (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="leafnodesplits_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_leafnodesplits_pt">Leaf Node Splits (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="branchnodesplits_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_branchnodesplits_ps">Branch Node Splits (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="branchnodesplits_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_branchnodesplits_pt">Branch Node Splits (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redosize_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_redosize_pt">Redo Generated (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="crundorecs_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_throughput_crundorecs_ps">Consistent Read Undo Records Applied (per second)</Label>
					<ShortName NLSID="instance_throughput_crundorecs_ps_sht">Cons Read Undo Applied (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
          SELECT /*+ ORDERED USE_MERGE(m) */
                 TO_CHAR(CAST(m.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                        'YYYY-MM-DD HH24:MI:SS TZD'),
               SUM(CASE WHEN a.internal_metric_name = 'transactions_ps'
                        THEN m.value ELSE 0 END) transactions_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physreads_ps'
                        THEN m.value ELSE 0 END) physreads_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physreads_pt'
                        THEN m.value ELSE 0 END) physreads_pt,
               SUM(CASE WHEN a.internal_metric_name = 'physwrites_ps'
                        THEN m.value ELSE 0 END) physwrites_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physwrites_pt'
                        THEN m.value ELSE 0 END) physwrites_pt,
               SUM(CASE WHEN a.internal_metric_name = 'physreadsdir_ps'
                        THEN m.value ELSE 0 END) physreadsdir_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physreadsdir_pt'
                        THEN m.value ELSE 0 END) physreadsdir_pt,
               SUM(CASE WHEN a.internal_metric_name = 'physwritesdir_ps'
                        THEN m.value ELSE 0 END) physwritesdir_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physwritesdir_pt'
                        THEN m.value ELSE 0 END) physwritesdir_pt,
               SUM(CASE WHEN a.internal_metric_name = 'physreadslob_ps'
                        THEN m.value ELSE 0 END) physreadslob_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physreadslob_pt'
                        THEN m.value ELSE 0 END) physreadslob_pt,
               SUM(CASE WHEN a.internal_metric_name = 'physwriteslob_ps'
                        THEN m.value ELSE 0 END) physwriteslob_ps,
               SUM(CASE WHEN a.internal_metric_name = 'physwriteslob_pt'
                        THEN m.value ELSE 0 END) physwriteslob_pt,
               SUM(CASE WHEN a.internal_metric_name = 'redosize_ps'
                        THEN m.value ELSE 0 END) redosize_ps,
               SUM(CASE WHEN a.internal_metric_name = 'logons_ps'
                        THEN m.value ELSE 0 END) logons_ps,
               SUM(CASE WHEN a.internal_metric_name = 'logons_pt'
                        THEN m.value ELSE 0 END) logons_pt,
               SUM(CASE WHEN a.internal_metric_name = 'opncurs_ps'
                        THEN m.value ELSE 0 END) opncurs_ps,
               SUM(CASE WHEN a.internal_metric_name = 'opncurs_pt'
                        THEN m.value ELSE 0 END) opncurs_pt,
               SUM(CASE WHEN a.internal_metric_name = 'commits_ps'
                        THEN m.value ELSE 0 END) commits_ps,
               SUM(CASE WHEN a.internal_metric_name = 'commits_pt'
                        THEN m.value ELSE 0 END) commits_pt,
               SUM(CASE WHEN a.internal_metric_name = 'rollbacks_ps'
                        THEN m.value ELSE 0 END) rollbacks_ps,
               SUM(CASE WHEN a.internal_metric_name = 'rollbacks_pt'
                        THEN m.value ELSE 0 END) rollbacks_pt,
               SUM(CASE WHEN a.internal_metric_name = 'usercalls_ps'
                        THEN m.value ELSE 0 END) usercalls_ps,
               SUM(CASE WHEN a.internal_metric_name = 'usercalls_pt'
                        THEN m.value ELSE 0 END) usercalls_pt,
               SUM(CASE WHEN a.internal_metric_name = 'recurscalls_ps'
                        THEN m.value ELSE 0 END) recurscalls_ps,
               SUM(CASE WHEN a.internal_metric_name = 'recurscalls_pt'
                        THEN m.value ELSE 0 END) recurscalls_pt,
               SUM(CASE WHEN a.internal_metric_name = 'logreads_ps'
                        THEN m.value ELSE 0 END) logreads_ps,
               SUM(CASE WHEN a.internal_metric_name = 'logreads_pt'
                        THEN m.value ELSE 0 END) logreads_pt,
               SUM(CASE WHEN a.internal_metric_name = 'dbwrcheckpoints_ps'
                        THEN m.value ELSE 0 END) dbwrcheckpoints_ps,
               SUM(CASE WHEN a.internal_metric_name = 'bgcheckpoints_ps'
                        THEN m.value ELSE 0 END) bgcheckpoints_ps,
               SUM(CASE WHEN a.internal_metric_name = 'redowrites_ps'
                        THEN m.value ELSE 0 END) redowrites_ps,
               SUM(CASE WHEN a.internal_metric_name = 'redowrites_pt'
                        THEN m.value ELSE 0 END) redowrites_pt,
               SUM(CASE WHEN a.internal_metric_name = 'tabscanslong_ps'
                        THEN m.value ELSE 0 END) tabscanslong_ps,
               SUM(CASE WHEN a.internal_metric_name = 'tabscanslong_pt'
                        THEN m.value ELSE 0 END) tabscanslong_pt,
               SUM(CASE WHEN a.internal_metric_name = 'tabscanstotal_ps'
                        THEN m.value ELSE 0 END) tabscanstotal_ps,
               SUM(CASE WHEN a.internal_metric_name = 'tabscanstotal_pt'
                        THEN m.value ELSE 0 END) tabscanstotal_pt,
               SUM(CASE WHEN a.internal_metric_name = 'indxscansfull_pt'
                        THEN m.value ELSE 0 END) indxscansfull_pt,
               SUM(CASE WHEN a.internal_metric_name = 'indxscansfull_ps'
                        THEN m.value ELSE 0 END) indxscansfull_ps,
               SUM(CASE WHEN a.internal_metric_name = 'indxscanstotal_ps'
                        THEN m.value ELSE 0 END) indxscanstotal_ps,
               SUM(CASE WHEN a.internal_metric_name = 'indxscanstotal_pt'
                        THEN m.value ELSE 0 END) indxscanstotal_pt,
               SUM(CASE WHEN a.internal_metric_name = 'parses_ps'
                        THEN m.value ELSE 0 END) parses_ps,
               SUM(CASE WHEN a.internal_metric_name = 'parses_pt'
                        THEN m.value ELSE 0 END) parses_pt,
               SUM(CASE WHEN a.internal_metric_name = 'hardparses_ps'
                        THEN m.value ELSE 0 END) hardparses_ps,
               SUM(CASE WHEN a.internal_metric_name = 'hardparses_pt'
                        THEN m.value ELSE 0 END) hardparses_pt,
               SUM(CASE WHEN a.internal_metric_name = 'failedparses_ps'
                        THEN m.value ELSE 0 END) failedparses_ps,
               SUM(CASE WHEN a.internal_metric_name = 'failedparses_pt'
                        THEN m.value ELSE 0 END) failedparses_pt,
               SUM(CASE WHEN a.internal_metric_name = 'sortsdisk_ps'
                        THEN m.value ELSE 0 END) sortsdisk_ps,
               SUM(CASE WHEN a.internal_metric_name = 'sortsdisk_pt'
                        THEN m.value ELSE 0 END) sortsdisk_pt,
               SUM(CASE WHEN a.internal_metric_name = 'rows_psort'
                        THEN m.value ELSE 0 END) rows_psort,
               SUM(CASE WHEN a.internal_metric_name = 'executeswoparse_pct'
                        THEN m.value ELSE 0 END) executeswoparse_pct,
               SUM(CASE WHEN a.internal_metric_name = 'softparse_pct'
                        THEN m.value ELSE 0 END) softparse_pct,
               SUM(CASE WHEN a.internal_metric_name = 'usercall_pct'
                        THEN m.value ELSE 0 END) usercall_pct,
               SUM(CASE WHEN a.internal_metric_name = 'networkbytes_ps'
                        THEN m.value ELSE 0 END) networkbytes_ps,
               SUM(CASE WHEN a.internal_metric_name = 'enqtimeouts_ps'
                        THEN m.value ELSE 0 END) enqtimeouts_ps,
               SUM(CASE WHEN a.internal_metric_name = 'enqtimeouts_pt'
                        THEN m.value ELSE 0 END) enqtimeouts_pt,
               SUM(CASE WHEN a.internal_metric_name = 'enqwaits_ps'
                        THEN m.value ELSE 0 END) enqwaits_ps,
               SUM(CASE WHEN a.internal_metric_name = 'enqwaits_pt'
                        THEN m.value ELSE 0 END) enqwaits_pt,
               SUM(CASE WHEN a.internal_metric_name = 'enqdeadlocks_ps'
                        THEN m.value ELSE 0 END) enqdeadlocks_ps,
               SUM(CASE WHEN a.internal_metric_name = 'enqdeadlocks_pt'
                        THEN m.value ELSE 0 END) enqdeadlocks_pt,
               SUM(CASE WHEN a.internal_metric_name = 'enqreqs_ps'
                        THEN m.value ELSE 0 END) enqreqs_ps,
               SUM(CASE WHEN a.internal_metric_name = 'enqreqs_pt'
                        THEN m.value ELSE 0 END) enqreqs_pt,
               SUM(CASE WHEN a.internal_metric_name = 'dbblkgets_ps'
                        THEN m.value ELSE 0 END) dbblkgets_ps,
               SUM(CASE WHEN a.internal_metric_name = 'dbblkgets_pt'
                        THEN m.value ELSE 0 END) dbblkgets_pt,
               SUM(CASE WHEN a.internal_metric_name = 'consistentreadgets_ps'
                        THEN m.value ELSE 0 END) consistentreadgets_ps,
               SUM(CASE WHEN a.internal_metric_name = 'consistentreadgets_pt'
                        THEN m.value ELSE 0 END) consistentreadgets_pt,
               SUM(CASE WHEN a.internal_metric_name = 'dbblkchanges_ps'
                        THEN m.value ELSE 0 END) dbblkchanges_ps,
               SUM(CASE WHEN a.internal_metric_name = 'dbblkchanges_pt'
                        THEN m.value ELSE 0 END) dbblkchanges_pt,
               SUM(CASE WHEN a.internal_metric_name = 'consistentreadchanges_ps'
                        THEN m.value ELSE 0 END) consistentreadchanges_ps,
               SUM(CASE WHEN a.internal_metric_name = 'consistentreadchanges_pt'
                        THEN m.value ELSE 0 END) consistentreadchanges_pt,
               SUM(CASE WHEN a.internal_metric_name = 'crblks_ps'
                        THEN m.value ELSE 0 END) crblks_ps,
               SUM(CASE WHEN a.internal_metric_name = 'crblks_pt'
                        THEN m.value ELSE 0 END) crblks_pt,
               SUM(CASE WHEN a.internal_metric_name = 'crundorecs_pt'
                        THEN m.value ELSE 0 END) crundorecs_pt,
               SUM(CASE WHEN a.internal_metric_name = 'userrollbackundorec_ps'
                        THEN m.value ELSE 0 END) userrollbackundorec_ps,
               SUM(CASE WHEN a.internal_metric_name = 'userrollbackundorec_pt'
                        THEN m.value ELSE 0 END) userrollbackundorec_pt,
               SUM(CASE WHEN a.internal_metric_name = 'leafnodesplits_ps'
                        THEN m.value ELSE 0 END) leafnodesplits_ps,
               SUM(CASE WHEN a.internal_metric_name = 'leafnodesplits_pt'
                        THEN m.value ELSE 0 END) leafnodesplits_pt,
               SUM(CASE WHEN a.internal_metric_name = 'branchnodesplits_ps'
                        THEN m.value ELSE 0 END) branchnodesplits_ps,
               SUM(CASE WHEN a.internal_metric_name = 'branchnodesplits_pt'
                        THEN m.value ELSE 0 END) branchnodesplits_pt,
               SUM(CASE WHEN a.internal_metric_name = 'redosize_pt'
                        THEN m.value ELSE 0 END) redosize_pt,
               SUM(CASE WHEN a.internal_metric_name = 'crundorecs_ps'
                        THEN m.value ELSE 0 END) crundorecs_ps
          FROM v$alert_types a, v$threshold_types t, v$sysmetric m
         WHERE a.internal_metric_category = 'instance_throughput'
           AND a.reason_id = t.alert_reason_id
           AND t.metrics_id = m.metric_id
           AND m.group_id = 2
           AND :1 != 'BASIC'
         GROUP BY m.end_time
         ORDER BY m.end_time ASC
      ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
		</PushDescriptor>
	</Metric>

 <!--
  ======================================================================
  == Category:         Wait Bottlenecks
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
  <Metric NAME="wait_bottlenecks" TYPE="TABLE">
    <ValidIf>
       <CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
    </ValidIf>
    <Display>
      <Label NLSID="wait_bottlenecks">Wait Bottlenecks</Label>
    </Display>

    <TableDescriptor>

      <!-- columns provided by the query descriptor's fetchlet call -->

      <!-- Note: The order of these columns must match the output ADT. -->
      <!--       The field name matches the column name only for clarity. -->
      <ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="time_series_time">Time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="user_wait_time_pct" TYPE="NUMBER">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_user_wait_time_pct">Wait Time (%)</Label>
          <ShortName NLSID="wait_bottlenecks_user_wait_time_pct_short">Wait Time %</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="db_time_users" TYPE="NUMBER"
                        TRANSIENT="TRUE" HELP="NO_HELP" />
      <ColumnDescriptor NAME="db_cpu_users" TYPE="NUMBER"
                        TRANSIENT="TRUE" HELP="NO_HELP" />
      <ColumnDescriptor NAME="host_cpu_usage_pct" TYPE="NUMBER">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_host_cpu_usage_pct">Host CPU Utilization (%)</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="userio_users" TYPE="NUMBER"
                        TRANSIENT="TRUE" HELP="NO_HELP" />
      <ColumnDescriptor NAME="max_cpu_cnt" TYPE="NUMBER"
                        TRANSIENT="TRUE" HELP="NO_HELP"/>

      <!-- columns based on deltas or other computations from counters -->

      <ColumnDescriptor NAME="user_cpu_time_cnt" TYPE="NUMBER"
                        COMPUTE_EXPR="0 > db_cpu_users ? 1/0 : (db_cpu_users > max_cpu_cnt ? 1/0 : db_cpu_users)">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_user_cpu_time_cnt">Active Sessions Using CPU</Label>
          <ShortName NLSID="wait_bottlenecks_user_cpu_time_cnt_short">Sessions: CPU</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="userio_wait_cnt" TYPE="NUMBER"
                        COMPUTE_EXPR="0 > userio_users ? 1/0 : userio_users">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_userio_wait_cnt">Active Sessions Waiting: I/O</Label>
          <ShortName NLSID="wait_bottlenecks_userio_wait_cnt_short">Sessions: I/O</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="active_sessions" TYPE="NUMBER"
                        COMPUTE_EXPR="db_cpu_users + userio_users > db_time_users ? 1/0 : db_time_users"
                        TRANSIENT="TRUE">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_active_sessions">Active Sessions</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="other_wait_cnt" TYPE="NUMBER"
                        COMPUTE_EXPR="active_sessions - user_cpu_time_cnt - userio_wait_cnt">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_other_wait_cnt">Active Sessions Waiting: Other</Label>
          <ShortName NLSID="wait_bottlenecks_other_wait_cnt_short">Sessions: Other</ShortName>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="avg_user_cpu_time_pct" TYPE="NUMBER"
                        COMPUTE_EXPR="100*user_cpu_time_cnt/max_cpu_cnt">
        <Display FOR_SUMMARY_UI="TRUE">
          <Label NLSID="wait_bottlenecks_avg_user_cpu_time_pct">Average Instance CPU (%)</Label>
          <ShortName NLSID="wait_bottlenecks_avg_user_cpu_time_pct_short">Instance CPU (%)</ShortName>
        </Display>
      </ColumnDescriptor>

    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <ValidIf>
        <CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
      </ValidIf>
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
      <![CDATA[
        SELECT TO_CHAR(CAST(md.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                       'YYYY-MM-DD HH24:MI:SS TZD') time,
               md.user_wait_time_pct,
               md.db_time_ps db_time_users,
               md.cpu_time_ps db_cpu_users,
               DECODE(:1, 'TRUE', md.host_cpu_usage_pct,
                                  NULL) host_cpu_usage_pct,
               wcd.users userio_users,
               :2 max_cpu_cnt
          FROM (SELECT DISTINCT wait_class_id
                  FROM v$event_name
                 WHERE wait_class = 'User I/O'
                   AND :3 = 'TRUE') wcn,
               (SELECT wait_class_id,
                       intsize_csec, end_time,
                       time_waited / intsize_csec users
                  FROM v$waitclassmetric_history
                 WHERE end_time >= SYSDATE - 15/(60*24)) wcd,
               (SELECT intsize_csec, end_time,
                       SUM(CASE WHEN metric_name = 'Database Wait Time Ratio'
                                THEN value
                                ELSE 0 END) user_wait_time_pct,
                       SUM(CASE WHEN metric_name = 'Database Time Per Sec'
                                THEN value / 100
                                ELSE 0 END) db_time_ps,
                       SUM(CASE WHEN metric_name = 'CPU Usage Per Sec'
                                 THEN value / 100
                                 ELSE 0 END) cpu_time_ps,
                       SUM(CASE WHEN metric_name = 'Host CPU Utilization (%)'
                                 THEN value
                                 ELSE 0 END) host_cpu_usage_pct
                  FROM v$sysmetric_history
                 WHERE metric_name IN ('Database Wait Time Ratio',
                                       'Database Time Per Sec',
                                        'CPU Usage Per Sec',
                                        'Host CPU Utilization (%)')
                   AND group_id = 2
                   AND end_time >= SYSDATE - 15/(60*24)
                 GROUP BY intsize_csec, end_time) md
         WHERE wcn.wait_class_id = wcd.wait_class_id
           AND wcd.intsize_csec = md.intsize_csec
           AND wcd.end_time = md.end_time
           AND :4 != 'BASIC'
         ORDER BY md.end_time ASC
         ]]>
      </Property>
      <Property NAME="SQLINPARAM1" SCOPE="INSTANCE">CPUTimingEnabled</Property>
      <Property NAME="SQLINPARAM2" SCOPE="INSTANCE">CPUCount</Property>
      <Property NAME="SQLINPARAM3" SCOPE="INSTANCE">TimedStatistics</Property>
      <Property NAME="SQLINPARAM4" SCOPE="INSTANCE">StatisticsLevel</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE" OPTIONAL="TRUE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    </QueryDescriptor>

  <PushDescriptor RECVLET_ID="AQMetrics">
    <Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
    <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
    <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
    <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
    <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
    <Property NAME="password" SCOPE="INSTANCE">password</Property>
    <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    <Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
  </PushDescriptor>

  </Metric>

 <!--
  ======================================================================
  == Category:         Server-generated alert File
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
  <Metric NAME="file" TYPE="TABLE">
    <ValidIf>
       <CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
    </ValidIf>

    <Display>
      <Label NLSID="file">Database Files</Label>
    </Display>
    <TableDescriptor>
      <ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="time_series_time">Time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="file_name" TYPE="STRING" IS_KEY="TRUE">
          <Display>
            <Label NLSID="file_name">File Name</Label>
          </Display>
        </ColumnDescriptor>
      <ColumnDescriptor NAME="read_cs" TYPE="NUMBER" IS_KEY="FALSE">
          <Display>
            <Label NLSID="file_read_cs">Average File Read Time (centi-seconds)</Label>
          </Display>
        </ColumnDescriptor>
      <ColumnDescriptor NAME="write_cs" TYPE="NUMBER" IS_KEY="FALSE">
          <Display>
            <Label NLSID="file_write_cs">Average File Write Time (centi-seconds)</Label>
          </Display>
        </ColumnDescriptor>
    </TableDescriptor>
    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
      <![CDATA[
         SELECT TO_CHAR(CAST(d.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                        'YYYY-MM-DD HH24:MI:SS TZD'),
                n.name, d.average_read_time, d.average_write_time
         FROM v$dbfile n, v$filemetric d
         WHERE d.file_id = n.file#
         AND :1 != 'BASIC'
         ORDER BY d.end_time ASC

      ]]>
      </Property>
	   <Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    </QueryDescriptor>
     <PushDescriptor RECVLET_ID="AQMetrics">
       <Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
       <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
       <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
       <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
       <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
       <Property NAME="password" SCOPE="INSTANCE">password</Property>
       <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
       <Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
       <Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
       <Property NAME="KeyColumn" SCOPE="GLOBAL">file_name</Property>
     </PushDescriptor>
  </Metric>

	<!--
  ======================================================================
  == Category:         Server-generated alert Service
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="service" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="service">Database Services</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="time_series_time">Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="service_name">Service Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="elapsed_cs" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="service_elapsed_cs">Service Response Time (per user call) (microseconds)</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cpu_cs" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="service_cpu_cs">Service CPU Time (per user call) (microseconds)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
                   <ValidIf>
                     <CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
                   </ValidIf>
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
        SELECT TO_CHAR(CAST(d.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                       'YYYY-MM-DD HH24:MI:SS TZD') time,
               d.service_name,
               d.elapsedpercall, d.cpupercall
          FROM v$servicemetric_history d
         WHERE d.end_time >= SYSDATE - 15/(60*24) AND :1 != 'BASIC'
         ORDER BY d.end_time ASC
      ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">name</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Server-generated alert system_response_time_per_call
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="system_response_time_per_call" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="system_response_time_per_call">System Response Time Per Call</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="time_series_time">Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="time_cs" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="system_response_time_per_call_time_cs">System Response Time (centi-seconds)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
          SELECT /*+ ORDERED */
                 TO_CHAR(CAST(m.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                        'YYYY-MM-DD HH24:MI:SS TZD'),
                        m.value
          FROM v$alert_types a, v$threshold_types t, v$sysmetric_history m
         WHERE a.internal_metric_category = 'system_response_time_per_call'
           AND a.reason_id = t.alert_reason_id
           AND t.metrics_id = m.metric_id
           AND a.internal_metric_name = 'time_cs'
           AND m.group_id = 2
           AND m.end_time >= sysdate - 15 / (60 * 24)
           AND :1 != 'BASIC'
         ORDER BY m.end_time ASC
      ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Server-generated alert Database Limits
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="Database_Resource_Usage" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="resource_usage">Database Limits</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="time_series_time">Time</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="logons" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="logons">Current Logons Count</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="opencursors" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="opencursors">Current Open Cursors Count</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="user_limit" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="user_limit">User Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="process_usage" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="process_usage">Process Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="session_usage" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="session_usage">Session Limit Usage (%)</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
          SELECT /*+ ORDERED */
                 TO_CHAR(CAST(m.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                        'YYYY-MM-DD HH24:MI:SS TZD'),
               SUM(CASE WHEN a.internal_metric_name = 'logons'
                        THEN m.value ELSE 0 END) logons,
               SUM(CASE WHEN a.internal_metric_name = 'opencursors'
                        THEN m.value ELSE 0 END) opencursors,
               SUM(CASE WHEN a.internal_metric_name = 'user_limit'
                        THEN m.value ELSE 0 END) user_limit,
               SUM(CASE WHEN a.internal_metric_name = 'process_usage'
                        THEN m.value ELSE 0 END) process_usage,
               SUM(CASE WHEN a.internal_metric_name = 'session_usage'
                        THEN m.value ELSE 0 END) session_usage
          FROM v$alert_types a, v$threshold_types t, v$sysmetric m
         WHERE a.internal_metric_category = 'Database_Resource_Usage'
           AND a.reason_id = t.alert_reason_id
           AND t.metrics_id = m.metric_id
           AND m.group_id = 2
           AND :1 != 'BASIC'
         GROUP BY m.end_time
         ORDER BY m.end_time ASC
      ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================

  == Category:         Server-generated alert instance_efficiency
  == Collection Level: Recommended
  == Purpose:          Server generated alert
  ======================================================================
  -->
	<Metric NAME="instance_efficiency" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="instance_efficiency">Efficiency</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
				<Display>
					<Label NLSID="time_series_time">Time</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="bufcachehit_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_bufcachehit_pct">Buffer Cache Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="inmem_sort_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_inmem_sort_pct">Sorts in Memory (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="redologalloc_hit_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_redologalloc_hit_pct">Redo Log Allocation Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cursorcachehit_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_cursor_hit_pct">Cursor Cache Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cpuusage_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_cpu_usage_ps">CPU Usage (per second)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cpuusage_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_cpuusage_pt">CPU Usage (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pxdwngrd25_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pxdwngrd25_ps">Parallel Execution Downgraded 25% or more (per second)</Label>
					<ShortName NLSID="instance_efficiency_pxdwngrd25_ps_sht">PX Downgrade >=25% (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pxdwngrd50_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pxdwngrd50_ps">Parallel Execution Downgraded 50% or more (per second)</Label>
					<ShortName NLSID="instance_efficiency_pxdwngrd50_ps_sht">PX Downgrade >=50% (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pxdwngrd75_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pxdwngrd75_ps">Parallel Execution Downgraded 75% or more (per second)</Label>
					<ShortName NLSID="instance_efficiency_pxdwngrd75_ps_sht">PX Downgrade >=75% (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pxdwngrd_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pxdwngrd_ps">Parallel Execution Downgraded (per second)</Label>
					<ShortName NLSID="instance_efficiency_pxdwngrd_ps_sht">PX Downgrade (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pxdwngrdserial_ps" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pxdwngrdserial_ps">Parallel Execution Downgraded to Serial (per second)</Label>
					<ShortName NLSID="instance_efficiency_pxdwngrdserial_ps_sht">PX Serial Downgrade (per sec)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pxdwngrdserial_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pxdwngrdserial_pt">Parallel Execution Downgraded to Serial (per transaction)</Label>
					<ShortName NLSID="instance_efficiency_pxdwngrdserial_pt_sht">PX Serial Downgrade (per txn)</ShortName>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="cpu_time_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_cpu_time_pct">Database CPU Time (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="response_time_pt" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_response_time_pt">Response Time (per transaction)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dictionaryhit_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_dictionaryhit_pct">Data Dictionary Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="libcache_hit_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_libcache_hit_pct">Library Cache Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="libcache_miss_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_libcache_miss_pct">Library Cache Miss (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="pgacachehit_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_pgacachehit_pct">PGA Cache Hit (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="dictionarymiss_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="instance_efficiency_dictionarymiss_pct">Row Cache Miss Ratio (%)</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
          SELECT /*+ ORDERED USE_MERGE(m) */
                 TO_CHAR(CAST(m.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                        'YYYY-MM-DD HH24:MI:SS TZD'),
               SUM(CASE WHEN a.internal_metric_name = 'bufcachehit_pct'
                        THEN m.value ELSE 0 END) bufcachehit_pct,
               SUM(CASE WHEN a.internal_metric_name = 'inmem_sort_pct'
                        THEN m.value ELSE 0 END) inmem_sort_pct,
               SUM(CASE WHEN a.internal_metric_name = 'redologalloc_hit_pct'
                        THEN m.value ELSE 0 END) redologalloc_hit_pct,
               SUM(CASE WHEN a.internal_metric_name = 'cursorcachehit_pct'
                        THEN m.value ELSE 0 END) cursorcachehit_pct,
               SUM(CASE WHEN a.internal_metric_name = 'cpuusage_ps'
                        THEN m.value ELSE 0 END) cpuusage_ps,
               SUM(CASE WHEN a.internal_metric_name = 'cpuusage_pt'
                        THEN m.value ELSE 0 END) cpuusage_pt,
               SUM(CASE WHEN a.internal_metric_name = 'pxdwngrd25_ps'
                        THEN m.value ELSE 0 END) pxdwngrd25_ps,
               SUM(CASE WHEN a.internal_metric_name = 'pxdwngrd50_ps'
                        THEN m.value ELSE 0 END) pxdwngrd50_ps,
               SUM(CASE WHEN a.internal_metric_name = 'pxdwngrd75_ps'
                        THEN m.value ELSE 0 END) pxdwngrd75_ps,
               SUM(CASE WHEN a.internal_metric_name = 'pxdwngrd_ps'
                        THEN m.value ELSE 0 END) pxdwngrd_ps,
               SUM(CASE WHEN a.internal_metric_name = 'pxdwngrdserial_ps'
                        THEN m.value ELSE 0 END) pxdwngrdserial_ps,
               SUM(CASE WHEN a.internal_metric_name = 'pxdwngrdserial_pt'
                        THEN m.value ELSE 0 END) pxdwngrdserial_pt,
               SUM(CASE WHEN a.internal_metric_name = 'cpu_time_pct'
                        THEN m.value ELSE 0 END) cpu_time_pct,
               SUM(CASE WHEN a.internal_metric_name = 'response_time_pt'
                        THEN m.value ELSE 0 END) response_time_pt,
               SUM(CASE WHEN a.internal_metric_name = 'dictionaryhit_pct'
                        THEN m.value ELSE 0 END) dictionaryhit_pct,
               SUM(CASE WHEN a.internal_metric_name = 'libcache_hit_pct'
                        THEN m.value ELSE 0 END) libcache_hit_pct,
               SUM(CASE WHEN a.internal_metric_name = 'libcache_miss_pct'
                        THEN m.value ELSE 0 END) libcache_miss_pct,
               SUM(CASE WHEN a.internal_metric_name = 'pgacachehit_pct'
                        THEN m.value ELSE 0 END) pgacachehit_pct,
               SUM(CASE WHEN a.internal_metric_name = 'dictionarymiss_pct'
                        THEN m.value ELSE 0 END) dictionarymiss_pct
          FROM v$alert_types a, v$threshold_types t, v$sysmetric m
         WHERE a.internal_metric_category = 'instance_efficiency'
           AND a.reason_id = t.alert_reason_id
           AND t.metrics_id = m.metric_id
           AND m.group_id = 2
           AND :1 != 'BASIC'
         GROUP BY m.end_time
         ORDER BY m.end_time ASC
      ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
		</PushDescriptor>
	</Metric>
  <!--
  ======================================================================
  == Category:         Wait by Session Class
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
  <Metric NAME="wait_sess_cls" TYPE="TABLE">
    <ValidIf>
       <CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
    </ValidIf>
    <Display>
      <Label NLSID="wait_sess_cls">Waits by Wait Class</Label>
    </Display>
    <TableDescriptor>
      <ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP">
        <Display>
          <Label NLSID="time_series_time">Time</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="class" TYPE="STRING" IS_KEY="TRUE">
          <Display>
            <Label NLSID="wait_sess_cls_class">Wait Class</Label>
          </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="avg_users_waiting_on_class" TYPE="NUMBER">
        <Display>
          <Label NLSID="wait_sess_cls_avg_users">Average Users Waiting Count</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="dbtime_waitclass_pct" TYPE="NUMBER">
        <Display>
          <Label NLSID="wait_sess_cls_dbtime_pct">Database Time Spent Waiting (%)</Label>
        </Display>
      </ColumnDescriptor>
    </TableDescriptor>
    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
      <![CDATA[
        SELECT TO_CHAR(CAST(wcd.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                       'YYYY-MM-DD HH24:MI:SS TZD') time,
               wcn.wait_class,
               wcd.average_waiter_count, wcd.dbtime_in_wait
          FROM (SELECT DISTINCT wait_class, wait_class_id
                  FROM v$event_name) wcn,
               (SELECT end_time, wait_class_id,
                       average_waiter_count, dbtime_in_wait
                  FROM v$waitclassmetric_history) wcd
         WHERE wcn.wait_class_id = wcd.wait_class_id
           AND wcd.end_time >= SYSDATE - 15/(60*24)
           AND :1 != 'BASIC'
         ORDER BY wcd.end_time ASC
      ]]>
      </Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    </QueryDescriptor>
  <PushDescriptor RECVLET_ID="AQMetrics">
    <Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
    <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
    <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
    <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
    <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
    <Property NAME="password" SCOPE="INSTANCE">password</Property>
    <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    <Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
    <Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
    <Property NAME="KeyColumn" SCOPE="GLOBAL">class</Property>
  </PushDescriptor>
  </Metric>

	<!--
  ======================================================================
  == Category:         Server-generated alert User Block
  == Collection Level: Minimum
  == Purpose:          Alerts
  ======================================================================
    -->
	<Metric NAME="UserBlock" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="userBlock">User Block</Label>
		</Display>
		<TableDescriptor>
                  <ColumnDescriptor NAME="time" TYPE="STRING" IS_TIMESTAMP="TRUE" TRANSIENT="TRUE" HELP="NO_HELP"/>
			<ColumnDescriptor NAME="sid" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="userBlock_blocking_sid">Blocking Session ID</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="count" TYPE="NUMBER" IS_KEY="FALSE">
				<Display>
					<Label NLSID="userBlock_count">Blocking Session Count</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
        SELECT /*+ ORDERED */
               TO_CHAR(CAST(d.end_time AS TIMESTAMP) AT TIME ZONE 'GMT',
                               'YYYY-MM-DD HH24:MI:SS TZD') time,
                       'SID: '||d.entity_id||' Serial#: '||d.entity_sequence id, d.value
          FROM v$alert_types a, v$threshold_types t, v$metric_history d
         WHERE a.internal_metric_category = 'UserBlock'
           AND a.internal_metric_name = 'count'
           AND a.reason_id = t.alert_reason_id
           AND t.metrics_id = d.metric_id
           AND d.group_id = 4
           AND d.end_time >= SYSDATE - 15/(60*24)
           AND d.value > 0
           AND :1 != 'BASIC'
         ORDER BY d.end_time ASC
       ]]></Property>
			<Property NAME="SQLINPARAM1" SCOPE="INSTANCE">StatisticsLevel</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">sid</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Non-threshold based alert Suspended_Session
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="Suspended_Session" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="Suspended_Session">Session Suspended</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="Object_Causing" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="Suspended_Session_Object_Causing">Object Causing</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Tablespace" TYPE="STRING">
				<Display>
					<Label NLSID="Suspended_Session_Tablespace">Session Suspended by Tablespace Limitation</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Rollback_Segment" TYPE="STRING">
				<Display>
					<Label NLSID="Suspended_Session_Rollback_Segment">Session Suspended by Rollback Segment Limitation</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Data_Object" TYPE="STRING">
				<Display>
					<Label NLSID="Suspended_Session_Data_Object">Session Suspended by Data Object Limitation</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Quota" TYPE="STRING">
				<Display>
					<Label NLSID="Suspended_Session_Quota">Session Suspended by Quota Limitation</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">Object_Causing</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Non-threshold based alert Recovery_Area
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="Recovery_Area" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="Recovery_Area">Recovery Area</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="Recovery_Area" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="Recovery_Area_Recovery_Area">Recovery Area</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Free_Space" TYPE="NUMBER">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="Recovery_Area_Free_Space">Recovery Area Free Space (%)</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT 'RECOVERY AREA' recovery_area,
       CASE WHEN space_limit > 0 AND space_limit >= space_used AND space_used >= space_reclaimable
            THEN 100 * (space_limit - (space_used - space_reclaimable))/space_limit
            ELSE NULL END free_space
  FROM v$recovery_file_dest
 WHERE name IS NOT NULL
   AND rownum = 1
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">Recovery_Area</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         Non-threshold based alert Snap_Shot_Too_Old
  == Collection Level: Recommended
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="Snap_Shot_Too_Old" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			<CategoryProp NAME="RACOption" CHOICES="NO"/>
		</ValidIf>
		<Display>
			<Label NLSID="Snap_Shot_Too_Old">Snapshot Too Old</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="Object_Causing" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="Snap_Shot_Too_Old_Object_Causing">Object Causing</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Tablespace" TYPE="STRING" STATELESS_ALERTS="TRUE">
				<Display>
					<Label NLSID="Snap_Shot_Too_Old_Tablespace">Snapshot Too Old due to Tablespace Limit</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="Rollback_Segment" TYPE="STRING" STATELESS_ALERTS="TRUE">
				<Display>
					<Label NLSID="Snap_Shot_Too_Old_Rollback_Segment">Snapshot Too Old due to Rollback Segment Limit</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
			<Property NAME="KeyField" SCOPE="GLOBAL">OBJECT_NAME</Property>
			<Property NAME="KeyColumn" SCOPE="GLOBAL">Object_Causing</Property>
		</PushDescriptor>
	</Metric>
	<!--
  ======================================================================
  == Category:         SGA Pool Wastage
  == Collection Level: Minimum
  == Purpose:          Alerts, Trending
  ======================================================================
    -->
	<Metric NAME="sga_pool_wastage" TYPE="TABLE">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
		</ValidIf>
		<Display>
			<Label NLSID="sga_pool_wastage">SGA Pool Wastage</Label>
		</Display>
		<TableDescriptor>
			<ColumnDescriptor NAME="shared_free_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sga_pool_wastage_shared_free_pct">Shared Pool Free (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="large_free_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sga_pool_wastage_large_free_pct">Large Pool Free (%)</Label>

				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="java_free_pct" TYPE="NUMBER" IS_KEY="FALSE">
				<Display FOR_SUMMARY_UI="TRUE">
					<Label NLSID="sga_pool_wastage_java_free_pct">Java Pool Free (%)</Label>

				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE

  shared_free_pct NUMBER;
  large_free_pct  NUMBER;
  java_free_pct   NUMBER;

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  ----
  -- compute each percentage
  ----
  FOR pool_pct_pair IN
    (SELECT pool,
            DECODE(total_bytes, 0, NULL, 100 * free_bytes / total_bytes) pct
       FROM (SELECT pool,
                    SUM(bytes) total_bytes,
                    SUM(DECODE(name, 'free memory', bytes, 0)) free_bytes
               FROM v$sgastat
              GROUP BY pool))
  LOOP
    IF pool_pct_pair.pool = 'shared pool' THEN
      shared_free_pct := pool_pct_pair.pct;
    ELSIF pool_pct_pair.pool = 'java pool' THEN
      java_free_pct   := pool_pct_pair.pct;
    ELSIF pool_pct_pair.pool = 'large pool' THEN
      large_free_pct  := pool_pct_pair.pct;
    END IF;
  END LOOP;

  -- open the cursor to return
  OPEN data_cursor FOR
    SELECT shared_free_pct,
           large_free_pct,
           java_free_pct
      FROM dual;

  :1 := data_cursor;
END;
]]></Property>
			<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
			<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
		<PushDescriptor RECVLET_ID="AQMetrics">
			<Property NAME="QueueName" SCOPE="GLOBAL">ALERT_QUE</Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			<Property NAME="InstanceName" SCOPE="INSTANCE">InstanceName</Property>
		</PushDescriptor>
	</Metric>

<!-- ESM database collection -->
  <Metric NAME="remoteRolesAndAuthentication" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE"  HELP="NO_HELP">
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="8iR2;9i;9iR2;10gR1;10gR2"/>
    </ValidIf>
    <Display>
      <Label NLSID="remote_role_authentication">Remote OS Roles and Authentication</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
  SELECT name,value
  FROM sys.v_$parameter
  where name='remote_os_roles' or name='remote_os_authent'
]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>
  </Metric>

  <Metric NAME="remoteLoginPasswordFile" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="8iR2;9i;9iR2;10gR1;10gR2"/>
    </ValidIf>
    <Display>
      <Label NLSID="remote_password_file">Remote Password File</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
  SELECT name,value
  FROM sys.v_$parameter
  where name='remote_login_passwordfile'
]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>
  </Metric>

  <Metric NAME="installAndDemoAcccounts" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="8iR2;9i;9iR2;10gR1;10gR2"/>
	<CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
    <Display>
      <Label NLSID="install_demo_accounts">Default Install and Demo Accounts</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
select 'default user account', U.username || '(' || LOWER( U.account_status ) || ')'
from SYS.DBA_USERS U
where   U.username IN 	(
			'ADAMS',
			'BLAKE',
			'CLARK',
			'CTXSYS',
			'HR',
			'JONES',
			'LBACSYS',
			'MDSYS',
			'OE',
			'OLAPDBA',
			'OLAPSVR',
			'OLAPSYS',
			'ORDPLUGINS',
			'ORDSYS',
			'PM',
			'QS',
			'QS_ADM',
			'QS_CB',
			'QS_CBADM',
			'QS_CS',
			'QS_ES',
			'QS_OS',
			'QS_WS',
			'SH',
			'ANONYMOUS',
			'ODM_MTR',
			'ODM',
			'OUTLN',
			'WKPROXY',
			'WKSYS',
			'WMSYS',
			'XDB'
			)
  and   U.account_status <> 'EXPIRED & LOCKED'
ORDER BY U.username
]]>

      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>
  </Metric>

  <Metric NAME="defaultAccountPasswords" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="8iR2;9i;9iR2;10gR1;10gR2"/>
	<CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
    <Display>
      <Label NLSID="default_user_password">Default Users and Passwords</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
SELECT
'Default account uid/pwd', username
FROM dba_users
WHERE (username,password) IN (
('ADAMS',			'72CDEF4A3483F60D'),
('ADLDEMO',			'147215F51929A6E8'),
('APPLSYS',			'0F886772980B8C79'),
('APPLYSYSPUB',			'A5E09E84EC486FC9'),
('APPS',			'D728438E8A5925E0'),
('AQDEMO',			'5140E342712061DD'),
('AQJAVA',			'8765D2543274B42E'),
('AQUSER',			'4CF13BDAC1D7511C'),
('AUDIOUSER',			'CB4F2CEC5A352488'),
('AURORA$ORB$UNAUTHENTICATED',	'80C099F0EADF877E'),
('BLAKE',			'9435F2E60569158E'),
('CATALOG',			'397129246919E8DA'),
('CDEMO82',			'7299A5E2A5A05820'),
('CDEMOCOR',			'3A34F0B26B951F3F'),
('CDEMOUCB',			'CEAE780F25D556F8'),
('CDEMORID',			'E39CEFE64B73B308'),
('CENTRA',			'63BF5FFE5E3EA16D'),
('CLARK',			'7AAFE7D01511D73F'),
('COMPANY',			'402B659C15EAF6CB'),
('CSMIG',			'09B4BB013FBD0D65'),
('CTXDEMO',			'CB6B5E9D9672FE89'),
('CTXSYS',			'24ABAB8B06281B4C'),
('DBSNMP',			'E066D214D5421CCC'),
('DEMO',			'4646116A123897CF'),
('DEMO8',			'0E7260738FDFD678'),
('EMP',				'B40C23C6E2B4EA3D'),
('EVENT',			'7CA0A42DA768F96D'),
('FINANCE',			'6CBBF17292A1B9AA'),
('FND',				'0C0832F8B6897321'),
('GPFD',			'BA787E988F8BC424'),
('GPLD',			'9D561E4D6585824B'),
('HR',				'4C6D73C3E8B0F0DA'),
('HLW',				'855296220C095810'),
('IMAGEUSER',			'E079BF5E433F0B89'),
('IMEDIA',			'8FB1DC9A6F8CE827'),
('JONES',			'B9E99443032F059D'),
('JMUSER',			'063BA85BF749DF8E'),
('LBACSYS',			'AC9700FD3F1410EB'),
('MDSYS',			'9AAEB2214DCC9A31'),
('MFG',				'FC1B0DD35E790847'),
('MIGRATE',			'5A88CE52084E9700'),
('MILLER',			'D0EFCD03C95DF106'),
('MMO2',			'AE128772645F6709'),
('MODTEST',			'BBFF58334CDEF86D'),
('MOREAU',			'CF5A081E7585936B'),
('NAMES',			'9B95D28A979CC5C4'),
('MTSSYS',			'6465913FF5FF1831'),
('MXAGENT',			'C5F0512A64EB0E7F'),
('OCITEST',			'C09011CB0205B347'),
('ODS',				'89804494ADFC71BC'),
('ODSCOMMON',			'59BBED977430C1A8'),
('OE',				'D1A2DFC623FDA40A'),
('OEMADM',			'9DCE98CCF541AAE6'),
('OLAPDBA',			'1AF71599EDACFB00'),
('OLAPSVR',			'AF52CFD036E8F425'),
('OLAPSYS',			'3FB8EF9DB538647C'),
('ORAREGSYS',			'28D778112C63CB15'),
('ORDPLUGINS',			'88A2B2C183431F00'),
('ORDSYS',			'7EFA02EC7EA6B86F'),
('OUTLN',			'4A3BA55E08595C81'),
('PERFSTAT',			'AC98877DE1297365'),
('PM',				'C7A235E6D2AF6018'),
('PO',				'355CBEC355C10FEF'),
('PO8',				'7E15FBACA7CDEBEC'),
('PO7',				'6B870AF28F711204'),
('PORTAL30',			'D373ABE86992BE68'),
('PORTAL30_DEMO',		'CFD1302A7F832068'),
('PORTAL30_PUBLIC',		'42068201613CA6E2'),
('PORTAL30_SSO',		'882B80B587FCDBC8'),
('PORTAL30_SSO_PS',		'F2C3DC8003BC90F8'),
('PORTAL30_SSO_PUBLIC',		'98741BDA2AC7FFB2'),
('POWERCARTUSER',		'2C5ECE3BEC35CE69'),
('PRIMARY',			'70C3248DFFB90152'),
('PUBSUB',			'80294AE45A46E77B'),
('QS',				'4603BCD2744BDE4F'),
('QS_ADM',			'3990FB418162F2A0'),
('QS_CB',			'870C36D8E6CD7CF5'),
('QS_CBADM',			'20E788F9D4F1D92C'),
('QS_CS',			'2CA6D0FC25128CF3'),
('QS_ES',			'9A5F2D9F5D1A9EF4'),
('QS_OS',			'0EF5997DC2638A61'),
('QS_WS',			'0447F2F756B4F460'),
('RE',				'933B9A9475E882A6'),
('REPADMIN',			'915C93F34954F5F8'),
('RMAIL',			'DA4435BBF8CAE54C'),
('RMAN',			'E7B5D92911C831E1'),
('SAMPLE',			'E74B15A3F7A19CA8'),
('SCOTT',			'F894844C34402B67'),
('SDOS_ICSAP',			'C789210ACC24DA16'),
('SECDEMO',			'009BBE8142502E10'),
('SH',				'54B253CBBAAA8C48'),
('SYS',				'D4C5016086B2DC6A'),
('SYSADM',			'BA3E855E93B5B9B0'),
('SYSTEM',			'D4DF7931AB130E37'),
('TAHITI',			'F339612C73D27861'),
('TDOS_ICSAP',			'7C0900F751723768'),
('TRACESVR',			'F9DA8977092B7B81'),
('TSDEV',			'29268859446F5A8C'),
('TSUSER',			'90C4F894E2972F08'),
('USER0',			'8A0760E2710AB0B4'),
('USER1',			'BBE7786A584F9103'),
('USER2',			'1718E5DBB8F89784'),
('USER3',			'94152F9F5B35B103'),
('USER4',			'2907B1BFA9DA5091'),
('USER5',			'6E97FCEA92BAA4CB'),
('USER6',			'F73E1A76B1E57F3D'),
('USER7',			'3E9C94488C1A3908'),
('USER8',			'D148049C2780B869'),
('USER9',			'0487AFEE55ECEE66'),
('UTLBSTATU',			'C42D1FA3231AB025'),
('VIDEOUSER',			'29ECA1F239B0F7DF'),
('VIF_DEVELOPER',		'9A7DCB0C1D84C488'),
('VIRUSER',			'404B03707BF5CEA3'),
('VRR1',			'811C49394C921D66'),
('WEBDB',			'D4C4DCDD41B05A5D'),
('WKSYS',			'545E13456B7DDEA0'))
AND   account_status <> 'EXPIRED & LOCKED'
ORDER BY username
]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
    </QueryDescriptor>
  </Metric>

  <Metric NAME="systemPrivileges" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
	<CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
    <Display>
      <Label NLSID="system_privileges">System Privileges for Public Role</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
SELECT  DISTINCT 'PUBLIC has SYSTEM privilege', privilege
FROM	dba_sys_privs d,
	(	SELECT DISTINCT(granted_role)
		FROM dba_role_privs
		START WITH grantee = 'PUBLIC'
		CONNECT BY PRIOR granted_role = grantee
	UNION
		SELECT 'PUBLIC' AS granted_role FROM dual
	) r
WHERE r.granted_role = d.grantee
]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>
  </Metric>

  <Metric NAME="executePrivileges" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
	<CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
    <Display>
      <Label NLSID="execute_privilege">Object Execute Privilege for Public Role</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
SELECT 'PUBLIC can execute', d.table_name
FROM	dba_tab_privs d,
	(	SELECT DISTINCT(granted_role)
		FROM dba_role_privs
		START WITH grantee = 'PUBLIC'
		CONNECT BY PRIOR granted_role = grantee
	UNION
		SELECT 'PUBLIC' AS granted_role FROM dual
	) r
WHERE		r.granted_role = d.grantee
	AND	d.table_name IN ('DBMS_RANDOM', 'UTL_SMTP', 'UTL_HTTP', 'UTL_TCP', 'UTL_FILE')
ORDER BY d.table_name
]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>
  </Metric>

  <Metric NAME="unlimitedFailedLoginAttempts" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="8iR2;9i;9iR2;10gR1;10gR2"/>
	<CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
    <Display>
      <Label NLSID="unlimited_login_attempts">Number of Failed Login Attempts</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
SELECT 'Unlimited login attempts', u.username
FROM dba_users u, dba_profiles p
WHERE		p.resource_name = 'FAILED_LOGIN_ATTEMPTS'
	AND	u.profile = p.profile
	AND	p.limit = 'UNLIMITED'
ORDER BY u.username
]]>
      </Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>
  </Metric>

  <Metric NAME="testPrivileges" TYPE="RAW" CONFIG="TRUE" KEYS_ONLY="TRUE" HELP="NO_HELP" >
    <!-- The use of ValidIf causes the agent to connect to the database
         and this metric is designed to indicate if the agent is having
         problems connecting to the database. As a result, this metric
         cannot have a ValidIf element because it would prevent the
         execution of the metric because of the issue the metric was
         designed to detect. -->
    <ValidIf>
	<CategoryProp NAME="VersionCategory" CHOICES="8iR2;9i;9iR2;10gR1;10gR2"/>
	<CategoryProp NAME="RACOption" CHOICES="NO"/>
    </ValidIf>
    <Display>
      <Label NLSID="sufficient_dbsnmp_privilege">DBSNMP Privilege</Label>
    </Display>
    <TableDescriptor TABLE_NAME="esm_collection">
      <ColumnDescriptor NAME="property" COLUMN_NAME="property" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
      <ColumnDescriptor NAME="value" COLUMN_NAME="value" TYPE="STRING" IS_KEY="TRUE" HELP="NO_HELP">
      </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
DECLARE
  property     VARCHAR2(30);
  value     VARCHAR2(1000);

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor    data_cursor_type;

BEGIN
    -- Metric remoteRolesAndAuthentication
    -- Metric remoteLoginPasswordFile
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM sys.v_$parameter where ROWNUM = 1';

    -- Metric installAndDemoAcccounts
    -- Metric defaultAccountPasswords
    -- Metric unlimitedFailedLoginAttempts
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dba_users where ROWNUM = 1';

    -- Metric systemPrivileges
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dba_sys_privs where ROWNUM = 1';

    -- Metric executePrivileges
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dba_tab_privs where ROWNUM = 1';

    -- Metric systemPrivileges
    -- Metric executePrivileges
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dba_role_privs where ROWNUM = 1';

    -- Metric unlimitedFailedLoginAttempts
    EXECUTE IMMEDIATE 'SELECT COUNT(*) FROM dba_profiles where ROWNUM = 1';

    property := 'no_tests';
      value := 'no_error';
    OPEN data_cursor FOR
    SELECT     property,
        value
    FROM dual;

    :1 := data_cursor;

EXCEPTION
  WHEN OTHERS -- goes if ANY errors (should we check for privilege(s) related only ?)
  THEN
    BEGIN
    property := 'no_tests';
      value := 'Insufficient DBSNMP privilege';
--      value := SQLERRM;

      -- DBMS_OUTPUT.PUT_LINE('Caught exception ' || msg);

    -- open the cursor to return
    OPEN data_cursor FOR
    SELECT     property,
        value
    FROM dual;

    :1 := data_cursor;
    END;
END;
]]>
      </Property>

      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
      <Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
      <Property NAME="password" SCOPE="INSTANCE">password</Property>
      <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>

    </QueryDescriptor>

  </Metric>

<!-- ************** SQLUDM metrics (Begin) ************** -->
  <!--
  ======================================================================
  == Category:         SQLUDM metrics
  == Comment:          Keep R1 SQLUDM definition for backward compatibility
  ======================================================================
  -->

  <Metric NAME="SQLUDM" TYPE="TABLE"
          KEYS_FROM_MULT_COLLS="TRUE" >
    <Display>
      <Label NLSID="database_udm">User-Defined SQL Metrics</Label>
    </Display>
    <TableDescriptor>
      <ColumnDescriptor NAME="ID" TYPE="STRING" IS_KEY="TRUE">
        <Display >
          <Label NLSID="database_udm_id">Script</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="NumValue" TYPE="NUMBER" IS_KEY="FALSE" >
        <Display>
          <Label NLSID="database_udm_value">User-Defined Numeric Metric</Label>
        </Display>
      </ColumnDescriptor>

      <ColumnDescriptor NAME="StrValue" TYPE="STRING" IS_KEY="FALSE">
        <Display >
          <Label NLSID="database_udm_strvalue">User-Defined String Metric</Label>
        </Display>
      </ColumnDescriptor>
      <ColumnDescriptor NAME="Message" TYPE="STRING" IS_KEY="FALSE" TRANSIENT="TRUE">
        <Display>
          <Label NLSID="database_udm_message">Message</Label>
        </Display>
      </ColumnDescriptor>

    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
DECLARE
  udm_id                   VARCHAR2(30) := :1;
  value_type               VARCHAR2(16) := :2;
  sql_stmt                 VARCHAR2(32767) := :3;

  number_value             NUMBER;
  string_value             VARCHAR2(32767);
  err_msg                  VARCHAR2(130);
  ret_msg                  VARCHAR2(100);

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;
  sql_cursor  data_cursor_type;

BEGIN

  sql_stmt := RTRIM(LTRIM(sql_stmt));

  WHILE SUBSTR(sql_stmt, length(sql_stmt)) = ';' LOOP
    sql_stmt := SUBSTR(sql_stmt, 0, length(sql_stmt)-1);
    sql_stmt := RTRIM(sql_stmt);
  END LOOP;

  IF upper(SUBSTR(sql_stmt, 1, 6)) != 'SELECT' THEN
    sql_stmt := 'SELECT ' || sql_stmt || ' FROM DUAL';
  END IF;
  
  dbms_output.put_line('sql_stmt : ' || sql_stmt);

  EXECUTE IMMEDIATE sql_stmt;

  IF value_type = 'NUMBER' THEN
  
    -- NUMBER TYPE
    -- open the cursor to return

    OPEN sql_cursor FOR  -- open cursor variable
      sql_stmt;
    FETCH sql_cursor INTO number_value;
    CLOSE sql_cursor;

    ret_msg := 'User Defined Metric ' || udm_id || ' returned a value of ' || number_value || '.';

    OPEN data_cursor FOR
      SELECT udm_id, number_value, null, ret_msg FROM DUAL;

  ELSIF value_type = 'STRING' THEN

    -- STRING TYPE
    -- open the cursor to return

    OPEN sql_cursor FOR  -- open cursor variable
      sql_stmt;
    FETCH sql_cursor INTO string_value;
    CLOSE sql_cursor;

    ret_msg := 'User Defined Metric ' || udm_id || ' returned a value of ' || string_value || '.';

    OPEN data_cursor FOR
      SELECT udm_id, null, string_value, ret_msg FROM DUAL;

  ELSE
    -- WRONG TYPE
    err_msg := udm_id || ': Wrong type!';
    raise_application_error(-20101, err_msg);
  END IF;

  :4 := data_cursor;

END;
]]>
      </Property>
      <Property NAME="SQLINPARAM1" SCOPE="USER">ID</Property>
      <Property NAME="SQLINPARAM2" SCOPE="USER">valuetype</Property>
      <Property NAME="SQLINPARAM3" SCOPE="USER">sqlstmt</Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">4</Property>
      <Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
      <Property NAME="UserName" SCOPE="USER">UserName</Property>
      <Property NAME="password" SCOPE="USER">password</Property>
      <Property NAME="Role" SCOPE="USER" OPTIONAL="TRUE">Role</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
    </QueryDescriptor>
  </Metric>

  <!--
  ======================================================================
  == Category:         SQLUDM metrics
  == Comment:          R2 SQLUDM supports multiple data return
  ======================================================================
  -->

  <Metric NAME="SQLUDMSTR" TYPE="TABLE"
          KEYS_FROM_MULT_COLLS="TRUE" >
    <Display>
      <Label NLSID="database_udm_str">User-Defined SQL Metrics</Label>
    </Display>
    <TableDescriptor>
      <ColumnDescriptor NAME="ID" TYPE="STRING" IS_KEY="TRUE">
       <Display >
          <Label NLSID="database_udm_str_id">Metric ID</Label>
        </Display>
       </ColumnDescriptor>

      <ColumnDescriptor NAME="Key" TYPE="STRING" IS_KEY="TRUE">
        <Display >
          <Label NLSID="database_udm_str_key">Key</Label>
        </Display>
       </ColumnDescriptor>

      <ColumnDescriptor NAME="StrValue" TYPE="STRING" IS_KEY="FALSE">
        <Display >
          <Label NLSID="database_udm_str_strvalue">User-Defined String Metric</Label>
        </Display>
       </ColumnDescriptor>

      <ColumnDescriptor NAME="NumValue" TYPE="NUMBER" IS_KEY="FALSE">
        <Display >
          <Label NLSID="database_udm_str_numvalue">User-Defined Numeric Metric</Label>
        </Display>
       </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
DECLARE
  udm_id                   VARCHAR2(30) := :1;
  sql_stmt                 VARCHAR2(32767) := :2;
  key_type                 VARCHAR2(16) := :3;

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  sql_stmt := RTRIM(LTRIM(sql_stmt));

  WHILE SUBSTR(sql_stmt, length(sql_stmt)) = ';' LOOP
    sql_stmt := SUBSTR(sql_stmt, 0, length(sql_stmt)-1);
    sql_stmt := RTRIM(sql_stmt);
  END LOOP;

  IF upper(SUBSTR(sql_stmt, 1, 6)) != 'SELECT' 
    OR key_type = 'NULL' THEN
     sql_stmt := 'SELECT ''seudo_key'', (' || sql_stmt || ') FROM DUAL';
  END IF;
  
  -- dbms_output.put_line('sql_stmt : ' || sql_stmt);

  -- STRING TYPE
  sql_stmt := ' SELECT ''' || udm_id || ''', t.* from (' || sql_stmt || ') t';

  -- dbms_output.put_line('ret_stmt: ' || sql_stmt);

  OPEN data_cursor FOR
    sql_stmt;

  :4 := data_cursor;

END;
]]>
      </Property>
      <Property NAME="SQLINPARAM1" SCOPE="USER">ID</Property>
      <Property NAME="SQLINPARAM2" SCOPE="USER">sqlstmt</Property>
      <Property NAME="SQLINPARAM3" SCOPE="USER">keytype</Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">4</Property>
      <Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
      <Property NAME="UserName" SCOPE="USER">UserName</Property>
      <Property NAME="password" SCOPE="USER">password</Property>
      <Property NAME="Role" SCOPE="USER" OPTIONAL="TRUE">Role</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="valuetype" SCOPE="USER" OPTIONAL="TRUE">valuetype</Property>
    </QueryDescriptor>
  </Metric>

  <Metric NAME="SQLUDMNUM" TYPE="TABLE"
          KEYS_FROM_MULT_COLLS="TRUE" >
    <Display>
      <Label NLSID="database_udm_num">User-Defined SQL Metrics</Label>
    </Display>
    <TableDescriptor>
      <ColumnDescriptor NAME="ID" TYPE="STRING" IS_KEY="TRUE">
       <Display >
          <Label NLSID="database_udm_num_id">Metric ID</Label>
        </Display>
       </ColumnDescriptor>

      <ColumnDescriptor NAME="Key" TYPE="STRING" IS_KEY="TRUE">
        <Display >
          <Label NLSID="database_udm_num_key">Key</Label>
        </Display>
       </ColumnDescriptor>

      <ColumnDescriptor NAME="NumValue" TYPE="NUMBER" IS_KEY="FALSE">
        <Display >
          <Label NLSID="database_udm_num_numvalue">User-Defined Numeric Metric</Label>
        </Display>
       </ColumnDescriptor>

      <ColumnDescriptor NAME="StrValue" TYPE="STRING" IS_KEY="FALSE">
        <Display >
          <Label NLSID="database_udm_num_strvalue">User-Defined String Metric</Label>
        </Display>
       </ColumnDescriptor>
    </TableDescriptor>

    <QueryDescriptor FETCHLET_ID="SQL">
      <Property NAME="STATEMENT" SCOPE="GLOBAL">
<![CDATA[
DECLARE
  udm_id                   VARCHAR2(30) := :1;
  sql_stmt                 VARCHAR2(32767) := :2;
  key_type                 VARCHAR2(16) := :3;

  TYPE        data_cursor_type IS REF CURSOR;
  data_cursor data_cursor_type;

BEGIN

  sql_stmt := RTRIM(LTRIM(sql_stmt));

  WHILE SUBSTR(sql_stmt, length(sql_stmt)) = ';' LOOP
    sql_stmt := SUBSTR(sql_stmt, 0, length(sql_stmt)-1);
    sql_stmt := RTRIM(sql_stmt);
  END LOOP;

  IF upper(SUBSTR(sql_stmt, 1, 6)) != 'SELECT' 
    OR key_type = 'NULL' THEN
     sql_stmt := 'SELECT ''seudo_key'', (' || sql_stmt || ') FROM DUAL';
  END IF;
  
  -- dbms_output.put_line('sql_stmt : ' || sql_stmt);
  
  -- NUMBER TYPE
  sql_stmt := ' SELECT ''' || udm_id || ''', t.* from (' || sql_stmt || ') t';

  -- dbms_output.put_line('ret_stmt: ' || sql_stmt);

  OPEN data_cursor FOR
    sql_stmt;

  :4 := data_cursor;

END;
]]>
      </Property>
      <Property NAME="SQLINPARAM1" SCOPE="USER">ID</Property>
      <Property NAME="SQLINPARAM2" SCOPE="USER">sqlstmt</Property>
      <Property NAME="SQLINPARAM3" SCOPE="USER">keytype</Property>
      <Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">4</Property>
      <Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
      <Property NAME="UserName" SCOPE="USER">UserName</Property>
      <Property NAME="password" SCOPE="USER">password</Property>
      <Property NAME="Role" SCOPE="USER" OPTIONAL="TRUE">Role</Property>
      <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
      <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
      <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
      <Property NAME="valuetype" SCOPE="USER" OPTIONAL="TRUE">valuetype</Property>
    </QueryDescriptor>
  </Metric>
  
   <!-- 
  ======================================================================
  == Category:         Storage
  == Collection Level: Minimum
  == Purpose:          Count of segment advisor recommendations
  ======================================================================
    

  --> 
 <Metric NAME="segment_advisor_count" TYPE="TABLE">
    <ValidIf>
      <CategoryProp NAME="VersionCategory" CHOICES="10gR2" /> 
    </ValidIf>
    <Display>
      <Label NLSID="segment_advisor_count">Segment Advisor Recommendations</Label> 
    </Display>
    <TableDescriptor>
      <ColumnDescriptor NAME="recommendations" TYPE="NUMBER" IS_KEY="FALSE">
        <Display>
          <Label NLSID="database_stg_segAdv_count">Number of recommendations</Label> 
        </Display>
      </ColumnDescriptor>
     </TableDescriptor>
     <QueryDescriptor FETCHLET_ID="SQL">
       <Property NAME="STATEMENT" SCOPE="GLOBAL">
       <![CDATA[ SELECT count(*) FROM table(dbms_space.asa_recommendations('TRUE', 'TRUE', 'FALSE'))     
        ]]> 
        </Property>
        <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property> 
        <Property NAME="Port" SCOPE="INSTANCE">Port</Property> 
        <Property NAME="SID" SCOPE="INSTANCE">SID</Property> 
        <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property> 
        <Property NAME="password" SCOPE="INSTANCE">password</Property> 
        <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property> 
      </QueryDescriptor>
  </Metric>

<!-- ************** SQLUDM metrics (End) ************** -->

<!--  RAC Interconnects colletion. RAC instance only -->
	<Metric NAME="ha_rac_intrconn" TYPE="RAW" CONFIG="TRUE">
		<ValidIf>
  		     <CategoryProp NAME="VersionCategory" CHOICES="10gR2"/>
             <CategoryProp NAME="RACOption" CHOICES="YES"/>
		</ValidIf>
		<Display>
			<Label NLSID="ha_rac_intrconn">mgmt_ha_rac_intrconn</Label>
		</Display>
		<TableDescriptor TABLE_NAME="MGMT_HA_RAC_INTR_CONN">
			<ColumnDescriptor NAME="ic_name" COLUMN_NAME="ic_name" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="ha_cls_intrconn_ic_name">Interconnect Name</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="ic_ip" COLUMN_NAME="ic_ip" TYPE="STRING" IS_KEY="TRUE">
				<Display>
					<Label NLSID="ha_cls_intrconn_ic_ip">IP Address</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="ic_public" COLUMN_NAME="ic_public" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_cls_intrconn_ic_public">Public</Label>
				</Display>
			</ColumnDescriptor>
			<ColumnDescriptor NAME="ic_source" COLUMN_NAME="ic_source" TYPE="STRING" IS_KEY="FALSE">
				<Display>
					<Label NLSID="ha_cls_intrconn_ic_source">Source</Label>
				</Display>
			</ColumnDescriptor>
		</TableDescriptor>
		<QueryDescriptor FETCHLET_ID="SQL">
			<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
  SELECT a.name, a.ip_address, b.is_public, b.source 
  FROM v$cluster_interconnects a, v$configured_interconnects b
  WHERE a.name = b.name AND a.ip_address = b.ip_address
]]></Property>
			<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
			<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
			<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
			<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
			<Property NAME="password" SCOPE="INSTANCE">password</Property>
			<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
		</QueryDescriptor>
	</Metric>


	<CredentialInfo>
		<!-- Credential type for database credentials: username/password/role -->
		<CredentialType NAME="DBCreds">
			<Display>
				<Label NLSID="CREDS_DATABASE_DBCREDS">Database Credentials</Label>
			</Display>
			<CredentialTypeColumn NAME="DBUserName" IS_KEY="TRUE">
				<Display>
					<Label NLSID="CREDS_DATABASE_USERNAME">UserName</Label>
				</Display>
			</CredentialTypeColumn>
			<CredentialTypeColumn NAME="DBPassword">
				<Display>
					<Label NLSID="CREDS_DATABASE_PASSWORD">Password</Label>
				</Display>
			</CredentialTypeColumn>
			<CredentialTypeColumn NAME="DBRole">
				<Display>
					<Label NLSID="CREDS_DATABASE_ROLE">Role</Label>
				</Display>
			</CredentialTypeColumn>
		</CredentialType>
		<!-- Credential type for DB Host credentials, refers to credentials
       - on the host the database is on
    -->
		<CredentialType NAME="DBHostCreds">
			<Display>
				<Label NLSID="CREDS_DATABASE_DBCREDS">Database Host Credentials</Label>
			</Display>
			<CredentialTypeRef REF_NAME="HostRef" REF_TYPE="HostCreds" REF_TARGETTYPE="host" ASSOCIATION="host">
				<CredentialTypeRefColumn NAME="HostUserName" REF_TYPECOLUMN="HostUserName"/>
				<CredentialTypeRefColumn NAME="HostPassword" REF_TYPECOLUMN="HostPassword"/>
			</CredentialTypeRef>
		</CredentialType>
		<!-- The NORMAL credential set -->
		<CredentialSet NAME="DBCredsNormal" CREDENTIAL_TYPE="DBCreds" USAGE="PREFERRED_CRED">
			<CredentialSetColumn TYPE_COLUMN="DBUserName" SET_COLUMN="username">
				<Display>
					<Label NLSID="CREDS_NORMAL_USER">UserName</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="DBPassword" SET_COLUMN="password">
				<Display>
					<Label NLSID="CREDS_NORMAL_PASSWORD">Password</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="DBRole" SET_COLUMN="role">
				<Display>
					<Label NLSID="CREDS_NORMAL_ROLE">Password</Label>
				</Display>
			</CredentialSetColumn>
		</CredentialSet>
		<!-- The SYSDBA credential set -->
		<CredentialSet NAME="DBCredsSYSDBA" CREDENTIAL_TYPE="DBCreds" USAGE="PREFERRED_CRED">
			<CredentialSetColumn TYPE_COLUMN="DBUserName" SET_COLUMN="sysDBAUserName">
				<Display>
					<Label NLSID="CREDS_SYSDBA_USER">SYSDBA UserName</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="DBPassword" SET_COLUMN="sysDBAPassword">
				<Display>
					<Label NLSID="CREDS_SYSDBA_PASSWORD">SYSDBA Password</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="DBRole" SET_COLUMN="sysDBARole">
				<Display>
					<Label NLSID="CREDS_SYSDBA_ROLE">Password</Label>
				</Display>
			</CredentialSetColumn>
		</CredentialSet>
		<!-- The monitoring credential set -->
		<CredentialSet NAME="DBCredsMonitoring" CREDENTIAL_TYPE="DBCreds" USAGE="MONITORING">
			<CredentialSetColumn TYPE_COLUMN="DBUserName" SET_COLUMN="UserName">
				<Display>
					<Label NLSID="CREDS_MON_USER">Monitoring UserName</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="DBPassword" SET_COLUMN="password">
				<Display>
					<Label NLSID="CREDS_MON_PASSWORD">Monitoring Password</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="DBRole" SET_COLUMN="Role">
				<Display>
					<Label NLSID="CREDS_MON_ROLE">Monitoring Role</Label>
				</Display>
			</CredentialSetColumn>
		</CredentialSet>
		<!-- The DB host credentials credential set -->
		<CredentialSet NAME="DBHostCreds" CREDENTIAL_TYPE="DBHostCreds" USAGE="PREFERRED_CRED">
			<CredentialSetColumn TYPE_COLUMN="HostUserName" SET_COLUMN="HostUsername">
				<Display>
					<Label NLSID="CREDS_HOST_USER">Host UserName</Label>
				</Display>
			</CredentialSetColumn>
			<CredentialSetColumn TYPE_COLUMN="HostPassword" SET_COLUMN="HostPassword">
				<Display>
					<Label NLSID="CREDS_HOST_PASSWORD">Host Password</Label>
				</Display>
			</CredentialSetColumn>
		</CredentialSet>
	</CredentialInfo>
	<InstanceProperties>
		<InstanceProperty NAME="OracleHome" CREDENTIAL="FALSE" OPTIONAL="FALSE">
			<Display>
				<Label NLSID="OracleHome_iprop">Oracle home path</Label>
			</Display>
		</InstanceProperty>
		<InstanceProperty NAME="UserName" CREDENTIAL="TRUE" OPTIONAL="FALSE" NEED_REENTER="FALSE" HIDE_ENTRY="FALSE">
			<Display>
				<Label NLSID="UserName_iprop">Username</Label>
			</Display>
		</InstanceProperty>
		<InstanceProperty NAME="password" CREDENTIAL="TRUE" OPTIONAL="FALSE" NEED_REENTER="TRUE">
			<Display>
				<Label NLSID="password_iprop">Password</Label>
			</Display>
		</InstanceProperty>
		<InstanceProperty NAME="Role" CREDENTIAL="FALSE" OPTIONAL="TRUE">
			<Display>
				<Label NLSID="role_iprop">Role</Label>
			</Display>
		</InstanceProperty>
		<InstanceProperty NAME="MachineName" CREDENTIAL="FALSE" OPTIONAL="FALSE">
			<Display>
				<Label NLSID="MachineName_iprop">Listener Machine Name</Label>
			</Display>
		</InstanceProperty>
		<InstanceProperty NAME="Port" CREDENTIAL="FALSE" OPTIONAL="FALSE">
			<Display>
				<Label NLSID="Port_iprop">Port</Label>
			</Display>
		</InstanceProperty>
		<InstanceProperty NAME="SID" CREDENTIAL="FALSE" OPTIONAL="FALSE">
			<Display>
				<Label NLSID="SID_iprop">Database SID</Label>
			</Display>
		</InstanceProperty>

   <!--
   ======================================================================
   == Dynamic Properties: SYSTEM tablespace numbers
   == (can be used to improve performance on any query requiring the 
   ==  SYSTEM tablespaces. currently used in db_recSegmentSettings_sysseg)
   ======================================================================
   -->
		<DynamicProperties NAME="SystemTablespaceNumber" FORMAT="ROW" PROP_LIST="SystemTs#">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT ts# "SystemTs#" FROM sys.ts$ WHERE name = 'SYSTEM'
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			</QueryDescriptor>
		</DynamicProperties>  

   <!--
   ======================================================================
   == Dynamic Properties: SYSAUX tablespace number
   == (can be used to improve performance on any query requiring the 
   ==  SYSAUX tablespaces. currently used in db_recSegmentSettings_sysseg)
   == NOTE: If the SYSAUX tablespace does not exist -1 is returned
   ======================================================================
   -->
		<DynamicProperties NAME="SysauxTablespaceNumber" FORMAT="ROW" PROP_LIST="SysauxTs#">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT
  nvl(a.ts#, -1) "SysauxTs#"
FROM
  (select ts#,name from sys.ts$ where name = 'SYSAUX') a,
  (select 'SYSAUX' name from dual) b
WHERE
  a.name(+) = b.name 
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
			</QueryDescriptor>
		</DynamicProperties>  
		<!--
    ======================================================================
    == Dynamic Properties: MonitorConfigStatus
    == (check for statspack and packages under dbsnmp for db monitoring)
    ======================================================================
      -->
		<DynamicProperties NAME="MonitorConfigStatus" FORMAT="ROW" PROP_LIST="MCSpInst;MCResponse;MCPkg">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
DECLARE
   r              VARCHAR2(80);
   v              VARCHAR2(300);
   v_db_version   VARCHAR2(10);
   db_version_9i  CONSTANT VARCHAR2(10) := '09.0.0.0.0';
   db_version_10  CONSTANT VARCHAR2(10) := '10.0.0.0.0';
   id             NUMBER;
   iid            NUMBER;
   level          NUMBER;
   sp_pkg           VARCHAR2(2);
   dbsnmp_response  VARCHAR2(2);
   pkg_state      NUMBER;
   TYPE data_cursor_type IS REF CURSOR;
   data_cursor    data_cursor_type;
   TYPE obj_cursor_type IS REF CURSOR;
   obj_cursor    obj_cursor_type;
   oname         VARCHAR2(50);
BEGIN
   sp_pkg               := '0';
   dbsnmp_response      := '0';
   pkg_state            := 0;

   -- refresh the session to get the latest privileges
   BEGIN
      r := 'set role all';
      execute immediate r;
   EXCEPTION
    when others then  dbms_output.put_line(SQLERRM);
   END;

   SELECT LPAD(version, 10, '0') INTO v_db_version FROM v$instance;

   -- check for mgmt_response for version >= 9i
   IF v_db_version >= db_version_9i THEN
    BEGIN
      r := 'declare a varchar2(50); begin a := dbsnmp.mgmt_response.getVersion; end;';     
      execute immediate r;
      dbsnmp_response := '1';
      --- 2^1 - 2 is used for response;
      pkg_state := pkg_state + 2;
    EXCEPTION
        when others then   dbsnmp_response := '0';
    END;
   END IF;

  -- check perfstat.statspack 
  IF (v_db_version < db_version_10) THEN       
    OPEN obj_cursor FOR
                   'SELECT o.name FROM sys.obj$ o, sys.user$ u 
                    WHERE u.name = ''PERFSTAT'' AND o.owner# = u.user# 
                    AND o.name = ''STATSPACK'' AND o.type# = 11 AND o.status = 1';
    LOOP
       FETCH obj_cursor INTO oname;
       EXIT WHEN obj_cursor%NOTFOUND;
       sp_pkg := '1';
    END LOOP;
    CLOSE obj_cursor;

    -- if statspack exists, check for level
    IF (sp_pkg = '1') THEN
      BEGIN
        IF (v_db_version >= db_version_9i) THEN
          SELECT dbid into id FROM v$database;
          SELECT instance_number into iid FROM v$instance;
          v := 'SELECT SNAP_LEVEL FROM PERFSTAT.STATS$STATSPACK_PARAMETER WHERE dbid = :1 AND INSTANCE_NUMBER = :2';
          execute immediate v into level using id, iid;
          IF (level < 6) THEN
            sp_pkg := '0';
          END IF;
        END IF;
      EXCEPTION
        when others then  sp_pkg := '0';
      END;
    END IF;

    IF (sp_pkg = '1') THEN
      --- 2^0 - 1 is used for statspack and level;
      pkg_state := pkg_state + 1;
    END IF;
    
   END IF;
   
   OPEN data_cursor FOR SELECT sp_pkg, dbsnmp_response, to_char(pkg_state) FROM dual;
   :1 := data_cursor;
EXCEPTION
  WHEN others THEN
    OPEN :1 FOR SELECT sp_pkg, dbsnmp_response, to_char(pkg_state) FROM dual;
    dbms_output.put_line('Error executing db monitor config checking');
    dbms_output.put_line(SQLERRM);
END;
]]></Property>
				<Property NAME="SQLOUTPARAMPOS" SCOPE="GLOBAL">1</Property>
				<Property NAME="SQLOUTPARAMTYPE" SCOPE="GLOBAL">SQL_CURSOR</Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
       
			</QueryDescriptor>
		</DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: Config
    ======================================================================
      -->
		<DynamicProperties NAME="Config" FORMAT="ROW" PROP_LIST="DBName;InstanceName;StartTime;TimeFormat;Version;TimedStatistics;OpenMode">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT d.database_name "DBName",
       i.instance_name "InstanceName",
       TO_CHAR(i.startup_time, f.time_format) "StartTime",
       f.time_format "TimeFormat",
       i.version "Version",
       p.value "TimedStatistics",
       r.open_mode "OpenMode"
  FROM (SELECT name, value database_name
          FROM v$parameter
         WHERE (name = 'db_unique_name'
             OR name = 'db_name')
           AND value IS NOT NULL
         ORDER BY name DESC) d,
       v$instance i,
       v$version v,
       v$parameter p,
       v$database r,
       (SELECT :1 time_format
          FROM dual) f
 WHERE v.banner LIKE 'Oracle%'
   AND p.name = 'timed_statistics'
   AND ROWNUM = 1
]]></Property>
				<Property NAME="SQLINPARAM1" SCOPE="GLOBAL">YYYY-MM-DD HH24:MI:SS</Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
       
			</QueryDescriptor>
		</DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: GetDumpDestination
    ======================================================================
      -->
    <DynamicProperties NAME="GetDumpDestination" PROP_LIST="background_dump_dest;user_dump_dest;core_dump_dest">
    	<QueryDescriptor FETCHLET_ID="SQL">
    		<Property NAME="STATEMENT" SCOPE="GLOBAL">
    		<![CDATA[
                SELECT name, DECODE(sid_var_pos, 0, value, SUBSTR(value, 1,
                sid_var_pos)||:1||SUBSTR(value, sid_var_pos + sid_var_len, value_len))
                value
                FROM (SELECT name, value, LENGTH(sid_var) sid_var_len, INSTR(value,
                      sid_var) sid_var_pos, LENGTH(value) value_len
                      FROM (SELECT name, value, :2 sid_var FROM v$parameter WHERE name LIKE
                      '%_dump_dest'))
            ]]></Property>
            <Property NAME="SQLINPARAM1" SCOPE="INSTANCE">SID</Property>
            <Property NAME="SQLINPARAM2" SCOPE="GLOBAL">$ORACLE_SID</Property>
    		<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
    		<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
    		<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
    		<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
    		<Property NAME="password" SCOPE="INSTANCE">password</Property>
    		<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
      
    	</QueryDescriptor>
    </DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: GetArchiveDestination
    ======================================================================
      -->
		<DynamicProperties NAME="GetArchiveDestination" FORMAT="ROW" PROP_LIST="log_archive_mode">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
select log_mode from v$database
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
       
			</QueryDescriptor>
		</DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: GetD(ata)B(ase)Version
    ======================================================================
      -->
		<DynamicProperties NAME="GetDBVersion" FORMAT="ROW" PROP_LIST="DBVersion">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
select version from v$instance
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
       
			</QueryDescriptor>
		</DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: ComputeV(ersion)C(ategory)
    ======================================================================
      -->
		<DynamicProperties NAME="ComputeVC" FORMAT="ROW" PROP_LIST="VersionCategory">
			<QueryDescriptor FETCHLET_ID="VersionRangeComputer">
				<Property NAME="Version" SCOPE="INSTANCE">DBVersion</Property>
				<Property NAME="pre8" SCOPE="GLOBAL">;8.0.0</Property>
				<Property NAME="8i" SCOPE="GLOBAL">8.0.5;</Property>
				<Property NAME="8iR2" SCOPE="GLOBAL">8.1.5;9.0.0</Property>
				<Property NAME="9i" SCOPE="GLOBAL">9.0.1;</Property>
				<Property NAME="9iR2" SCOPE="GLOBAL">9.2.0;</Property>
				<Property NAME="10gR1" SCOPE="GLOBAL">10.1.0.2;</Property>
				<Property NAME="10gR2" SCOPE="GLOBAL">10.2.0;</Property>
       
			</QueryDescriptor>
		</DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: GetCPUCount
    ======================================================================
      -->
		<DynamicProperties NAME="GetCPUCount" FORMAT="ROW" PROP_LIST="CPUCount">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
select value from v$parameter where name='cpu_count'
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
       
			</QueryDescriptor>
		</DynamicProperties>

    <!--
    ======================================================================
    == Dynamic Properties: CPU Timing Enabled
    ======================================================================
      -->
    <DynamicProperties NAME="PlatformLimitations"
                       FORMAT="ROW"
                       PROP_LIST="CPUTimingEnabled">
      <ValidIf>
        <CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
      </ValidIf>

      <QueryDescriptor FETCHLET_ID="SQL">
        <Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
SELECT DECODE(COUNT(*), 0, 'FALSE', 'TRUE') "CPUTimingEnabled"
  FROM v$osstat
 WHERE stat_name = 'IDLE_TICKS'
]]></Property>
        <Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
        <Property NAME="Port" SCOPE="INSTANCE">Port</Property>
        <Property NAME="SID" SCOPE="INSTANCE">SID</Property>
        <Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
        <Property NAME="password" SCOPE="INSTANCE">password</Property>
        <Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
         
      </QueryDescriptor>
    </DynamicProperties>

		<!--
    ======================================================================
    == Dynamic Properties: GetOSMInstance
    ======================================================================
      -->
		<DynamicProperties NAME="GetOSMInstance" FORMAT="ROW" PROP_LIST="OSMInstance">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			</ValidIf>
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
select *
  from (select instance_name
          from (select ' ' instance_name from dual
                union all
                select instance_name from v$asm_client)
         order by instance_name desc)
 where rownum = 1
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
        
			</QueryDescriptor>
		</DynamicProperties>
		<!--
    ======================================================================
    == Dynamic Properties: RAC OPTION
    ======================================================================
      -->
		<DynamicProperties NAME="CheckRAC" FORMAT="ROW" PROP_LIST="RACOption">
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
select parallel from v$instance
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
        
			</QueryDescriptor>
		</DynamicProperties>

		<DynamicProperties NAME="GetDataGuardStatus" FORMAT="ROW" PROP_LIST="DataGuardStatus">
		<ValidIf>
			<CategoryProp NAME="VersionCategory" CHOICES="9i;9iR2;10gR1;10gR2"/>
		</ValidIf>
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL"><![CDATA[
select case when (((select count(*) from v$archive_dest where target='STANDBY') > 0) OR
(database_role like '%STANDBY')) then initcap(database_role) else ' ' end from v$database
]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
      
			</QueryDescriptor>
		</DynamicProperties>

    <!--
    ======================================================================
    == Dynamic Properties: Server Manageability
    ======================================================================
      -->
		<DynamicProperties NAME="ServerManageability" FORMAT="ROW" PROP_LIST="StatisticsLevel">
			<ValidIf>
				<CategoryProp NAME="VersionCategory" CHOICES="10gR1;10gR2"/>
			</ValidIf>
			<QueryDescriptor FETCHLET_ID="SQL">
				<Property NAME="STATEMENT" SCOPE="GLOBAL">
				<![CDATA[
                select value from v$parameter where name='statistics_level'
                ]]></Property>
				<Property NAME="MachineName" SCOPE="INSTANCE">MachineName</Property>
				<Property NAME="Port" SCOPE="INSTANCE">Port</Property>
				<Property NAME="SID" SCOPE="INSTANCE">SID</Property>
				<Property NAME="UserName" SCOPE="INSTANCE">UserName</Property>
				<Property NAME="password" SCOPE="INSTANCE">password</Property>
				<Property NAME="Role" SCOPE="INSTANCE" OPTIONAL="TRUE">Role</Property>
      
			</QueryDescriptor>
		</DynamicProperties>

	</InstanceProperties>

</TargetMetadata>
